<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Naruto Chakra Network — 2D Silhouette (Three.js)</title>
<style>
  html,body{height:100%;margin:0;background:#0b0f1a;overflow:hidden}
  canvas{display:block}
  #ui{
    position:fixed;left:12px;top:12px;padding:10px 12px;color:#eaeaea;
    background:rgba(0,0,0,.6);border:1px solid #2a2a2a;border-radius:12px;
    font:12px system-ui,-apple-system,Segoe UI,Roboto;backdrop-filter:blur(6px);
    max-width:300px; line-height:1.35; z-index: 5
  }
  #ui h1{margin:.1rem 0 .35rem 0;font-size:14px;font-weight:700;color:#bfe3ff}
  #ui .row{display:flex;align-items:center;justify-content:space-between;margin:.4rem 0}
  #legend{
    position:fixed;right:12px;top:12px;padding:10px 12px;color:#eaeaea;
    background:rgba(0,0,0,.6);border:1px solid #2a2a2a;border-radius:12px;
    font:12px system-ui,-apple-system,Segoe UI,Roboto;backdrop-filter:blur(6px);
    max-width:320px; z-index: 5
  }
  #footer{
    position:fixed;left:12px;bottom:12px;color:#9bb4c9;font:11px system-ui,Segoe UI,Roboto;
    background:rgba(0,0,0,.45);border:1px solid #2a2a2a;padding:6px 8px;border-radius:10px; z-index:5
  }
  .btn {
    padding:5px 8px;border:1px solid #3a3a3a;border-radius:10px;background:#0e1624;color:#bfe3ff;
    cursor:pointer; font-weight:600
  }
  .btn:hover{background:#13203a}
  input[type="number"]{background:#07101a;color:#bfe3ff;border:1px solid #20303a;padding:4px;border-radius:6px}
</style>
<script type="importmap">
{"imports":{
  "three":"https://unpkg.com/three@0.160.0/build/three.module.js",
  "three/examples/jsm/controls/OrbitControls.js":
    "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js"
}}
</script>
</head>
<body>
<div id="ui">
  <h1>Chakra Network — Controls</h1>
  <div class="row"><label><input id="toggleCore" type="checkbox" checked> Core</label></div>
  <div class="row"><label><input id="toggleGates" type="checkbox" checked> 8 Inner Gates</label></div>
  <div class="row"><label><input id="toggleTenketsu" type="checkbox" checked> 361 Tenketsu</label></div>
  <div class="row"><label><input id="toggleChannels" type="checkbox" checked> Channels</label></div>
  <div class="row"><label><input id="toggleGlow" type="checkbox" checked> Glow</label></div>

  <div class="row">
    <label for="count">Tenketsu shown</label>
    <input id="count" type="range" min="0" max="361" value="120" step="1">
  </div>
  <div class="row">
    <label for="density">Channel density</label>
    <input id="density" type="range" min="0" max="1" value="0.35" step="0.01">
  </div>
  <div class="row">
    <label for="ptsize">Point size</label>
    <input id="ptsize" type="range" min="1" max="8" value="4" step="1">
  </div>
  <div class="row">
    <label for="seed">Seed</label>
    <input id="seed" type="number" value="1337" style="width:90px">
    <button id="btnReroll" class="btn" title="Reseed + rebuild">Reroll</button>
  </div>
  <div class="row">
    <button id="btnExport" class="btn">Export PNG</button>
  </div>
  <div style="margin-top:8px;font-size:11px;color:#9bb4c9">Using <code>outline.png</code> in same folder as this HTML.</div>
</div>

<div id="legend">
  <h2 style="margin:.1rem 0 .35rem 0;font-size:13px;color:#bfe3ff">Inner Gates (Hachimon)</h2>
  <ul style="margin:.25rem 0 .1rem 1rem;padding:0;color:#dfefff">
    <li>1. Gate of Opening — brain</li>
    <li>2. Gate of Healing — brain stem</li>
    <li>3. Gate of Life — upper spine</li>
    <li>4. Gate of Pain — mid spine</li>
    <li>5. Gate of Limit — upper abdomen</li>
    <li>6. Gate of View — stomach</li>
    <li>7. Gate of Wonder — lower abdomen</li>
    <li>8. Gate of Death — heart</li>
  </ul>
  <h2 style="margin:.6rem 0 .35rem 0;font-size:13px;color:#bfe3ff">Notes</h2>
  <ul style="margin:.25rem 0 .1rem 1rem;padding:0;color:#dfefff">
    <li><b>361</b> tenketsu (chakra nodes)</li>
    <li>Channels are schematic “meridians”</li>
    <li>Use sliders to tune density & visibility</li>
  </ul>
</div>

<div id="footer">Orthographic view — drag to pan, wheel to zoom</div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

/* -----------------------
   Utilities / DOM helper
   ----------------------- */
const $ = s => document.querySelector(s);

/* =========================
   Scene / Camera / Renderer
   ========================= */
const renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();

// Background gradient in separate scene so we can keep the main scene simple
const bgScene = new THREE.Scene();
const bgCamera = new THREE.OrthographicCamera(-1,1,1,-1,0,1);
const bgGeom = new THREE.PlaneGeometry(2,2);
const bgMat = new THREE.ShaderMaterial({
  depthWrite:false, depthTest:false,
  uniforms:{ uA:{value:new THREE.Color('#070a0f')}, uB:{value:new THREE.Color('#0e1320')} },
  vertexShader:`varying vec2 vUv; void main(){vUv=uv; gl_Position=vec4(position,1.0);}`,
  fragmentShader:`varying vec2 vUv; uniform vec3 uA; uniform vec3 uB;
    void main(){
      float r = smoothstep(0.0,1.0,length(vUv-0.5)*1.2);
      vec3 col = mix(uB, uA, r);
      gl_FragColor = vec4(col,1.0);
    }`
});
bgScene.add(new THREE.Mesh(bgGeom,bgMat));

const camera = new THREE.OrthographicCamera(-1.1, 1.1, 1.8, -1.35, -10, 10);
camera.position.set(0,0,5);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableRotate = false;
controls.zoomSpeed = 1.0;
controls.panSpeed = 1.0;

/* =========================
   Outline-driven silhouette
   - loads outline.png,
   - builds mask (flood-fill),
   - paints silhouette texture,
   - exposes insideBody(x,y)
   ========================= */

// World silhouette size (used by mapping)
const bodyWidth = 1.25;
const bodyHeight = 2.3;

// Canvas to render final silhouette texture (displayed as plane)
const silCanvas = document.createElement('canvas');
silCanvas.width = 1024;
silCanvas.height = 2048;
const ctx = silCanvas.getContext('2d', {willReadFrequently: true});
const silhouetteTex = new THREE.CanvasTexture(silCanvas);
silhouetteTex.minFilter = THREE.LinearFilter;
silhouetteTex.magFilter = THREE.LinearFilter;

// Mask (lower-res) to speed processing
const maskW = 512;
const maskH = 1024;
let mask = null; // Uint8Array length maskW*maskH. 1 = inside, 0 = outside

// precomputed list of inside pixel coords (for fast placement)
let insidePixels = []; // array of {px,py}

// load the outline.png and process
function initMaskFromOutline(url='outline.png'){
  return new Promise((resolve,reject)=>{
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.onload = () => {
      const tmp = document.createElement('canvas');
      tmp.width = maskW; tmp.height = maskH;
      const tctx = tmp.getContext('2d', {willReadFrequently:true});
      tctx.clearRect(0,0,maskW,maskH);
      // Fit the outline image to the mask while preserving aspect
      const arSrc = img.width / img.height;
      const arDst = maskW / maskH;
      let dw = maskW, dh = maskH, dx = 0, dy = 0;
      if (arSrc > arDst){
        dh = maskH;
        dw = Math.round(maskH * arSrc);
        dx = Math.round((maskW - dw) / 2);
      } else {
        dw = maskW;
        dh = Math.round(maskW / arSrc);
        dy = Math.round((maskH - dh) / 2);
      }
      tctx.drawImage(img, dx, dy, dw, dh);

      // read pixels and threshold to binary (outline line pixels)
      const imgd = tctx.getImageData(0,0,maskW,maskH);
      const data = imgd.data;
      const outline = new Uint8Array(maskW*maskH);
      for (let i=0;i<maskW*maskH;i++){
        const r=data[i*4], g=data[i*4+1], b=data[i*4+2], a=data[i*4+3];
        const bright = (r + g + b) / 3;
        if (a > 100 && bright > 40) outline[i]=1; else outline[i]=0;
      }

      // dilate outline to make sure it forms closed boundaries
      const dilated = new Uint8Array(maskW*maskH);
      const radius = 1;
      for (let y=0;y<maskH;y++){
        for (let x=0;x<maskW;x++){
          let any=0;
          for (let oy=-radius; oy<=radius; oy++){
            for (let ox=-radius; ox<=radius; ox++){
              const nx=x+ox, ny=y+oy;
              if (nx<0||nx>=maskW||ny<0||ny>=maskH) continue;
              if (outline[ny*maskW+nx]) { any=1; break; }
            }
            if (any) break;
          }
          dilated[y*maskW + x] = any;
        }
      }

      // Flood-fill from borders to mark outside pixels
      const outside = new Uint8Array(maskW*maskH);
      const q = [];
      for (let x=0;x<maskW;x++){
        const iTop = x;
        const iBot = (maskH-1)*maskW + x;
        if (dilated[iTop] === 0 && !outside[iTop]) { outside[iTop]=1; q.push(iTop); }
        if (dilated[iBot] === 0 && !outside[iBot]) { outside[iBot]=1; q.push(iBot); }
      }
      for (let y=0;y<maskH;y++){
        const iL = y*maskW + 0;
        const iR = y*maskW + (maskW-1);
        if (dilated[iL] === 0 && !outside[iL]) { outside[iL]=1; q.push(iL); }
        if (dilated[iR] === 0 && !outside[iR]) { outside[iR]=1; q.push(iR); }
      }
      while (q.length){
        const idx = q.shift();
        const y = Math.floor(idx / maskW), x = idx % maskW;
        const ns = [[x-1,y],[x+1,y],[x,y-1],[x,y+1]];
        for (const [nx,ny] of ns){
          if (nx<0||nx>=maskW||ny<0||ny>=maskH) continue;
          const ni = ny*maskW + nx;
          if (outside[ni]) continue;
          if (dilated[ni] === 0){ outside[ni]=1; q.push(ni); }
        }
      }

      // inside = not outside
      mask = new Uint8Array(maskW*maskH);
      insidePixels = [];
      for (let i=0;i<maskW*maskH;i++){
        mask[i] = outside[i] ? 0 : 1;
        if (mask[i]) {
          const py = Math.floor(i / maskW), px = i % maskW;
          insidePixels.push({px, py});
        }
      }

      // Sort insidePixels by Y then X so selection is spatially uniform when we pick spaced indices
      insidePixels.sort((a,b)=> (a.py - b.py) || (a.px - b.px));

      resolve();
    };
    img.onerror = (e)=> reject(e);
    img.src = url;
  });
}

// paint silhouette texture from mask into silCanvas (full-res)
function paintSilhouetteTexture(){
  const W = silCanvas.width, H = silCanvas.height;
  const tmp = document.createElement('canvas');
  tmp.width = maskW; tmp.height = maskH;
  const tctx = tmp.getContext('2d');
  const id = tctx.createImageData(maskW, maskH);
  for (let y=0;y<maskH;y++){
    for (let x=0;x<maskW;x++){
      const i = y*maskW + x;
      const di = i*4;
      if (mask[i]){
        id.data[di] = 255; id.data[di+1]=255; id.data[di+2]=255; id.data[di+3]=255;
      } else {
        id.data[di+3]=0;
      }
    }
  }
  tctx.putImageData(id, 0, 0);

  // Clear final canvas
  ctx.clearRect(0,0,W,H);

  // 1) fill black (body)
  ctx.fillStyle = '#000';
  ctx.fillRect(0,0,W,H);

  // 2) apply mask as alpha (destination-in)
  ctx.globalCompositeOperation = 'destination-in';
  ctx.drawImage(tmp, 0, 0, W, H);
  ctx.globalCompositeOperation = 'source-over';

  // 3) halo (soft)
  ctx.save();
  ctx.globalAlpha = 0.28;
  ctx.filter = 'blur(18px)';
  ctx.drawImage(tmp, 0, 0, W, H);
  ctx.restore();

  // 4) faint inner glow
  ctx.save();
  ctx.filter = 'blur(4px)';
  ctx.globalAlpha = 0.08;
  ctx.drawImage(tmp, 0, 0, W, H);
  ctx.restore();

  silhouetteTex.needsUpdate = true;
}

/* Hit test: world (x,y) -> mask coords (same mapping used across file) */
function insideBody(x, y){
  if (!mask) return false;
  const px = Math.round(( (x / bodyWidth) + 0.5) * (maskW - 1));
  const py = Math.round(( ((y - 0.2) / bodyHeight) + 0.5) * (maskH - 1));
  if (px < 0 || px >= maskW || py < 0 || py >= maskH) return false;
  return mask[py*maskW + px] === 1;
}

/* Helper mapping: mask pixel -> world coords (inverse of above) */
function maskToWorld(px, py){
  const x = (px / (maskW - 1) - 0.5) * bodyWidth;
  const y = (py / (maskH - 1) - 0.5) * bodyHeight + 0.2;
  return new THREE.Vector2(x, y);
}

/* =========================
   Chakra data (positions in world coordinates)
   ========================= */
const GATES = [
  {name:'Opening', pos:new THREE.Vector2( 0.00,  1.32)},
  {name:'Healing', pos:new THREE.Vector2( 0.00,  1.16)},
  {name:'Life',    pos:new THREE.Vector2( 0.00,  0.92)},
  {name:'Pain',    pos:new THREE.Vector2( 0.00,  0.65)},
  {name:'Limit',   pos:new THREE.Vector2( 0.00,  0.38)},
  {name:'View',    pos:new THREE.Vector2( 0.00,  0.16)},
  {name:'Wonder',  pos:new THREE.Vector2( 0.00, -0.08)},
  {name:'Death',   pos:new THREE.Vector2(-0.06,  1.02)},
];
const CORE = new THREE.Vector2(0.0, 0.02);

function polyline(arr){ return arr.map(([x,y])=> new THREE.Vector2(x,y)); }
const spine = polyline([[0,1.35],[0,1.18],[0,0.98],[0,0.80],[0,0.62],[0,0.45],[0,0.28],[0,0.10],[0,-0.05],[0,-0.20],[0,-0.35],[0,-0.50],[0,-0.68],[0,-0.86],[0,-1.02]]);
const clavL = polyline([[-0.06,1.12],[-0.14,1.08],[-0.20,1.02]]);
const clavR = polyline([[ 0.06,1.12],[ 0.14,1.08],[ 0.20,1.02]]);
const armL  = polyline([[-0.22,0.98],[-0.27,0.74],[-0.24,0.50],[-0.23,0.30],[ -0.22,0.18]]);
const armR  = polyline([[ 0.22,0.98],[ 0.27,0.74],[ 0.24,0.50],[ 0.23,0.30],[  0.22,0.18]]);
const legL  = polyline([[-0.11,0.98],[-0.12,0.60],[-0.115,0.30],[-0.11,-0.05],[-0.10,-0.45],[ -0.09,-0.90]]);
const legR  = polyline([[ 0.11,0.98],[ 0.12,0.60],[ 0.115,0.30],[ 0.11,-0.05],[ 0.10,-0.45],[  0.09,-0.90]]);
const meridianAnchors = [...spine, ...clavL, ...clavR, ...armL, ...armR, ...legL, ...legR];

/* =========================
   Geometry Layers + params
   ========================= */
const overlay = new THREE.Group(); scene.add(overlay);
let ptsTenketsu = [], meshTenketsu = null;
let meshGates, meshCore, meshChannels, meshMeridians;
const params = { tenketsuCount:120, channelDensity:0.35, pointSize:4, glow:true, seed:1337 };

/* =========================
   RNG & helpers
   ========================= */
function LCG(seed=1337){ let s=(seed>>>0)||1; return ()=>{ s=(1664525*s+1013904223)>>>0; return s/0xFFFFFFFF; } }
function pickK(n,k,rng){ const idxs = Array.from({length:n},(_,i)=>i); for (let i=0;i<k;i++){const j=i+Math.floor(rng()*(n-i)); [idxs[i],idxs[j]]=[idxs[j],idxs[i]];} return idxs.slice(0,k); }

/* =========================
   Build / Render
   ========================= */
function buildAll(){
  while(overlay.children.length) overlay.remove(overlay.children[0]);

  meshCore = makeGlowSprite(CORE, 0.22, 0.65, '#56e1ff');

  meshGates = new THREE.Group();
  for (const g of GATES) meshGates.add(makeGlowSprite(g.pos, 0.14, 0.45, '#6bf5a9'));

  meshMeridians = drawMeridians();

  rebuildTenketsuAndChannels();

  overlay.add(meshMeridians, meshCore, meshGates, meshTenketsu, meshChannels);
  applyVisibility();
}

/* New: build tenketsu by sampling the mask pixel list evenly.
   This ensures each tenketsu is placed on an actual silhouette pixel and distributed evenly. */
function rebuildTenketsuAndChannels(){
  if (!mask || insidePixels.length === 0){
    ptsTenketsu = [];
    meshTenketsu = new THREE.Points(new THREE.BufferGeometry(), new THREE.PointsMaterial({size:params.pointSize}));
    meshChannels = new THREE.LineSegments(new THREE.BufferGeometry(), new THREE.LineBasicMaterial());
    return;
  }

  const rng = LCG(params.seed);

  // Use deterministic selection across the sorted insidePixels array
  // We'll pick up to 361 positions by spacing through the sorted list.
  const totalAvailable = insidePixels.length;
  const requestedTotal = 361; // canonical total we can later show subset of
  const step = Math.max(1, Math.floor(totalAvailable / requestedTotal));
  const chosenPixels = [];
  // start offset randomized by seed to avoid always picking same subset of rows
  const offset = Math.floor(rng() * Math.min(step, totalAvailable));
  for (let i = offset; i < totalAvailable && chosenPixels.length < requestedTotal; i += step){
    chosenPixels.push(insidePixels[i]);
  }
  // If we fell short due to rounding, fill by picking every Nth of remainder
  if (chosenPixels.length < requestedTotal){
    const need = requestedTotal - chosenPixels.length;
    const extra = pickK(totalAvailable, need, rng);
    for (const idx of extra) {
      chosenPixels.push(insidePixels[idx]);
      if (chosenPixels.length >= requestedTotal) break;
    }
  }

  // Map mask pixels to world
  const positions = chosenPixels.map(p => maskToWorld(p.px, p.py));
  ptsTenketsu = positions;

  // Build points geometry
  const geom = new THREE.BufferGeometry();
  const arr = new Float32Array(positions.length * 3);
  for (let i=0;i<positions.length;i++){
    arr[i*3+0]=positions[i].x;
    arr[i*3+1]=positions[i].y;
    arr[i*3+2]=0.001;
  }
  geom.setAttribute('position', new THREE.BufferAttribute(arr,3));

  // round dot texture for nicer tenketsu
  const dot = document.createElement('canvas'); dot.width=dot.height=32;
  const dctx = dot.getContext('2d');
  const grad = dctx.createRadialGradient(16,16,0,16,16,16);
  grad.addColorStop(0,'rgba(143,227,255,1)'); grad.addColorStop(1,'rgba(143,227,255,0)');
  dctx.fillStyle = grad; dctx.fillRect(0,0,32,32);
  const dotTex = new THREE.CanvasTexture(dot);

  const mat = new THREE.PointsMaterial({
    size: params.pointSize, map: dotTex, color: 0xffffff, transparent:true,
    depthWrite:false, blending: params.glow ? THREE.AdditiveBlending : THREE.NormalBlending,
    sizeAttenuation:false
  });
  meshTenketsu = new THREE.Points(geom, mat);

  // drawRange controls how many are visible (UI slider)
  meshTenketsu.geometry.setDrawRange(0, Math.max(0, Math.min(params.tenketsuCount, positions.length)));

  // Channels: connect subset of tenketsu to nearest meridian anchors (same as before)
  meshChannels = drawChannels(positions, params.channelDensity, rng);
}

function drawMeridians(){
  const positions = [];
  function addSegs(poly){
    for (let i=0;i<poly.length-1;i++){
      const a=poly[i], b=poly[i+1];
      positions.push(a.x,a.y,0.002, b.x,b.y,0.002);
    }
  }
  addSegs(spine); addSegs(clavL); addSegs(clavR); addSegs(armL); addSegs(armR); addSegs(legL); addSegs(legR);
  const geom = new THREE.BufferGeometry();
  geom.setAttribute('position', new THREE.Float32BufferAttribute(positions,3));
  const mat = new THREE.LineBasicMaterial({ color:'#57ffd6', transparent:true, opacity:0.65, depthWrite:false, blending: THREE.AdditiveBlending });
  const lines = new THREE.LineSegments(geom, mat);
  lines.frustumCulled = false;
  lines.renderOrder = 1;
  return lines;
}

function drawChannels(points, density, rng){
  const targetCount = Math.floor(points.length * density);
  const anchors = meridianAnchors;
  const segs = [];
  const pick = pickK(points.length, targetCount, rng);
  for (const idx of pick){
    const p = points[idx];
    let best=null, bestD=1e9;
    for (const a of anchors){
      const dx=p.x-a.x, dy=p.y-a.y, d=dx*dx+dy*dy;
      if (d < bestD){ bestD=d; best=a; }
    }
    if (best){
      const mid = new THREE.Vector2((p.x*0.65+best.x*0.35),(p.y*0.65+best.y*0.35));
      segs.push(p.x,p.y,0.003, mid.x,mid.y,0.003, mid.x,mid.y,0.003, best.x,best.y,0.003);
    }
  }
  const geom = new THREE.BufferGeometry();
  geom.setAttribute('position', new THREE.Float32BufferAttribute(segs,3));
  const mat = new THREE.LineBasicMaterial({ color:'#45baff', transparent:true, opacity:0.35, depthWrite:false, blending: THREE.AdditiveBlending});
  const lines = new THREE.LineSegments(geom, mat);
  lines.frustumCulled = false;
  lines.renderOrder = 2;
  return lines;
}

/* Glow sprite helper */
function makeGlowSprite(pos, radius=0.15, intensity=0.5, color='#6bf5a9'){
  const size = 128;
  const c = document.createElement('canvas'); c.width=c.height=size;
  const cx = c.getContext('2d');
  const rgb = hexToRgb(color);
  const grad = cx.createRadialGradient(size/2,size/2,0,size/2,size/2,size/2);
  grad.addColorStop(0, `rgba(${rgb.r},${rgb.g},${rgb.b},${intensity})`);
  grad.addColorStop(0.5, `rgba(${rgb.r},${rgb.g},${rgb.b},${intensity*0.35})`);
  grad.addColorStop(1, `rgba(${rgb.r},${rgb.g},${rgb.b},0)`);
  cx.fillStyle = grad; cx.fillRect(0,0,size,size);
  const tex = new THREE.CanvasTexture(c);
  const mat = new THREE.SpriteMaterial({ map:tex, transparent:true, depthWrite:false, blending: params.glow ? THREE.AdditiveBlending : THREE.NormalBlending });
  const spr = new THREE.Sprite(mat);
  spr.position.set(pos.x,pos.y,0.004);
  spr.scale.set(radius,radius,1);
  return spr;
}
function hexToRgb(hex){ const c = hex.replace('#',''); const n=parseInt(c,16); return {r:(n>>16)&255,g:(n>>8)&255,b:n&255}; }

/* =========================
   UI wiring & helpers
   ========================= */
$('#toggleCore').addEventListener('change', applyVisibility);
$('#toggleGates').addEventListener('change', applyVisibility);
$('#toggleTenketsu').addEventListener('change', applyVisibility);
$('#toggleChannels').addEventListener('change', applyVisibility);
$('#toggleGlow').addEventListener('change', ()=>{
  params.glow = $('#toggleGlow').checked;
  buildAll();
});
$('#count').addEventListener('input', e=>{
  params.tenketsuCount = parseInt(e.target.value,10);
  if (meshTenketsu) meshTenketsu.geometry.setDrawRange(0, params.tenketsuCount);
});
$('#density').addEventListener('input', e=>{
  params.channelDensity = parseFloat(e.target.value);
  if (meshChannels) { overlay.remove(meshChannels); const rng = LCG(params.seed+999); meshChannels = drawChannels(ptsTenketsu, params.channelDensity, rng); overlay.add(meshChannels); }
  applyVisibility();
});
$('#ptsize').addEventListener('input', e=>{
  params.pointSize = parseInt(e.target.value,10);
  if (meshTenketsu) meshTenketsu.material.size = params.pointSize;
});
$('#seed').addEventListener('change', e=>{ const v=parseInt(e.target.value,10); params.seed = isFinite(v)?v:1337; });
$('#btnReroll').addEventListener('click', ()=>{
  params.seed = (Math.random()*1e9)|0; $('#seed').value = params.seed;
  rebuildTenketsuAndChannels();
  overlay.remove(meshTenketsu); overlay.remove(meshChannels);
  overlay.add(meshTenketsu, meshChannels);
  applyVisibility();
});
$('#btnExport').addEventListener('click', ()=>{
  render();
  const a = document.createElement('a'); a.href = renderer.domElement.toDataURL('image/png'); a.download = 'chakra_network.png'; a.click();
});

function applyVisibility(){
  const vCore = (document.getElementById('toggleCore')?.checked) ?? true;
  const vGates = (document.getElementById('toggleGates')?.checked) ?? true;
  const vTenk = (document.getElementById('toggleTenketsu')?.checked) ?? true;
  const vCh = (document.getElementById('toggleChannels')?.checked) ?? true;
  if (meshCore) meshCore.visible = vCore;
  if (meshGates) meshGates.visible = vGates;
  if (meshTenketsu) meshTenketsu.visible = vTenk;
  if (meshChannels) meshChannels.visible = vCh;
}

/* =========================
   Resize & render loop
   ========================= */
window.addEventListener('resize', onResize);
function onResize(){
  renderer.setSize(window.innerWidth, window.innerHeight);
  const aspect = window.innerWidth / window.innerHeight;
  const baseH = 3.15;
  camera.top = baseH/2; camera.bottom = -baseH/2;
  camera.left = -baseH*aspect/2; camera.right = baseH*aspect/2;
  camera.updateProjectionMatrix();
}
onResize();

renderer.setAnimationLoop(render);
function render(){
  renderer.autoClear = false;
  renderer.clear();
  renderer.render(bgScene, bgCamera);
  renderer.render(scene, camera);
  renderer.autoClear = true;
}

/* =========================
   Initialization sequence:
   1) Build mask from outline.png
   2) Paint silhouette texture from mask
   3) Add silhouette plane and build scene objects
   ========================= */
(async function init(){
  try{
    await initMaskFromOutline('outline.png');
    paintSilhouetteTexture();

    const silhouette = new THREE.Mesh(new THREE.PlaneGeometry(bodyWidth, bodyHeight),
                                      new THREE.MeshBasicMaterial({ map: silhouetteTex, transparent:true }));
    silhouette.position.set(0, 0.2, -0.01);
    scene.add(silhouette);

    buildAll();
  } catch(e){
    console.error('Failed to initialize silhouette mask:', e);
    // fallback: simple placeholder to avoid crashing
    ctx.clearRect(0,0,silCanvas.width,silCanvas.height);
    ctx.fillStyle = '#000'; ctx.fillRect(360,200,300,1500);
    silhouetteTex.needsUpdate = true;
    const silhouette = new THREE.Mesh(new THREE.PlaneGeometry(bodyWidth, bodyHeight),
                                      new THREE.MeshBasicMaterial({ map: silhouetteTex, transparent:true }));
    silhouette.position.set(0, 0.2, -0.01);
    scene.add(silhouette);
    mask = new Uint8Array(maskW*maskH);
    insidePixels = [];
    buildAll();
  }
})();

</script>
</body>
</html>
