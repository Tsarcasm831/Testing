<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Naruto’s Room — Three.js (Fixed)</title>
<style>
  html,body{height:100%;margin:0;overflow:hidden;background:#e7dfd2}
  canvas{display:block}
  #hud{
    position:fixed;left:12px;bottom:12px;
    background:rgba(0,0,0,.55);color:#fafafa;border:1px solid #000;
    padding:10px 12px;border-radius:10px;font:12px/1.35 system-ui,Segoe UI,Roboto;
    user-select:none; z-index:10; max-width:380px
  }
  #crosshair{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);opacity:.65;pointer-events:none}
  #crosshair:before,#crosshair:after{content:"";position:absolute;background:#111;border:1px solid #fff;border-radius:2px}
  #crosshair:before{width:14px;height:2px;left:-7px;top:-1px}
  #crosshair:after{width:2px;height:14px;left:-1px;top:-7px}
  .btn{display:inline-block;margin-top:8px;padding:6px 10px;border-radius:8px;background:#ffd24d;color:#111;font-weight:700;cursor:pointer}
</style>
</head>
<body>
<div id="hud">
  <b>Naruto’s Room</b><br/>
  Click to lock. <b>WASD</b> move, <b>Mouse</b> look, <b>Space</b> jump, <b>Shift</b> sprint.<br/>
  <span class="btn" id="lockBtn">Click to Start</span>
</div>
<div id="crosshair"></div>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
  }
}
</script>
<script type="module">
import * as THREE from 'three';
import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

let scene, camera, renderer, controls;
let clock = new THREE.Clock();
let blockers = [];
let velocityY = 0;
let canJump = false;
const params = { speed: 3.0, sprint: 5.0, gravity: 18.0, jumpVel: 7.0 };

// ---------- Scene / Camera ----------
scene = new THREE.Scene();
scene.background = new THREE.Color(0xe7dfd2);
camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 200);
// start INSIDE the room
camera.position.set(0.5, 1.6, 0.8);

renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
document.body.appendChild(renderer.domElement);

// Lights
const hemi = new THREE.HemisphereLight(0xffffff, 0x554433, 0.75);
scene.add(hemi);
const sun = new THREE.DirectionalLight(0xffffff, 0.9);
sun.position.set(4, 6, 2);
sun.castShadow = true;
sun.shadow.mapSize.set(2048,2048);
scene.add(sun);

// Controls
controls = new PointerLockControls(camera, renderer.domElement);
document.getElementById('lockBtn').addEventListener('click', ()=> controls.lock());
controls.addEventListener('lock', ()=> document.getElementById('hud').style.display='none');
controls.addEventListener('unlock', ()=> document.getElementById('hud').style.display='block');

// ---------- Materials ----------
const texLoader = new THREE.TextureLoader();
function makeWood() {
  const wood = texLoader.load('https://images.unsplash.com/photo-1495435229349-e86db7bfa013?w=1200');
  wood.wrapS = wood.wrapT = THREE.RepeatWrapping;
  wood.repeat.set(6,4); // doubled room -> more tiles
  return new THREE.MeshStandardMaterial({ map: wood, roughness:0.8, metalness:0.0 });
}
const paintGreen = new THREE.MeshStandardMaterial({ color:0xbdd39f, roughness:0.95 });
const wainscotBandMat = wainscot.clone();
wainscotBandMat.polygonOffset = true;
wainscotBandMat.polygonOffsetFactor = -1;
wainscotBandMat.polygonOffsetUnits = 1;
const trim = new THREE.MeshStandardMaterial({ color:0x5c3a21, roughness:0.8 });
const whiteMat = new THREE.MeshStandardMaterial({ color:0xffffff, roughness:0.95 });
const blueMat  = new THREE.MeshStandardMaterial({ color:0x5aa7d6, roughness:0.9 });
const yellowMat= new THREE.MeshStandardMaterial({ color:0xffd24d, roughness:0.85 });
const darkMat  = new THREE.MeshStandardMaterial({ color:0x222222, roughness:0.6 });
const glassMat = new THREE.MeshPhysicalMaterial({ color:0xffffff, metalness:0, roughness:0, transmission:0.9, thickness:0.02 });

// ---------- Room (size doubled) ----------
const roomW = 10.0, roomD = 7.2, roomH = 2.6;

// Floor
const floor = new THREE.Mesh(new THREE.PlaneGeometry(roomW, roomD), makeWood());
floor.rotation.x = -Math.PI/2;
floor.receiveShadow = true;
scene.add(floor);

// Walls
const groupWalls = new THREE.Group();
const wallGeom = new THREE.PlaneGeometry(roomW, roomH);
const wallGeomD = new THREE.PlaneGeometry(roomD, roomH);

const long1 = new THREE.Mesh(wallGeom, paintGreen);
long1.position.set(0, roomH/2, -roomD/2);

const long2 = new THREE.Mesh(wallGeom, paintGreen);
long2.position.set(0, roomH/2, roomD/2);
long2.rotation.y = Math.PI;

const short1 = new THREE.Mesh(wallGeomD, paintGreen);
short1.position.set(-roomW/2, roomH/2, 0);
short1.rotation.y = Math.PI/2;

const short2 = new THREE.Mesh(wallGeomD, paintGreen);
short2.position.set(roomW/2, roomH/2, 0);
short2.rotation.y = -Math.PI/2;

for (const w of [long1,long2,short1,short2]) { w.receiveShadow = true; groupWalls.add(w); }

// Wainscot band
function addWainscot(mesh, width){
  const h = 0.9;
  const g = new THREE.PlaneGeometry(width, h);
  const band = new THREE.Mesh(g, wainscotBandMat);
  band.position.copy(mesh.position);
  band.position.y = h/2;
  band.rotation.copy(mesh.rotation);
  groupWalls.add(band);
}
addWainscot(long1, roomW);
addWainscot(long2, roomW);
addWainscot(short1, roomD);
addWainscot(short2, roomD);
scene.add(groupWalls);

// Door (red) — left wall
const door = new THREE.Mesh(new THREE.BoxGeometry(0.04, 2.1, 0.9), new THREE.MeshStandardMaterial({ color:0xb3352e, roughness:0.8 }));
door.position.set(-roomW/2+0.02, 1.05, -0.5);
door.castShadow = true; scene.add(door);

// Round blue rug
const rug = new THREE.Mesh(new THREE.CircleGeometry(0.8, 48), blueMat);
rug.rotation.x = -Math.PI/2;
rug.position.set(-roomW*0.25, 0.01, -roomD*0.18);
rug.receiveShadow = true;
scene.add(rug);

// Bed (right wall)
const bedGroup = new THREE.Group();
const bedFrame = new THREE.Mesh(new THREE.BoxGeometry(2.0, 0.35, 0.9), wainscot);
bedFrame.position.set(0, 0.18, 0);
bedFrame.castShadow = bedFrame.receiveShadow = true;
const mattress = new THREE.Mesh(new THREE.BoxGeometry(1.9, 0.22, 0.8), whiteMat);
mattress.position.set(0, 0.47, 0);
mattress.castShadow = mattress.receiveShadow = true;
const blanket = new THREE.Mesh(new THREE.BoxGeometry(1.9, 0.06, 0.55), yellowMat);
blanket.position.set(0, 0.60, 0.125);
const pillow = new THREE.Mesh(new THREE.BoxGeometry(0.55, 0.12, 0.35), whiteMat);
pillow.position.set(-0.6, 0.58, -0.15);
bedGroup.add(bedFrame, mattress, blanket, pillow);
bedGroup.position.set(roomW/2-1.2, 0, roomD*0.25);
scene.add(bedGroup);

// Backpack
const pack = new THREE.Mesh(new THREE.BoxGeometry(0.36,0.14,0.28), darkMat);
pack.rotation.y = 0.4;
pack.position.set(bedGroup.position.x+0.2, 0.68, bedGroup.position.z+0.05);
pack.castShadow = true; scene.add(pack);

// Cabinet
const cab = new THREE.Group();
const cabBody = new THREE.Mesh(new THREE.BoxGeometry(0.7,0.9,0.35), wainscot);
cabBody.castShadow = cabBody.receiveShadow = true;
const cabTop = new THREE.Mesh(new THREE.BoxGeometry(0.74,0.05,0.39), trim);
cabTop.position.y = 0.47;
const glassL = new THREE.Mesh(new THREE.BoxGeometry(0.30,0.5,0.01), glassMat);
glassL.position.set(-0.18,0.20,0.18);
const glassR = glassL.clone(); glassR.position.x = 0.18;
cab.add(cabBody,cabTop,glassL,glassR);
cab.position.set(roomW/2-0.9, 0.45, 0.1);
scene.add(cab);

// Desk (left/front corner)
const desk = new THREE.Group();
const top = new THREE.Mesh(new THREE.BoxGeometry(1.1,0.06,0.5), trim);
top.position.y = 0.76;
const base = new THREE.Mesh(new THREE.BoxGeometry(1.1,0.72,0.5), wainscot);
base.position.y = 0.36;
const shelves = new THREE.Mesh(new THREE.BoxGeometry(1.08,0.04,0.48), trim);
shelves.position.set(0,0.22,0);
desk.add(base, shelves, top);
desk.position.set(-roomW/2+1.0, 0, -roomD/2+0.6);
scene.add(desk);

// Banner + emblem (right wall)
const banner = new THREE.Mesh(new THREE.PlaneGeometry(1.0,0.7), yellowMat);
banner.position.set(roomW/2-0.05, 1.8, -0.2);
banner.rotation.y = -Math.PI/2;
scene.add(banner);
const leafShape = new THREE.Shape();
leafShape.absarc(0,0,0.18,0,Math.PI*2,false);
const swirl = new THREE.Path();
swirl.absarc(0.05,0.02,0.30,Math.PI*0.9,Math.PI*1.8,false);
leafShape.holes.push(swirl);
const leafGeo = new THREE.ShapeGeometry(leafShape);
const emblem = new THREE.Mesh(leafGeo, new THREE.MeshBasicMaterial({ color:0x222222 }));
emblem.position.set(banner.position.x-0.01, 1.78, -0.2);
emblem.rotation.y = -Math.PI/2;
scene.add(emblem);

// Window (right/front)
const windowFrame = new THREE.Mesh(new THREE.BoxGeometry(0.02,1.0,1.2), trim);
windowFrame.position.set(roomW/2-0.01, 1.5, -roomD*0.35);
scene.add(windowFrame);
const windowPane = new THREE.Mesh(new THREE.PlaneGeometry(1.0,0.9), glassMat);
windowPane.position.set(roomW/2-0.02, 1.50, -roomD*0.35);
windowPane.rotation.y = -Math.PI/2;
scene.add(windowPane);

// Lamp pole near rug
const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.03,0.03,2.2,16), darkMat);
pole.position.set(-roomW*0.26, 1.1, -roomD*0.19);
const lampHead = new THREE.Mesh(new THREE.CylinderGeometry(0.18,0.28,0.18,24,1,true), darkMat);
lampHead.position.set(-roomW*0.26, 2.1, -roomD*0.19);
lampHead.rotation.z = Math.PI;
scene.add(pole,lampHead);

// ---------- Colliders ----------
function addBlockerFromMesh(m, pad=0){
  m.updateWorldMatrix(true,true);
  const box = new THREE.Box3().setFromObject(m).expandByScalar(pad);
  blockers.push(box);
}
for (const w of [long1,long2,short1,short2]) addBlockerFromMesh(w, -0.02);
[door,rug,bedGroup,cab,desk,windowFrame,windowPane,pole,lampHead,pack].forEach(m=>addBlockerFromMesh(m,0.02));

// ---------- Input ----------
const keys = { w:false, a:false, s:false, d:false, shift:false };
const map = { 'KeyW':'w', 'KeyA':'a', 'KeyS':'s', 'KeyD':'d', 'ShiftLeft':'shift', 'ShiftRight':'shift' };
document.addEventListener('keydown', (e)=>{ if(map[e.code]) keys[map[e.code]]=true;
  if(e.code==='Space' && canJump){ velocityY = params.jumpVel; canJump=false; }});
document.addEventListener('keyup',   (e)=>{ if(map[e.code]) keys[map[e.code]]=false; });

// ---------- Movement helpers ----------
function tryMove(step){
  const pos = controls.getObject().position.clone().add(step);
  const halfW=0.25, height=1.7;
  const playerBox = new THREE.Box3(
    new THREE.Vector3(pos.x - halfW, pos.y - height*0.5, pos.z - halfW),
    new THREE.Vector3(pos.x + halfW, pos.y + 0.2,        pos.z + halfW)
  );
  for(const b of blockers){ if(playerBox.intersectsBox(b)) return false; }
  controls.getObject().position.copy(pos);
  return true;
}
function onGround(){ return controls.getObject().position.y <= 1.6; }

// ---------- Animate ----------
function animate(){
  requestAnimationFrame(animate);
  const dt = Math.min(0.05, clock.getDelta());

  // Horizontal move (FIXED directions)
  if (controls.isLocked){
    const speed = (keys.shift ? params.sprint : params.speed) * dt;
    const forward = new THREE.Vector3();
    controls.getDirection(forward); forward.y = 0; forward.normalize();
    const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).normalize();

    const desired = new THREE.Vector3();
    if(keys.w) desired.add(forward);
    if(keys.s) desired.sub(forward);
    if(keys.a) desired.sub(right);
    if(keys.d) desired.add(right);
    if(desired.lengthSq()>0){
      desired.normalize().multiplyScalar(speed);
      // slide if blocked
      if(!tryMove(desired)){
        const tryX = new THREE.Vector3(desired.x,0,0);
        const tryZ = new THREE.Vector3(0,0,desired.z);
        if(!tryMove(tryX)) tryMove(tryZ);
      }
    }
  }

  // Vertical
  velocityY -= params.gravity * dt;
  const obj = controls.getObject();
  obj.position.y += velocityY * dt;
  if (onGround()){
    velocityY = 0; obj.position.y = 1.6; canJump = true;
  }

  renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
