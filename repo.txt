

├── AGENTS.md
├── CHANGELOG.md
├── CHANGELOG_ARCHIVE.md
├── README.md
├── agents
    ├── changelog.md
    ├── general.md
    └── testing.md
├── assets.json
├── gear_icon.png
├── ground_texture.png
├── hammer_icon.png
├── index.html
├── js
    ├── advancedBuildTool.js
    ├── aiBuilder.js
    ├── animationSetup.js
    ├── app.js
    ├── assetReplacementManager.js
    ├── buildTool.js
    ├── characterCreator.js
    ├── characters
    │   ├── animations.js
    │   ├── presets.js
    │   └── textures.js
    ├── collisionManager.js
    ├── controls
    │   ├── InputManager.js
    │   └── constants.js
    ├── downloader.js
    ├── interaction.js
    ├── inventoryManager.js
    ├── lifespanExtender.js
    ├── multiplayerManager.js
    ├── npc
    │   ├── NPC.js
    │   ├── NPCSpawner.js
    │   ├── ZoneManager.js
    │   └── constants.js
    ├── npcManager.js
    ├── objectCreator.js
    ├── player.js
    ├── playerControls.js
    ├── playerModel.js
    ├── previewManager.js
    ├── uiManager.js
    ├── world.js
    ├── worldGeneration.js
    └── worldgen
    │   ├── amphitheatre.js
    │   ├── barriers.js
    │   ├── clouds.js
    │   ├── constants.js
    │   ├── groundGrid.js
    │   ├── random.js
    │   ├── shopkeeper.js
    │   ├── starterHouse.js
    │   ├── terrain.js
    │   └── trees.js
├── loading.css
├── map_icon.png
├── package.json
├── python
    ├── glbanalyzer.py
    └── skeleton_rigger.py
├── styles
    ├── ads.css
    ├── base.css
    ├── build.css
    ├── changelog.css
    ├── character-creator.css
    ├── chat.css
    ├── compass.css
    ├── interaction.css
    ├── inventory.css
    ├── map.css
    ├── mobile.css
    ├── options.css
    ├── overlays.css
    ├── responsive.css
    └── theme.css
└── ui
    ├── adModal.js
    ├── advancedBuildUI.js
    ├── buildUI.js
    ├── changelogUI.js
    ├── characterCreatorUI.js
    ├── chatUI.js
    ├── compassUI.js
    ├── inventoryUI.js
    ├── mapUI.js
    └── optionsUI.js


/AGENTS.md:
--------------------------------------------------------------------------------
 1 | # Repository Contribution Guidelines
 2 | 
 3 | Detailed instructions are stored in the `agents/` directory. Read the files there before making changes.
 4 | 
 5 | - Update `CHANGELOG.md` with a short description for every change.
 6 | - After every 10 changelog entries, move older entries to `CHANGELOG_ARCHIVE.md` to keep `CHANGELOG.md` concise.
 7 | - Use the current UTC date for new changelog entries. Run `date -u +%Y-%m-%d` for the date heading and prefix each bullet beneath it with an `HHMM` timestamp from `date -u +%H%M`.
 8 | - Run any available tests before committing, even if none exist yet.
 9 | 
10 | 


--------------------------------------------------------------------------------
/CHANGELOG.md:
--------------------------------------------------------------------------------
 1 | # Changelog
 2 | 
 3 | ## 2025-07-16
 4 | - 1906 Improve compass angle tracking with wrap-around detection
 5 | - 1934 Fix amphitheatre seat collision and update seating rows
 6 | 
 7 | ## 2025-07-15
 8 | - 1205 Fix compass not displaying directions and add tweakable offset
 9 | - 1200 Fix shopkeeper not spawning and improve interaction system performance
10 | 
11 | ## 2025-07-14
12 | - 1522 Fix HouseBlocks module loading error by merging it into starterHouse.js
13 | - 1507 Break up worldGeneration.js into modular files
14 | - 1555 Restrict grid labels to show within 7m radius when grid toggled
15 | - 1623 Label every grid cell and keep labels visible only when the grid is toggled
16 | - 1640 Enable dual joysticks for mobile look and movement
17 | - 1706 Generate grid labels on demand to eliminate DOM lag
18 | 
19 | ## Guidelines for future updates
20 | - List changes in reverse chronological order (newest first).
21 | - Use a heading for each version or date, followed by brief bullet points.
22 | - Summaries should be short, highlighting major additions or fixes.
23 | 
24 | 


--------------------------------------------------------------------------------
/CHANGELOG_ARCHIVE.md:
--------------------------------------------------------------------------------
 1 | # Changelog Archive
 2 | 
 3 | ## 2025-07-14
 4 | - 1747 Ensure joystick containers display on mobile initialization
 5 | - 1758 Correct A/D key mapping and improve mobile joystick handling
 6 |  
 7 | ## 2025-06-26
 8 | - **7d0177a** Merge: extend MapUI to handle scene objects
 9 | - **d335b69** Use texture sampling for map terrain
10 | - **858612b** Merge: load texture and update terrain rendering
11 | - **c210851** Add static object markers to MapUI
12 | - **08f04d4** Starting Point
13 | - **cfb2ea7** Initial commit
14 | - Add AGENTS.md with changelog and testing guidelines
15 | - 2314 Add theme stylesheet and replace color constants
16 | 
17 | - 2118 Make AI builder asynchronous with progress indicator
18 | - Document using the current UTC date when updating the changelog
19 | - 1918 Revise character generator prompt for humanoid proportions and 3×3×3 size limit
20 | - 1918 Prevent objects from spawning on top of players
21 | - 1928 Add pyramid shape to builder tool
22 | 
23 | - 1958 Reserve spawn area so players don't load inside objects
24 | - 1928 Add rotate and undo buttons to basic build mode
25 | - 2018 Add map UI button and close control
26 | - 2057 Rework character creator modal layout for clearer flow
27 | - 2110 Fix build tool using undefined material index in object creator
28 | - 2147 Add HouseBlocks mesh kit
29 | 
30 | 
31 | - 2221 Document new agents directory and split instructions
32 | - 2218 Fade chat bubbles before hiding
33 | - 2214 Show sent chat immediately and keep log of messages
34 | - 2309 Update remote players to run custom animations each frame
35 | - 2257 Add animated player replace button and improved options styling
36 | - 2242 Add options menu with asset downloader and glb analysis scripts
37 | 
38 | ## 2025-06-27
39 | - 1623 Fix stylesheet path in index.html
40 | - 1742 Fix idle animation orientation for animated player model
41 | - 1815 Hide mobile/desktop toggle and rely on auto-detection
42 | 
43 | ## 2025-06-28
44 | - 0100 Rig up running animation on Shift key press for animated player model.
45 | 
46 | - 1818 Fix player asset replacement to avoid duplicate player model
47 | 
48 | 
49 | 


--------------------------------------------------------------------------------
/README.md:
--------------------------------------------------------------------------------
 1 | # MP
 2 | 
 3 | This is a minimalist 3D multiplayer prototype. The project includes a
 4 | character creator powered by AI.
 5 | 
 6 | ## Character creator
 7 | 
 8 | Characters are generated from text prompts. When a humanoid shape is
 9 | described, the AI assembles separate primitives for the head, torso and
10 | limbs to maintain humanoid proportions. All features must fit within a
11 | 3×3×3 unit volume and textures or colors should match the prompt for
12 | realism.
13 | 


--------------------------------------------------------------------------------
/agents/changelog.md:
--------------------------------------------------------------------------------
 1 | Changelog Updates
 2 | =================
 3 | 
 4 | - Record each change briefly in `CHANGELOG.md`.
 5 | - Keep only the most recent 10 entries in `CHANGELOG.md`.
 6 | - Move older entries to `CHANGELOG_ARCHIVE.md`.
 7 | - Use UTC for dates and times. Example commands:
 8 |   - `date -u +%Y-%m-%d` for the date heading.
 9 |   - `date -u +%H%M` for the bullet prefix.
10 | 


--------------------------------------------------------------------------------
/agents/general.md:
--------------------------------------------------------------------------------
1 | General Contribution Guidelines
2 | ===============================
3 | 
4 | - Follow the coding style already present in the repository.
5 | - Keep pull requests focused on a single topic.
6 | - Provide clear commit messages summarizing the change.
7 | 


--------------------------------------------------------------------------------
/agents/testing.md:
--------------------------------------------------------------------------------
1 | Testing Before Commit
2 | =====================
3 | 
4 | - Run `npm test` or any project-specific test command.
5 | - If tests are missing or fail due to environment limits, document the issue in the pull request.
6 | 


--------------------------------------------------------------------------------
/assets.json:
--------------------------------------------------------------------------------
  1 | {
  2 |   "schema": {
  3 |     "type": "string - category of asset such as image, model, audio or script",
  4 |     "name": "string - human friendly asset name",
  5 |     "url": "string - relative path or remote URL to download the asset"
  6 |   },
  7 |   "assets": [
  8 |     {
  9 |       "type": "image",
 10 |       "name": "Ground texture",
 11 |       "url": "ground_texture.png"
 12 |     },
 13 |     {
 14 |       "type": "script",
 15 |       "name": "App logic",
 16 |       "url": "js/app.js"
 17 |     },
 18 |     {
 19 |       "type": "script",
 20 |       "name": "Input controls",
 21 |       "url": "js/controls.js"
 22 |     }
 23 |     ,
 24 |     {
 25 |       "type": "model",
 26 |       "name": "Player idle animation",
 27 |       "url": "https://file.garden/Zy7B0LkdIVpGyzA1/Z1/player/Animation_Idle_withSkin.glb"
 28 |     },
 29 |     {
 30 |       "type": "model",
 31 |       "name": "Player walking animation",
 32 |       "url": "https://file.garden/Zy7B0LkdIVpGyzA1/Z1/player/Animation_Walking_withSkin.glb"
 33 |     },
 34 |     {
 35 |       "type": "model",
 36 |       "name": "Player running animation",
 37 |       "url": "https://file.garden/Zy7B0LkdIVpGyzA1/Z1/player/Animation_Running_withSkin.glb"
 38 |     },
 39 |     {
 40 |       "type": "model",
 41 |       "name": "Robot walking animation",
 42 |       "url": "https://file.garden/Zy7B0LkdIVpGyzA1/Public/Robot/Animation_Walking_withSkin.glb"
 43 |     },
 44 |     {
 45 |       "type": "model",
 46 |       "name": "Robot listening animation",
 47 |       "url": "https://file.garden/Zy7B0LkdIVpGyzA1/Public/Robot/Animation_Listening_Gesture_withSkin.glb"
 48 |     },
 49 |     {
 50 |       "type": "model",
 51 |       "name": "Robot idle 2 animation",
 52 |       "url": "https://file.garden/Zy7B0LkdIVpGyzA1/Public/Robot/Animation_Idle_02_withSkin.glb"
 53 |     },
 54 |     {
 55 |       "type": "model",
 56 |       "name": "Eyebot model",
 57 |       "url": "https://file.garden/Zy7B0LkdIVpGyzA1/Public/Eyebot/Orbital_Eye_Bot_0713172403_texture.glb"
 58 |     },
 59 |     {
 60 |       "type": "model",
 61 |       "name": "Chicken Alert Animation",
 62 |       "url": "https://file.garden/Zy7B0LkdIVpGyzA1/Public/Chicken/Animation_Alert_withSkin.glb"
 63 |     },
 64 |     {
 65 |       "type": "model",
 66 |       "name": "Chicken Idle Animation",
 67 |       "url": "https://file.garden/Zy7B0LkdIVpGyzA1/Public/Chicken/Animation_Idle_02_withSkin.glb"
 68 |     },
 69 |     {
 70 |       "type": "model",
 71 |       "name": "Chicken Listening Animation",
 72 |       "url": "https://file.garden/Zy7B0LkdIVpGyzA1/Public/Chicken/Animation_Listening_Gesture_withSkin.glb"
 73 |     },
 74 |     {
 75 |       "type": "model",
 76 |       "name": "Chicken Walking Animation",
 77 |       "url": "https://file.garden/Zy7B0LkdIVpGyzA1/Public/Chicken/Animation_Walking_withSkin.glb"
 78 |     },
 79 |     {
 80 |       "type": "model",
 81 |       "name": "Chicken Running Animation",
 82 |       "url": "https://file.garden/Zy7B0LkdIVpGyzA1/Public/Chicken/Animation_Running_withSkin.glb"
 83 |     },
 84 |     {
 85 |       "type": "model",
 86 |       "name": "Wireframe Listening Animation",
 87 |       "url": "https://file.garden/Zy7B0LkdIVpGyzA1/Public/Wireframe/Animation_Listening_Gesture_withSkin.glb"
 88 |     },
 89 |     {
 90 |       "type": "model",
 91 |       "name": "Wireframe Idle Animation",
 92 |       "url": "https://file.garden/Zy7B0LkdIVpGyzA1/Public/Wireframe/Animation_Idle_4_withSkin.glb"
 93 |     },
 94 |     {
 95 |       "type": "model",
 96 |       "name": "Wireframe Walking Animation",
 97 |       "url": "https://file.garden/Zy7B0LkdIVpGyzA1/Public/Wireframe/Animation_Walking_withSkin.glb"
 98 |     },
 99 |     {
100 |       "type": "model",
101 |       "name": "Wireframe Running Animation",
102 |       "url": "https://file.garden/Zy7B0LkdIVpGyzA1/Public/Wireframe/Animation_Running_withSkin.glb"
103 |     },
104 |     {
105 |       "type": "model",
106 |       "name": "Alien Listening Animation",
107 |       "url": "https://file.garden/Zy7B0LkdIVpGyzA1/Public/Alien/Animation_Listening_Gesture_withSkin.glb"
108 |     },
109 |     {
110 |       "type": "model",
111 |       "name": "Alien Walking Animation",
112 |       "url": "https://file.garden/Zy7B0LkdIVpGyzA1/Public/Alien/Animation_Walking_withSkin.glb"
113 |     },
114 |     {
115 |       "type": "model",
116 |       "name": "Alien Running Animation",
117 |       "url": "https://file.garden/Zy7B0LkdIVpGyzA1/Public/Alien/Animation_Running_withSkin.glb"
118 |     },
119 |     {
120 |       "type": "model",
121 |       "name": "Alien Idle Animation",
122 |       "url": "https://file.garden/Zy7B0LkdIVpGyzA1/Public/Alien/Animation_Idle_02_withSkin.glb"
123 |     }
124 |   ]
125 | }


--------------------------------------------------------------------------------
/gear_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Testing/9013d8c6561ab48e051ddb026d6286fe57b22282/gear_icon.png


--------------------------------------------------------------------------------
/ground_texture.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Testing/9013d8c6561ab48e051ddb026d6286fe57b22282/ground_texture.png


--------------------------------------------------------------------------------
/hammer_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Testing/9013d8c6561ab48e051ddb026d6286fe57b22282/hammer_icon.png


--------------------------------------------------------------------------------
/index.html:
--------------------------------------------------------------------------------
 1 | <html lang="en">
 2 | <head>
 3 |   <meta charset="UTF-8">
 4 |   <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
 5 |   <title>3D Overworld Template v1.9.6.1</title>
 6 |   <script>
 7 |     // Suppress specific cookie-related console errors and warnings
 8 |     /* @tweakable List of phrases to filter from console error/warning messages. */
 9 |     const consoleFilter = ['Cookie', 'rejected for invalid domain'];
10 | 
11 |     const originalError = console.error;
12 |     console.error = (...args) => {
13 |       if (typeof args[0] === 'string' && consoleFilter.every(phrase => args[0].includes(phrase))) {
14 |         return;
15 |       }
16 |       originalError.apply(console, args);
17 |     };
18 | 
19 |     const originalWarn = console.warn;
20 |     console.warn = (...args) => {
21 |       if (typeof args[0] === 'string' && consoleFilter.every(phrase => args[0].includes(phrase))) {
22 |         return;
23 |       }
24 |       originalWarn.apply(console, args);
25 |     };
26 |   </script>
27 |   <link rel="stylesheet" href="styles/theme.css">
28 |   <link rel="stylesheet" href="styles/base.css">
29 |   <link rel="stylesheet" href="styles/mobile.css">
30 |   <link rel="stylesheet" href="styles/overlays.css">
31 |   <link rel="stylesheet" href="styles/chat.css">
32 |   <link rel="stylesheet" href="styles/character-creator.css">
33 |   <link rel="stylesheet" href="styles/build.css">
34 |   <link rel="stylesheet" href="styles/inventory.css">
35 |   <link rel="stylesheet" href="styles/ads.css">
36 |   <link rel="stylesheet" href="styles/responsive.css">
37 |   <link rel="stylesheet" href="styles/map.css">
38 |   <link rel="stylesheet" href="styles/changelog.css">
39 |   <link rel="stylesheet" href="styles/options.css">
40 |   <link rel="stylesheet" href="styles/interaction.css">
41 |   <link rel="stylesheet" href="styles/compass.css">
42 |   <script type="importmap">
43 |     {
44 |       "imports": {
45 |         "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
46 |         "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
47 |       }
48 |     }
49 |   </script>
50 |   <script src="https://cdn.jsdelivr.net/npm/nipplejs@0.10.1/dist/nipplejs.min.js"></script>
51 | </head>
52 | <body oncontextmenu="return false;">
53 |   <div id="joystick-container"></div>
54 |   <div id="right-side-touch-area"></div>
55 |   <div id="game-container">
56 |     <div class="crosshair"></div>
57 |   </div>
58 |   <div id="label-container"></div>
59 |   <div id="ui-container"></div>
60 |   <script src="js/app.js" type="module"></script>
61 | </body>
62 | </html>


--------------------------------------------------------------------------------
/js/advancedBuildTool.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { TransformControls } from 'three/addons/controls/TransformControls.js';
  3 | 
  4 | export class AdvancedBuildTool {
  5 |   constructor(scene, camera, renderer, buildTool, objectCreator) {
  6 |     this.scene = scene;
  7 |     this.camera = camera;
  8 |     this.renderer = renderer;
  9 |     this.buildTool = buildTool; 
 10 |     this.objectCreator = objectCreator;
 11 |     this.enabled = false;
 12 |     this.room = null;
 13 |     this.selectedObject = null;
 14 |     
 15 |     this.transformControl = new TransformControls(camera, renderer.domElement);
 16 |     this.transformControl.addEventListener('dragging-changed', (event) => {
 17 |       if (this.orbitControls) {
 18 |         this.orbitControls.enabled = !event.value;
 19 |       }
 20 |       if (!event.value) { // Dragging ended
 21 |         this.updateObjectTransform();
 22 |       }
 23 |     });
 24 |     scene.add(this.transformControl);
 25 |     
 26 |     this.transformMode = 'translate'; 
 27 |     this.advancedBuildObjects = [];
 28 |     this.raycaster = new THREE.Raycaster();
 29 |     this.mouse = new THREE.Vector2();
 30 |     this.colorPickerActive = false;
 31 |     
 32 |     this.setupEventListeners();
 33 |   }
 34 |   
 35 |   setupEventListeners() {
 36 |     this.renderer.domElement.addEventListener('pointerdown', this.onPointerDown.bind(this));
 37 |     window.addEventListener('keydown', this.onKeyDown.bind(this));
 38 |   }
 39 |   
 40 |   onKeyDown(event) {
 41 |     if (!this.enabled) return;
 42 |     
 43 |     if (event.key === 'g') {
 44 |       this.setTransformMode('translate');
 45 |     } else if (event.key === 'r') {
 46 |       this.setTransformMode('rotate');
 47 |     } else if (event.key === 's') {
 48 |       this.setTransformMode('scale');
 49 |     } else if (event.key === 'Delete' || event.key === 'Backspace') {
 50 |       this.deleteSelectedObject();
 51 |     } else if (event.key === 'd' && event.ctrlKey) {
 52 |       // Add Ctrl+D shortcut for duplicate
 53 |       event.preventDefault();
 54 |       this.duplicateSelectedObject();
 55 |     }
 56 |   }
 57 |   
 58 |   onPointerDown(event) {
 59 |     if (!this.enabled) return;
 60 |     
 61 |     // Stop event propagation to prevent buildTool from processing the same click
 62 |     event.stopPropagation();
 63 |     
 64 |     this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
 65 |     this.mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
 66 |     
 67 |     this.raycaster.setFromCamera(this.mouse, this.camera);
 68 |     const intersects = this.raycaster.intersectObjects([...this.buildTool.buildObjects, ...this.advancedBuildObjects], false);
 69 |     
 70 |     // Check if color picker is active
 71 |     if (this.colorPickerActive && intersects.length > 0) {
 72 |       this.pickColorFromObject(intersects[0].object);
 73 |       return;
 74 |     }
 75 |     
 76 |     // Don't deselect if the transform controls are being used
 77 |     if (event.target === this.renderer.domElement) {
 78 |       if (intersects.length > 0) {
 79 |         this.selectObject(intersects[0].object);
 80 |       } else if (!this.transformControl.dragging) {
 81 |         this.deselectObject();
 82 |       }
 83 |     }
 84 |   }
 85 |   
 86 |   selectObject(object) {
 87 |     this.deselectObject();
 88 |     this.selectedObject = object;
 89 |     this.transformControl.attach(object);
 90 |     
 91 |     const originalMaterial = object.material;
 92 |     object.userData.originalMaterial = originalMaterial;
 93 |     const highlightMaterial = originalMaterial.clone();
 94 |     highlightMaterial.emissive = new THREE.Color(0x333333);
 95 |     object.material = highlightMaterial;
 96 |     
 97 |     document.getElementById('selection-controls').style.display = 'flex';
 98 |   }
 99 |   
100 |   deselectObject() {
101 |     if (this.selectedObject) {
102 |       if (this.selectedObject.userData.originalMaterial) {
103 |         this.selectedObject.material = this.selectedObject.userData.originalMaterial;
104 |         delete this.selectedObject.userData.originalMaterial;
105 |       }
106 |       
107 |       this.transformControl.detach();
108 |       this.selectedObject = null;
109 |       document.getElementById('selection-controls').style.display = 'none';
110 |     }
111 |   }
112 |   
113 |   setTransformMode(mode) {
114 |     this.transformMode = mode;
115 |     this.transformControl.setMode(mode);
116 |     
117 |     document.querySelectorAll('.transform-button').forEach(button => {
118 |       button.classList.remove('active');
119 |     });
120 |     document.getElementById(`${mode}-button`).classList.add('active');
121 |   }
122 |   
123 |   deleteSelectedObject() {
124 |     if (!this.selectedObject) return;
125 |     
126 |     this.scene.remove(this.selectedObject);
127 |     
128 |     const basicBuildIndex = this.buildTool.buildObjects.indexOf(this.selectedObject);
129 |     if (basicBuildIndex !== -1) {
130 |       this.buildTool.buildObjects.splice(basicBuildIndex, 1);
131 |     }
132 |     
133 |     const advancedBuildIndex = this.advancedBuildObjects.indexOf(this.selectedObject);
134 |     if (advancedBuildIndex !== -1) {
135 |       this.advancedBuildObjects.splice(advancedBuildIndex, 1);
136 |     }
137 |     
138 |     if (this.room && this.room.roomState.buildObjects && this.selectedObject.userData.id) {
139 |       const updatedBuildObjects = { ...(this.room.roomState.buildObjects) };
140 |       delete updatedBuildObjects[this.selectedObject.userData.id];
141 |       this.room.updateRoomState({
142 |         buildObjects: updatedBuildObjects
143 |       });
144 |       this.room.send({
145 |         type: 'delete_build_object',
146 |         objectId: this.selectedObject.userData.id
147 |       });
148 |     }
149 |     
150 |     this.transformControl.detach();
151 |     this.selectedObject = null;
152 |     document.getElementById('selection-controls').style.display = 'none';
153 |   }
154 |   
155 |   duplicateSelectedObject() {
156 |     if (!this.selectedObject) return;
157 |     
158 |     const duplicatedObject = this.objectCreator.duplicateObject(this.selectedObject);
159 |     if(duplicatedObject) {
160 |         this.advancedBuildObjects.push(duplicatedObject);
161 |         this.selectObject(duplicatedObject);
162 |     }
163 |   }
164 |   
165 |   createObjectFromLibrary(objectType) {
166 |     const newObject = this.objectCreator.createObject(objectType);
167 |     if (newObject) {
168 |       this.advancedBuildObjects.push(newObject);
169 |       this.selectObject(newObject);
170 |     }
171 |   }
172 |   
173 |   syncObjectWithRoom(object) {
174 |     this.objectCreator.syncObjectWithRoom(object);
175 |   }
176 |   
177 |   updateObjectTransform() {
178 |     if (!this.selectedObject || !this.room) return;
179 |     
180 |     const transformData = {
181 |       type: 'transform_object',
182 |       objectId: this.selectedObject.userData.id,
183 |       position: {
184 |         x: this.selectedObject.position.x,
185 |         y: this.selectedObject.position.y,
186 |         z: this.selectedObject.position.z
187 |       },
188 |       rotation: {
189 |         x: this.selectedObject.rotation.x,
190 |         y: this.selectedObject.rotation.y,
191 |         z: this.selectedObject.rotation.z
192 |       },
193 |       scale: {
194 |         x: this.selectedObject.scale.x,
195 |         y: this.selectedObject.scale.y,
196 |         z: this.selectedObject.scale.z
197 |       }
198 |     };
199 |     
200 |     this.room.send(transformData);
201 |     
202 |     if (this.room.roomState.buildObjects && this.selectedObject.userData.id) {
203 |       const updatedBuildObjects = { ...(this.room.roomState.buildObjects) };
204 |       if (updatedBuildObjects[this.selectedObject.userData.id]) {
205 |         updatedBuildObjects[this.selectedObject.userData.id] = {
206 |           ...updatedBuildObjects[this.selectedObject.userData.id],
207 |           position: transformData.position,
208 |           rotation: transformData.rotation,
209 |           scale: transformData.scale
210 |         };
211 |         this.room.updateRoomState({
212 |           buildObjects: updatedBuildObjects
213 |         });
214 |       }
215 |     }
216 |   }
217 |   
218 |   receiveObjectTransform(transformData) {
219 |     if (!transformData || !transformData.objectId) return;
220 |     
221 |     const object = [...this.buildTool.buildObjects, ...this.advancedBuildObjects].find(
222 |       obj => obj.userData.id === transformData.objectId
223 |     );
224 |     
225 |     if (object) {
226 |       object.position.set(
227 |         transformData.position.x,
228 |         transformData.position.y,
229 |         transformData.position.z
230 |       );
231 |       
232 |       object.rotation.set(
233 |         transformData.rotation.x,
234 |         transformData.rotation.y,
235 |         transformData.rotation.z
236 |       );
237 |       
238 |       object.scale.set(
239 |         transformData.scale.x,
240 |         transformData.scale.y,
241 |         transformData.scale.z
242 |       );
243 |     }
244 |   }
245 |   
246 |   receiveBuildObject(buildData) {
247 |     if (!buildData) return;
248 |     
249 |     const existingObject = [...this.buildTool.buildObjects, ...this.advancedBuildObjects].find(
250 |       obj => obj.userData.id === buildData.objectId
251 |     );
252 |     
253 |     if (existingObject) return; 
254 |     
255 |     const buildObject = this.objectCreator.createFromData(buildData);
256 |     
257 |     if (!buildObject) return;
258 | 
259 |     this.scene.add(buildObject);
260 |     
261 |     if (buildData.isAdvanced) {
262 |       this.advancedBuildObjects.push(buildObject);
263 |     } else {
264 |       this.buildTool.buildObjects.push(buildObject);
265 |     }
266 |   }
267 |   
268 |   receiveDeleteObject(objectId) {
269 |     if (!objectId) return;
270 |     
271 |     const object = [...this.buildTool.buildObjects, ...this.advancedBuildObjects].find(
272 |       obj => obj.userData.id === objectId
273 |     );
274 |     
275 |     if (object) {
276 |       this.scene.remove(object);
277 |       
278 |       const basicBuildIndex = this.buildTool.buildObjects.indexOf(object);
279 |       if (basicBuildIndex !== -1) {
280 |         this.buildTool.buildObjects.splice(basicBuildIndex, 1);
281 |       }
282 |       
283 |       const advancedBuildIndex = this.advancedBuildObjects.indexOf(object);
284 |       if (advancedBuildIndex !== -1) {
285 |         this.advancedBuildObjects.splice(advancedBuildIndex, 1);
286 |       }
287 |       
288 |       if (this.selectedObject === object) {
289 |         this.deselectObject();
290 |       }
291 |     }
292 |   }
293 |   
294 |   setRoom(room) {
295 |     this.room = room;
296 |   }
297 |   
298 |   setOrbitControls(controls) {
299 |     this.orbitControls = controls;
300 |   }
301 |   
302 |   toggleAdvancedBuildMode() {
303 |     this.enabled = !this.enabled;
304 |     
305 |     if (this.enabled) {
306 |       document.getElementById('advanced-build-controls').style.display = 'flex';
307 |       document.getElementById('object-library').style.display = 'flex';
308 |       
309 |       if (document.getElementById('build-controls')) {
310 |         document.getElementById('build-controls').style.display = 'none';
311 |       }
312 |       
313 |       this.buildTool.previewManager.hide();
314 |       
315 |       // Remove existing listener first to avoid duplicates
316 |       this.transformControl.removeEventListener('objectChange', this.onTransformChanged.bind(this));
317 |       this.transformControl.addEventListener('objectChange', this.onTransformChanged.bind(this));
318 |       
319 |       // Make buildTool disabled in advanced mode
320 |       this.buildTool.enabled = false;
321 |     } else {
322 |       document.getElementById('advanced-build-controls').style.display = 'none';
323 |       document.getElementById('object-library').style.display = 'none';
324 |       document.getElementById('selection-controls').style.display = 'none';
325 |       document.getElementById('color-picker').style.display = 'none';
326 |       
327 |       // Remove color picker message if exists
328 |       const message = document.getElementById('color-picker-message');
329 |       if (message) message.remove();
330 |       
331 |       this.colorPickerActive = false;
332 |       this.deselectObject();
333 |       
334 |       this.transformControl.removeEventListener('objectChange', this.onTransformChanged.bind(this));
335 |     }
336 |     
337 |     return this.enabled;
338 |   }
339 |   
340 |   onTransformChanged() {
341 |     this.updateObjectTransform();
342 |   }
343 |   
344 |   checkExpiredObjects(currentTime, expirationTime) {
345 |     const objectsToRemove = [];
346 |     
347 |     for (let i = 0; i < this.advancedBuildObjects.length; i++) {
348 |       const object = this.advancedBuildObjects[i];
349 |       if (object.userData.createdAt && !object.userData.extendedUntil && 
350 |           (currentTime - object.userData.createdAt > expirationTime)) {
351 |         objectsToRemove.push(object);
352 |       } else if (object.userData.extendedUntil && currentTime > object.userData.extendedUntil) {
353 |         // For objects with extended lifespan, check if extension has expired
354 |         objectsToRemove.push(object);
355 |       }
356 |     }
357 |     
358 |     for (const object of objectsToRemove) {
359 |       this.scene.remove(object);
360 |       
361 |       const index = this.advancedBuildObjects.indexOf(object);
362 |       if (index !== -1) {
363 |         this.advancedBuildObjects.splice(index, 1);
364 |       }
365 |       
366 |       if (this.room && this.room.roomState.buildObjects && object.userData.id) {
367 |         const updatedBuildObjects = { ...(this.room.roomState.buildObjects) };
368 |         delete updatedBuildObjects[object.userData.id];
369 |         this.room.updateRoomState({
370 |           buildObjects: updatedBuildObjects
371 |         });
372 |       }
373 |       
374 |       if (this.selectedObject === object) {
375 |         this.deselectObject();
376 |       }
377 |     }
378 |     
379 |     if (objectsToRemove.length > 0) {
380 |       console.log(`Removed ${objectsToRemove.length} expired advanced build objects`);
381 |     }
382 |   }
383 |   
384 |   toggleColorPicker() {
385 |     this.colorPickerActive = !this.colorPickerActive;
386 |     document.getElementById('color-pick-button').classList.toggle('active', this.colorPickerActive);
387 |     
388 |     if (this.colorPickerActive) {
389 |       // Show instruction message
390 |       const message = document.createElement('div');
391 |       message.id = 'color-picker-message';
392 |       message.textContent = 'Click on any object to copy its color';
393 |       message.style.position = 'fixed';
394 |       message.style.top = '100px';
395 |       message.style.left = '50%';
396 |       message.style.transform = 'translateX(-50%)';
397 |       message.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
398 |       message.style.color = 'white';
399 |       message.style.padding = '10px';
400 |       message.style.borderRadius = '5px';
401 |       message.style.zIndex = '2000';
402 |       document.getElementById('game-container').appendChild(message);
403 |     } else {
404 |       // Remove instruction message
405 |       const message = document.getElementById('color-picker-message');
406 |       if (message) message.remove();
407 |     }
408 |   }
409 | 
410 |   pickColorFromObject(object) {
411 |     if (!this.selectedObject) {
412 |       this.colorPickerActive = false;
413 |       document.getElementById('color-pick-button').classList.remove('active');
414 |       const message = document.getElementById('color-picker-message');
415 |       if (message) message.remove();
416 |       return;
417 |     }
418 |     
419 |     // Get color from object
420 |     const color = object.material.color.clone();
421 |     
422 |     // Apply to selected object
423 |     this.changeObjectColor(color);
424 |     
425 |     // Update color picker inputs
426 |     const r = Math.round(color.r * 255);
427 |     const g = Math.round(color.g * 255);
428 |     const b = Math.round(color.b * 255);
429 |     
430 |     document.getElementById('color-r').value = r;
431 |     document.getElementById('color-g').value = g;
432 |     document.getElementById('color-b').value = b;
433 |     document.getElementById('color-preview').style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
434 |     
435 |     // Exit color picker mode
436 |     this.colorPickerActive = false;
437 |     document.getElementById('color-pick-button').classList.remove('active');
438 |     const message = document.getElementById('color-picker-message');
439 |     if (message) message.remove();
440 |   }
441 | 
442 |   changeObjectColor(color) {
443 |     if (!this.selectedObject) return;
444 |     
445 |     // Clone the material to avoid affecting other objects with the same material
446 |     if (!this.selectedObject.userData.originalMaterial) {
447 |       this.selectedObject.userData.originalMaterial = this.selectedObject.material.clone();
448 |     }
449 |     
450 |     const newMaterial = this.selectedObject.material.clone();
451 |     newMaterial.color.copy(color);
452 |     this.selectedObject.material = newMaterial;
453 |     
454 |     // Sync color change with other players
455 |     if (this.room) {
456 |       const colorData = {
457 |         type: 'color_object',
458 |         objectId: this.selectedObject.userData.id,
459 |         color: {
460 |           r: color.r,
461 |           g: color.g,
462 |           b: color.b
463 |         }
464 |       };
465 |       
466 |       this.room.send(colorData);
467 |       
468 |       // Update in room state
469 |       if (this.room.roomState.buildObjects && this.selectedObject.userData.id) {
470 |         const updatedBuildObjects = { ...(this.room.roomState.buildObjects) };
471 |         if (updatedBuildObjects[this.selectedObject.userData.id]) {
472 |           updatedBuildObjects[this.selectedObject.userData.id] = {
473 |             ...updatedBuildObjects[this.selectedObject.userData.id],
474 |             color: {
475 |               r: color.r,
476 |               g: color.g,
477 |               b: color.b
478 |             }
479 |           };
480 |           this.room.updateRoomState({
481 |             buildObjects: updatedBuildObjects
482 |           });
483 |         }
484 |       }
485 |     }
486 |   }
487 | 
488 |   receiveObjectColor(colorData) {
489 |     if (!colorData || !colorData.objectId) return;
490 |     
491 |     const object = [...this.buildTool.buildObjects, ...this.advancedBuildObjects].find(
492 |       obj => obj.userData.id === colorData.objectId
493 |     );
494 |     
495 |     if (object) {
496 |       const newMaterial = object.material.clone();
497 |       newMaterial.color.setRGB(
498 |         colorData.color.r,
499 |         colorData.color.g,
500 |         colorData.color.b
501 |       );
502 |       object.material = newMaterial;
503 |     }
504 |   }
505 |   
506 |   updateColorPreview() {
507 |     const r = document.getElementById('color-r').value;
508 |     const g = document.getElementById('color-g').value;
509 |     const b = document.getElementById('color-b').value;
510 |     document.getElementById('color-preview').style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
511 |   }
512 | }


--------------------------------------------------------------------------------
/js/aiBuilder.js:
--------------------------------------------------------------------------------
  1 | export class AIBuilder {
  2 |     constructor(buildTool) {
  3 |         this.buildTool = buildTool;
  4 |         this.scene = buildTool.scene;
  5 |         this.room = buildTool.room;
  6 |     }
  7 | 
  8 |     async generateStructure(prompt) {
  9 |         if (!this.room || this.buildTool.aiBuilding) return;
 10 | 
 11 |         this.buildTool.aiBuilding = true;
 12 |         try {
 13 |             this.showIndicator("Generating your structure...");
 14 |             const completion = await websim.chat.completions.create({
 15 |                 messages: [
 16 |                     {
 17 |                         role: "system",
 18 |                         content: `You are a 3D structure generator for a multiplayer game.
 19 |                         Create structured 3D object placements from the user's description.
 20 |                         Respond with ONLY JSON in this format:
 21 |                         {
 22 |                           "objects": [
 23 |                             {
 24 |                               "type": "box|sphere|cylinder|cone|torus",
 25 |                               "position": {"x": number, "y": number, "z": number},
 26 |                               "scale": {"x": number, "y": number, "z": number},
 27 |                               "rotation": {"x": number, "y": number, "z": number},
 28 |                               "materialIndex": number (0-5)
 29 |                             }
 30 |                           ],
 31 |                           "description": "brief description of the created structure"
 32 |                         }
 33 |                         IMPORTANT CONSTRAINTS:
 34 |                         - Keep all Y positions >= 0.5
 35 |                         - Keep all objects within reasonable game bounds (-50 to 50 for X and Z)
 36 |                         - Ensure structures are playable and make logical sense
 37 |                         - Use a maximum of 50 objects for performance reasons`
 38 |                     },
 39 |                     { role: "user", content: `Create a 3D structure: ${prompt}` }
 40 |                 ],
 41 |                 json: true
 42 |             });
 43 | 
 44 |             const structureData = JSON.parse(completion.content);
 45 |             if (structureData.objects && Array.isArray(structureData.objects)) {
 46 |                 const total = structureData.objects.length;
 47 |                 let placed = 0;
 48 |                 this.showIndicator(`Building: ${structureData.description} (0%)...`, 0);
 49 | 
 50 |                 const buildNext = () => {
 51 |                     if (placed >= total) {
 52 |                         this.showIndicator(`Created: ${structureData.description}`, null, true);
 53 |                         setTimeout(() => this.hideIndicator(), 3000);
 54 |                         this.buildTool.aiBuilding = false;
 55 |                         return;
 56 |                     }
 57 | 
 58 |                     this.placeObject(structureData.objects[placed]);
 59 |                     placed++;
 60 |                     const progress = Math.round((placed / total) * 100);
 61 |                     this.showIndicator(`Building: ${structureData.description} (${progress}%)...`, progress);
 62 |                     requestAnimationFrame(buildNext);
 63 |                 };
 64 | 
 65 |                 requestAnimationFrame(buildNext);
 66 |             } else {
 67 |                 throw new Error('Invalid structure data');
 68 |             }
 69 |         } catch (error) {
 70 |             console.error('Error generating structure:', error);
 71 |             this.showIndicator("Error creating structure. Please try again.", null, true);
 72 |             setTimeout(() => this.hideIndicator(), 3000);
 73 |             this.buildTool.aiBuilding = false;
 74 |         }
 75 |     }
 76 | 
 77 |     placeObject(objectData) {
 78 |         if (!objectData || !objectData.type) return;
 79 | 
 80 |         let geometry;
 81 |         switch (objectData.type.toLowerCase()) {
 82 |             case 'box': geometry = new THREE.BoxGeometry(1, 1, 1); break;
 83 |             case 'sphere': geometry = new THREE.SphereGeometry(0.5, 16, 16); break;
 84 |             case 'cylinder': geometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 16); break;
 85 |             case 'cone': geometry = new THREE.ConeGeometry(0.5, 1, 16); break;
 86 |             case 'torus': geometry = new THREE.TorusGeometry(0.5, 0.2, 16, 32); break;
 87 |             default: geometry = new THREE.BoxGeometry(1, 1, 1);
 88 |         }
 89 | 
 90 |         const materialIndex = Math.min(objectData.materialIndex || 0, this.buildTool.buildMaterials.length - 1);
 91 |         const material = this.buildTool.buildMaterials[materialIndex].clone();
 92 |         const buildObject = new THREE.Mesh(geometry, material);
 93 | 
 94 |         const position = objectData.position || { x: 0, y: 0.5, z: 0 };
 95 |         buildObject.position.set(
 96 |             Math.max(-50, Math.min(50, position.x || 0)) / 5,
 97 |             Math.max(0.5, position.y || 0.5) / 5,
 98 |             Math.max(-50, Math.min(50, position.z || 0)) / 5
 99 |         );
100 | 
101 |         if (this.buildTool.isLocationOccupiedByPlayer(buildObject.position)) return;
102 |         const scale = objectData.scale || { x: 1, y: 1, z: 1 };
103 |         buildObject.scale.set(
104 |             Math.max(0.1, Math.min(10, scale.x || 1)) / 5,
105 |             Math.max(0.1, Math.min(10, scale.y || 1)) / 5,
106 |             Math.max(0.1, Math.min(10, scale.z || 1)) / 5
107 |         );
108 |         const rotation = objectData.rotation || { x: 0, y: 0, z: 0 };
109 |         buildObject.rotation.set(rotation.x || 0, rotation.y || 0, rotation.z || 0);
110 | 
111 |         buildObject.castShadow = true;
112 |         buildObject.receiveShadow = true;
113 |         buildObject.userData.isBarrier = true;
114 | 
115 |         const objectId = 'build_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
116 |         buildObject.userData.id = objectId;
117 |         buildObject.userData.createdAt = Date.now();
118 | 
119 |         this.scene.add(buildObject);
120 |         this.buildTool.buildObjects.push(buildObject);
121 | 
122 |         if (this.room) {
123 |             const buildData = {
124 |                 objectId,
125 |                 position: buildObject.position,
126 |                 scale: buildObject.scale,
127 |                 rotation: {x: buildObject.rotation.x, y: buildObject.rotation.y, z: buildObject.rotation.z},
128 |                 materialIndex: materialIndex,
129 |                 geometryType: buildObject.geometry.type,
130 |                 createdAt: buildObject.userData.createdAt
131 |             };
132 |             this.room.send({ type: 'build_object', ...buildData });
133 |             
134 |             const updatedBuildObjects = { ...(this.room.roomState.buildObjects || {}) };
135 |             updatedBuildObjects[objectId] = buildData;
136 |             this.room.updateRoomState({ buildObjects: updatedBuildObjects });
137 |         }
138 |     }
139 | 
140 |     showIndicator(message, progress = null, isComplete = false) {
141 |         let indicator = document.getElementById('ai-building-indicator');
142 |         if (!indicator) {
143 |             indicator = document.createElement('div');
144 |             indicator.id = 'ai-building-indicator';
145 |             document.getElementById('game-container').appendChild(indicator);
146 |         }
147 |         const progressBar = progress !== null && !isComplete ?
148 |             `<div class="ai-progress"><div class="ai-progress-bar" style="width:${progress}%"></div></div>` : '';
149 |         indicator.innerHTML = `
150 |             <div class="ai-building-message">
151 |                 ${isComplete ? '' : '<div class="ai-loading-spinner"></div>'}
152 |                 <div class="ai-building-text">${message}${progressBar}</div>
153 |             </div>
154 |         `;
155 |         indicator.style.display = 'flex';
156 |     }
157 | 
158 |     hideIndicator() {
159 |         const indicator = document.getElementById('ai-building-indicator');
160 |         if (indicator) indicator.style.display = 'none';
161 |     }
162 | }
163 | 


--------------------------------------------------------------------------------
/js/animationSetup.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | 
  3 | export function setupAnimatedPlayer(model, idleClip, walkClip, runClip) {
  4 |     // Rename clips for easier access
  5 |     idleClip.name = 'idle';
  6 |     walkClip.name = 'walk';
  7 |     runClip.name = 'run';
  8 | 
  9 |     // Filter out rotation tracks from the idle animation to preserve player orientation
 10 |     /* @tweakable Set to false to allow the idle animation to control player rotation. */
 11 |     const removeIdleRotation = true;
 12 |     if (removeIdleRotation) {
 13 |         idleClip.tracks = idleClip.tracks.filter(track => !track.name.endsWith('.quaternion'));
 14 |     }
 15 | 
 16 |     model.animations = [idleClip, walkClip, runClip];
 17 | 
 18 |     const mixer = new THREE.AnimationMixer(model);
 19 |     const actions = {
 20 |         idle: mixer.clipAction(idleClip),
 21 |         walk: mixer.clipAction(walkClip),
 22 |         run: mixer.clipAction(runClip),
 23 |     };
 24 |     
 25 |     /* @tweakable Duration for fading between animations in seconds. */
 26 |     model.userData.animationFadeDuration = 0.3;
 27 | 
 28 |     actions.idle.play();
 29 | 
 30 |     // Set a rotation offset so the GLB faces the same direction as procedural models.
 31 |     // This is used by the controls system to align the model with its movement direction.
 32 |     /* @tweakable Rotation offset for the animated GLB player model in radians. Adjust this if the model faces the wrong direction. 0 means no offset, -Math.PI / 2 is -90 degrees. */
 33 |     const rotationOffset = 0; // Set to 0 to remove the initial rotation.
 34 |     // model.rotation.y = rotationOffset; // We no longer apply initial rotation here.
 35 |     model.userData.rotationOffset = rotationOffset;
 36 | 
 37 |     model.userData.mixer = mixer;
 38 |     model.userData.actions = actions;
 39 |     model.userData.isAnimatedGLB = true;
 40 | 
 41 |     return model;
 42 | }
 43 | 
 44 | export function setupAnimatedRobot(model, idleClip, walkClip, listenClip) {
 45 |     idleClip.name = 'idle';
 46 |     walkClip.name = 'walk';
 47 |     listenClip.name = 'listen';
 48 | 
 49 |     model.animations = [idleClip, walkClip, listenClip];
 50 | 
 51 |     const mixer = new THREE.AnimationMixer(model);
 52 |     const actions = {
 53 |         idle: mixer.clipAction(idleClip),
 54 |         walk: mixer.clipAction(walkClip),
 55 |         listen: mixer.clipAction(listenClip),
 56 |     };
 57 |     
 58 |     /* @tweakable Duration for fading between robot animations in seconds. */
 59 |     model.userData.animationFadeDuration = 0.4;
 60 | 
 61 |     actions.idle.play();
 62 | 
 63 |     /* @tweakable Rotation offset for the animated robot GLB model in radians. */
 64 |     const rotationOffset = 0;
 65 |     model.userData.rotationOffset = rotationOffset;
 66 | 
 67 |     model.userData.mixer = mixer;
 68 |     model.userData.actions = actions;
 69 |     model.userData.isAnimatedGLB = true;
 70 | 
 71 |     return model;
 72 | }
 73 | 
 74 | export function setupAnimatedChicken(model, idleClip, walkClip, runClip, alertClip, listenClip) {
 75 |     idleClip.name = 'idle';
 76 |     walkClip.name = 'walk';
 77 |     runClip.name = 'run';
 78 |     alertClip.name = 'alert';
 79 |     listenClip.name = 'listen';
 80 | 
 81 |     model.animations = [idleClip, walkClip, runClip, alertClip, listenClip];
 82 | 
 83 |     const mixer = new THREE.AnimationMixer(model);
 84 |     const actions = {
 85 |         idle: mixer.clipAction(idleClip),
 86 |         walk: mixer.clipAction(walkClip),
 87 |         run: mixer.clipAction(runClip),
 88 |         alert: mixer.clipAction(alertClip),
 89 |         listen: mixer.clipAction(listenClip),
 90 |     };
 91 |     
 92 |     /* @tweakable Duration for fading between chicken animations in seconds. */
 93 |     model.userData.animationFadeDuration = 0.4;
 94 |     actions.idle.play();
 95 | 
 96 |     /* @tweakable Rotation offset for the animated chicken GLB model in radians. */
 97 |     const rotationOffset = 0;
 98 |     model.userData.rotationOffset = rotationOffset;
 99 | 
100 |     model.userData.mixer = mixer;
101 |     model.userData.actions = actions;
102 |     model.userData.isAnimatedGLB = true;
103 | 
104 |     return model;
105 | }
106 | 
107 | export function setupAnimatedWireframe(model, idleClip, walkClip, runClip, listenClip) {
108 |     idleClip.name = 'idle';
109 |     walkClip.name = 'walk';
110 |     runClip.name = 'run';
111 |     listenClip.name = 'listen';
112 | 
113 |     model.animations = [idleClip, walkClip, runClip, listenClip];
114 | 
115 |     const mixer = new THREE.AnimationMixer(model);
116 |     const actions = {
117 |         idle: mixer.clipAction(idleClip),
118 |         walk: mixer.clipAction(walkClip),
119 |         run: mixer.clipAction(runClip),
120 |         listen: mixer.clipAction(listenClip),
121 |     };
122 |     
123 |     /* @tweakable Duration for fading between wireframe animations in seconds. */
124 |     model.userData.animationFadeDuration = 0.4;
125 |     actions.idle.play();
126 | 
127 |     /* @tweakable Rotation offset for the animated wireframe GLB model in radians. */
128 |     const rotationOffset = 0;
129 |     model.userData.rotationOffset = rotationOffset;
130 | 
131 |     model.userData.mixer = mixer;
132 |     model.userData.actions = actions;
133 |     model.userData.isAnimatedGLB = true;
134 | 
135 |     return model;
136 | }
137 | 
138 | export function setupAnimatedAlien(model, idleClip, walkClip, runClip, listenClip) {
139 |     idleClip.name = 'idle';
140 |     walkClip.name = 'walk';
141 |     runClip.name = 'run';
142 |     listenClip.name = 'listen';
143 | 
144 |     model.animations = [idleClip, walkClip, runClip, listenClip];
145 | 
146 |     const mixer = new THREE.AnimationMixer(model);
147 |     const actions = {
148 |         idle: mixer.clipAction(idleClip),
149 |         walk: mixer.clipAction(walkClip),
150 |         run: mixer.clipAction(runClip),
151 |         listen: mixer.clipAction(listenClip),
152 |     };
153 |     
154 |     /* @tweakable Duration for fading between alien animations in seconds. */
155 |     model.userData.animationFadeDuration = 0.4;
156 |     actions.idle.play();
157 | 
158 |     /* @tweakable Rotation offset for the animated alien GLB model in radians. */
159 |     const rotationOffset = 0;
160 |     model.userData.rotationOffset = rotationOffset;
161 | 
162 |     model.userData.mixer = mixer;
163 |     model.userData.actions = actions;
164 |     model.userData.isAnimatedGLB = true;
165 | 
166 |     return model;
167 | }
168 | 
169 | export function setupEyebot(model) {
170 |     model.userData.isEyebot = true;
171 |     model.userData.isAnimatedGLB = false; // It is not using baked animations
172 |     
173 |     /* @tweakable Rotation offset for the eyebot GLB model in radians. */
174 |     const rotationOffset = 0;
175 |     model.userData.rotationOffset = rotationOffset;
176 | 
177 |     /* @tweakable Enables bobbing animation for the eyebot. */
178 |     const enableBobbing = true;
179 |     /* @tweakable Speed of the eyebot's bobbing animation. */
180 |     const bobSpeed = 2;
181 |     /* @tweakable Amplitude of the eyebot's bobbing animation. */
182 |     const bobAmplitude = 0.1;
183 |     
184 |     /* @tweakable Enables aimless spinning animation for the eyebot. Set to false to allow directional movement. */
185 |     const enableSpinning = false;
186 |     /* @tweakable Speed of the eyebot's spinning animation. */
187 |     const spinSpeed = 0.5;
188 | 
189 |     const initialRotationY = model.rotation.y;
190 | 
191 |     if (enableBobbing || enableSpinning) {
192 |         // base Y position needs to be set when spawned
193 |         model.userData.updateAnimations = (time) => {
194 |             if (enableBobbing && model.userData.baseY) {
195 |                  model.position.y = model.userData.baseY + (Math.sin(time * bobSpeed) * bobAmplitude);
196 |             }
197 |             if (enableSpinning) {
198 |                 model.rotation.y = initialRotationY + time * spinSpeed;
199 |             }
200 |         };
201 |     }
202 |     
203 |     return model;
204 | }


--------------------------------------------------------------------------------
/js/app.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from "three";
  2 | import { PlayerControls } from "./playerControls.js";
  3 | import { createPlayerModel } from "./playerModel.js";
  4 | import { ZONE_SIZE, createBarriers, createTrees, createClouds, createGroundGrid } from "./worldGeneration.js";
  5 | import { BuildTool } from "./buildTool.js";
  6 | import { AdvancedBuildTool } from "./advancedBuildTool.js";
  7 | import { UIManager } from './uiManager.js';
  8 | import { CharacterCreator } from './characterCreator.js';
  9 | import { MultiplayerManager } from './multiplayerManager.js';
 10 | import { ObjectCreator } from './objectCreator.js';
 11 | import { InventoryManager } from './inventoryManager.js';
 12 | import { NPCManager } from './npcManager.js';
 13 | import { InteractionManager } from './interaction.js';
 14 | import { AssetReplacementManager } from './assetReplacementManager.js';
 15 | import { CollisionManager } from './collisionManager.js';
 16 | import { CSS2DRenderer } from 'three/addons/renderers/CSS2DRenderer.js';
 17 | import './npc/NPC.js';
 18 | import './npc/ZoneManager.js';
 19 | import './npc/NPCSpawner.js';
 20 | import './previewManager.js'; // Ensure it's part of the context
 21 | import { FORCE_MOBILE_MODE } from './controls/constants.js';
 22 | import { World } from './world.js';
 23 | 
 24 | /* @tweakable The maximum distance at which grid labels are visible at full density. Lower values can improve performance. */
 25 | const GRID_LABEL_VISIBILITY_DISTANCE = 7;
 26 | /* @tweakable The distance at which to switch to a more sparse set of grid labels to reduce visual clutter and improve performance. */
 27 | const GRID_LABEL_LOD_DISTANCE = 30;
 28 | /* @tweakable The step rate for showing labels at the LOD distance. e.g., a value of 10 shows every 10th label. */
 29 | const GRID_LABEL_LOD_STEP = 10;
 30 | /* @tweakable How frequently to update grid label visibility (in frames). Larger numbers reduce lag but also decrease label responsiveness. */
 31 | const LABEL_UPDATE_INTERVAL = 10;
 32 | 
 33 | // Simple seeded random number generator
 34 | class MathRandom {
 35 |   constructor(seed) {
 36 |     this.seed = seed;
 37 |   }
 38 |   
 39 |   random() {
 40 |     const x = Math.sin(this.seed++) * 10000;
 41 |     return x - Math.floor(x);
 42 |   }
 43 | }
 44 | 
 45 | let collectedRemotes = {};
 46 | 
 47 | async function main() {
 48 |   // Initialize WebsimSocket for multiplayer functionality
 49 |   const room = new WebsimSocket();
 50 |   await room.initialize();
 51 |   
 52 |   // Get current user for special spawn logic
 53 |   const currentUser = await window.websim.getCurrentUser();
 54 | 
 55 |   // Generate a player name if not available
 56 |   const playerInfo = room.peers[room.clientId] || {};
 57 |   const playerName = playerInfo.username || `Player${Math.floor(Math.random() * 1000)}`;
 58 |   
 59 |   // --- Special Spawn Logic ---
 60 |   /* @tweakable The target username for the special spawn location. */
 61 |   const targetUsername = "lordtsarcasm";
 62 |   /* @tweakable The special spawn location coordinates. */
 63 |   const specialSpawnLocation = { x: 44.1, y: 13.7, z: 21.4 };
 64 | 
 65 |   let initialPosition;
 66 |   if (currentUser && currentUser.username === targetUsername) {
 67 |     initialPosition = specialSpawnLocation;
 68 |   } else {
 69 |     // Default random position
 70 |     initialPosition = {
 71 |       x: (Math.random() * 10) - 5,
 72 |       y: 0.70, // Default Y
 73 |       z: (Math.random() * 10) - 5
 74 |     };
 75 |   }
 76 |   
 77 |   // Safe initial position values
 78 |   const playerX = initialPosition.x;
 79 |   const playerY = initialPosition.y;
 80 |   const playerZ = initialPosition.z;
 81 | 
 82 |   // Setup Three.js scene
 83 |   const scene = new THREE.Scene();
 84 |   /* @tweakable The color of the sky. */
 85 |   scene.background = new THREE.Color(0x87CEEB); // Light sky blue background
 86 |   
 87 |   // Create renderer before it is used by other components
 88 |   /* @tweakable Enable antialiasing for smoother edges. Can impact performance. */
 89 |   const renderer = new THREE.WebGLRenderer({ antialias: true });
 90 |   renderer.setSize(window.innerWidth, window.innerHeight);
 91 |   renderer.shadowMap.enabled = true;
 92 |   renderer.shadowMap.type = THREE.PCFSoftShadowMap; // PCFSoftShadowMap for softer shadows
 93 |   document.getElementById('game-container').appendChild(renderer.domElement);
 94 |   
 95 |   // Create player model with default appearance. It will be passed to controls.
 96 |   let playerModel = createPlayerModel(THREE, playerName);
 97 |   scene.add(playerModel);
 98 | 
 99 |   // Create managers and controls. We will set the terrain on them after it's generated.
100 |   const playerControls = new PlayerControls(scene, room, {
101 |     renderer: renderer,
102 |     initialPosition: {
103 |       x: playerX,
104 |       y: playerY,
105 |       z: playerZ
106 |     },
107 |     playerModel: playerModel,
108 |     terrain: null, // Terrain will be set after generation
109 |   });
110 | 
111 |   const npcManager = new NPCManager(scene, null, playerControls);
112 |   
113 |   // Get camera after playerControls is fully initialized
114 |   const camera = playerControls.getCamera();
115 |   const listener = new THREE.AudioListener();
116 |   camera.add(listener);
117 | 
118 |   // Create world, which generates the terrain
119 |   const world = new World(scene, npcManager);
120 |   const terrain = world.generate(listener);
121 |   
122 |   // Now that terrain exists, set it on the managers that need it.
123 |   playerControls.terrain = terrain;
124 |   npcManager.terrain = terrain;
125 |   // Initialize NPC Spawner with terrain
126 |   npcManager.initializeSpawner(terrain);
127 | 
128 |   // Create barriers, trees, and clouds which depend on the terrain
129 |   createBarriers(scene, terrain.userData.getHeight);
130 |   createTrees(scene, terrain.userData.getHeight);
131 |   createClouds(scene);
132 |   
133 |   // Setup label renderer
134 |   const labelRenderer = new CSS2DRenderer();
135 |   labelRenderer.setSize(window.innerWidth, window.innerHeight);
136 |   labelRenderer.domElement.style.position = 'absolute';
137 |   labelRenderer.domElement.style.top = '0px';
138 |   labelRenderer.domElement.style.pointerEvents = 'none';
139 |   document.getElementById('label-container').appendChild(labelRenderer.domElement);
140 |   
141 |   // Add dev button to toggle mobile/desktop mode
142 |   const isMobileModeForced = localStorage.getItem('forceMobileMode') === 'true';
143 |   const devToggleButton = document.createElement('button');
144 |   devToggleButton.textContent = 'Toggle View';
145 |   devToggleButton.id = 'dev-toggle-button';
146 |   devToggleButton.setAttribute('data-tooltip', isMobileModeForced ? 'Switch to Desktop View' : 'Switch to Mobile View');
147 |   document.body.appendChild(devToggleButton);
148 | 
149 |   devToggleButton.addEventListener('click', () => {
150 |     const currentMode = localStorage.getItem('forceMobileMode') === 'true';
151 |     localStorage.setItem('forceMobileMode', String(!currentMode));
152 |     location.reload();
153 |   });
154 | 
155 |   // Create UI containers for mobile controls
156 |   if (FORCE_MOBILE_MODE || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
157 |     // joystick containers are now in index.html, we just need the jump button
158 |     const jumpButton = document.createElement('div');
159 |     jumpButton.id = 'jump-button';
160 |     jumpButton.innerText = 'JUMP';
161 |     document.body.appendChild(jumpButton);
162 |   }
163 | 
164 |   // Initialize build tool
165 |   const buildTool = new BuildTool(scene, camera, playerControls, terrain);
166 |   buildTool.setRoom(room); // Pass room to buildTool for multiplayer sync
167 |   
168 |   // Initialize advanced build tool
169 |   const objectCreator = new ObjectCreator(scene, camera, room, buildTool);
170 |   const advancedBuildTool = new AdvancedBuildTool(scene, camera, renderer, buildTool, objectCreator);
171 |   advancedBuildTool.setRoom(room);
172 |   advancedBuildTool.setOrbitControls(playerControls.controls);
173 |   
174 |   // Load existing build objects from room state
175 |   if (room.roomState && room.roomState.buildObjects) {
176 |     Object.values(room.roomState.buildObjects || {}).forEach(buildData => {
177 |       if (buildData.isAdvanced) {
178 |         advancedBuildTool.receiveBuildObject(buildData);
179 |       } else {
180 |         buildTool.receiveBuildObject(buildData);
181 |       }
182 |     });
183 |   }
184 | 
185 |   const multiplayerManager = new MultiplayerManager({
186 |     room,
187 |     scene,
188 |     camera,
189 |     renderer,
190 |     buildTool,
191 |     advancedBuildTool,
192 |     createPlayerModel: (three, username, spec) => createPlayerModel(three, username, spec),
193 |     playerControls
194 |   });
195 |   multiplayerManager.init();
196 | 
197 |   const assetReplacementManager = new AssetReplacementManager({
198 |     playerControls,
199 |     npcManager,
200 |     onPlayerModelReplaced: (model) => { playerModel = model; }
201 |   });
202 | 
203 |   const characterCreator = new CharacterCreator(
204 |     THREE,
205 |     room,
206 |     playerControls,
207 |     (newSpec) => {
208 |       // Remove old player model
209 |       scene.remove(playerModel);
210 |       
211 |       // Create new player model with the character spec
212 |       playerModel = createPlayerModel(THREE, playerName, newSpec);
213 |       scene.add(playerModel);
214 |       
215 |       // Update player controls with new model
216 |       playerControls.playerModel = playerModel;
217 | 
218 |       return playerModel;
219 |     }
220 |   );
221 | 
222 |   const interactionManager = new InteractionManager({
223 |     playerControls,
224 |     npcManager,
225 |     camera,
226 |     renderer
227 |   });
228 |   interactionManager.init();
229 | 
230 |   const inventoryManager = new InventoryManager({ playerControls });
231 | 
232 |   // Ambient light
233 |   /* @tweakable The intensity of the ambient light. */
234 |   const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
235 |   scene.add(ambientLight);
236 |   
237 |   // Directional light (sun)
238 |   /* @tweakable The intensity of the directional light. */
239 |   const dirLight = new THREE.DirectionalLight(0xffffff, 1);
240 |   /* @tweakable The position of the sun (directional light). */
241 |   dirLight.position.set(5, 10, 5);
242 |   dirLight.castShadow = true;
243 |   /* @tweakable Shadow map resolution. Higher values are more detailed but slower. */
244 |   dirLight.shadow.mapSize.width = 1024;
245 |   /* @tweakable Shadow map resolution. Higher values are more detailed but slower. */
246 |   dirLight.shadow.mapSize.height = 1024;
247 |   /* @tweakable The size of the area around the player that casts shadows. Larger values can reduce shadow quality but extend shadow range. */
248 |   const shadowFrustumSize = 100;
249 |   dirLight.shadow.camera.near = 0.5;
250 |   /* @tweakable The maximum distance for shadows from the light source. Affects shadow precision. */
251 |   dirLight.shadow.camera.far = 500;
252 |   dirLight.shadow.camera.left = -shadowFrustumSize / 2;
253 |   dirLight.shadow.camera.right = shadowFrustumSize / 2;
254 |   dirLight.shadow.camera.top = shadowFrustumSize / 2;
255 |   dirLight.shadow.camera.bottom = -shadowFrustumSize / 2;
256 |   /* @tweakable Shadow bias to prevent shadow acne. */
257 |   dirLight.shadow.bias = -0.0001;
258 |   /* @tweakable Shadow radius for softer shadows (PCFSoftShadowMap). */
259 |   dirLight.shadow.radius = 1.5;
260 |   scene.add(dirLight);
261 |   scene.add(dirLight.target);
262 | 
263 |   const uiManager = new UIManager({
264 |       playerControls,
265 |       buildTool,
266 |       advancedBuildTool,
267 |       characterCreator,
268 |       objectCreator,
269 |       inventoryManager,
270 |       multiplayerManager,
271 |       npcManager,
272 |       assetReplacementManager,
273 |       room,
274 |       renderer,
275 |       playerModel,
276 |       dirLight,
277 |       scene
278 |   });
279 |   const { inventoryUI, mapUI } = uiManager.init();
280 |   
281 |   inventoryManager.inventoryUI = inventoryUI;
282 |   inventoryManager.init();
283 |   
284 |   // Grid helper for better spatial awareness
285 |   /* @tweakable The total size of the grid (width and depth). */
286 |   const gridHelperSize = 200;
287 |   /* @tweakable The number of divisions across the grid. */
288 |   const gridHelperDivisions = 200;
289 |   /* @tweakable The color of the lines at the center of the grid. */
290 |   const gridHelperColorCenterLine = 0xffffff;
291 |   /* @tweakable The color of the main grid lines. */
292 |   const gridHelperColorGrid = 0xcccccc;
293 |   const gridHelper = createGroundGrid(terrain, gridHelperSize, gridHelperDivisions, gridHelperColorCenterLine, gridHelperColorGrid);
294 |   gridHelper.visible = false; // Hidden by default
295 |   // Ensure grid labels follow the grid's visibility state
296 |   const initialLabelsGroup = gridHelper.getObjectByName('grid-labels-group');
297 |   if (initialLabelsGroup) {
298 |     initialLabelsGroup.visible = false;
299 |   }
300 |   scene.add(gridHelper);
301 |   
302 |   // Add a global keydown listener for toggling the grid
303 |   window.addEventListener('keydown', (event) => {
304 |     // Prevent toggling if an input is focused
305 |     if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') {
306 |         return;
307 |     }
308 |     // Toggle grid visibility with 'G' key
309 |     if (event.key.toLowerCase() === 'g' && !advancedBuildTool.enabled) {
310 |       /* @tweakable Whether the grid helper is visible or not. This is toggled by the 'G' key. */
311 |       gridHelper.visible = !gridHelper.visible;
312 |       const labelsGroup = gridHelper.getObjectByName('grid-labels-group');
313 |       if (labelsGroup) {
314 |         labelsGroup.visible = gridHelper.visible;
315 |       }
316 |       if (!gridHelper.visible) {
317 |         gridHelper.userData.clearLabels();
318 |       } else {
319 |         gridHelper.userData.updateLabels(playerModel.position, GRID_LABEL_VISIBILITY_DISTANCE, GRID_LABEL_LOD_DISTANCE, GRID_LABEL_LOD_STEP);
320 |       }
321 |     }
322 |   });
323 | 
324 |   let labelUpdateCounter = 0;
325 |   /* @tweakable How frequently to update grid label visibility (in frames). Larger numbers reduce lag but also decrease label responsiveness. */
326 |   const labelUpdateInterval = LABEL_UPDATE_INTERVAL;
327 | 
328 |   // Video screen occlusion logic
329 |   const raycaster = new THREE.Raycaster();
330 | 
331 |   // Animation loop
332 |   function animate() {
333 |     requestAnimationFrame(animate);
334 |     const time = performance.now() * 0.001; // Current time in seconds
335 |     const currentTime = Date.now(); // Current time in milliseconds
336 |     
337 |     playerControls.update();
338 |     
339 |     // render uiManager related components
340 |     if(uiManager) uiManager.update();
341 | 
342 |     labelUpdateCounter++;
343 |     if (labelUpdateCounter >= labelUpdateInterval) {
344 |         labelUpdateCounter = 0;
345 |         if (gridHelper.visible) {
346 |             gridHelper.userData.updateLabels(
347 |                 playerModel.position,
348 |                 GRID_LABEL_VISIBILITY_DISTANCE,
349 |                 GRID_LABEL_LOD_DISTANCE,
350 |                 GRID_LABEL_LOD_STEP
351 |             );
352 |         }
353 |     }
354 | 
355 |     interactionManager.update();
356 |     npcManager.update();
357 | 
358 |     // Update custom animations for player model
359 |     if (playerModel && playerModel.userData.updateAnimations) {
360 |         playerModel.userData.updateAnimations(time);
361 |     }
362 | 
363 |     multiplayerManager.updatePlayerLabels();
364 |     
365 |     // Move shadow camera with player for global shadows
366 |     if (dirLight.castShadow) {
367 |         /* @tweakable The offset of the sun from the player, determining shadow direction. */
368 |         const lightOffset = new THREE.Vector3(30, 40, 25);
369 |         dirLight.position.copy(playerModel.position).add(lightOffset);
370 |         dirLight.target.position.copy(playerModel.position);
371 |     }
372 |     
373 |     // Check for remote collisions
374 |     const playerPositionForCollision = playerModel.position.clone();
375 |     scene.traverse((object) => {
376 |       if (object.userData && object.userData.isRemote) {
377 |         const worldPosition = new THREE.Vector3();
378 |         object.getWorldPosition(worldPosition);
379 |         
380 |         const distance = playerPositionForCollision.distanceTo(worldPosition);
381 |         if (distance < 1 && !multiplayerManager.collectedRemotes[object.userData.remoteId]) {
382 |           multiplayerManager.collectRemote(object.userData.remoteId, object);
383 |         }
384 |       }
385 |     });
386 |     
387 |     // Check for expired build objects (older than 50 minutes)
388 |     const expirationTime = 50 * 60 * 1000; // 50 minutes in milliseconds
389 |     buildTool.checkExpiredObjects(currentTime, expirationTime);
390 |     advancedBuildTool.checkExpiredObjects(currentTime, expirationTime);
391 |     
392 |     renderer.render(scene, camera);
393 |     labelRenderer.render(scene, camera);
394 |   }
395 |   
396 |   animate();
397 | }
398 | 
399 | main();


--------------------------------------------------------------------------------
/js/assetReplacementManager.js:
--------------------------------------------------------------------------------
  1 | import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
  2 | import { Downloader } from './downloader.js';
  3 | import { setupAnimatedPlayer, setupAnimatedRobot, setupAnimatedChicken, setupAnimatedWireframe, setupAnimatedAlien, setupEyebot } from './animationSetup.js';
  4 | 
  5 | export class AssetReplacementManager {
  6 |     constructor(dependencies) {
  7 |         this.dependencies = dependencies;
  8 |         this.downloader = new Downloader();
  9 |         this.assets = null;
 10 |         this.statusElement = null;
 11 |         // Optional callback for when the player model is replaced
 12 |         this.onPlayerModelReplaced = dependencies.onPlayerModelReplaced || null;
 13 | 
 14 |         this.modelTypes = {
 15 |             'player': {
 16 |                 assetNames: ['Player idle animation', 'Player walking animation', 'Player running animation'],
 17 |                 clipNames: ['idle', 'walk', 'run'],
 18 |                 setupFn: setupAnimatedPlayer,
 19 |                 applyFn: (modelData) => this.applyToPlayer(modelData)
 20 |             },
 21 |             'robot': {
 22 |                 assetNames: ['Robot idle 2 animation', 'Robot walking animation', 'Robot listening animation'],
 23 |                 clipNames: ['idle', 'walk', 'listen'],
 24 |                 setupFn: setupAnimatedRobot,
 25 |                 applyFn: (modelData) => this.dependencies.npcManager.useAnimatedRobots(modelData)
 26 |             },
 27 |             'eyebot': {
 28 |                 assetNames: ['Eyebot model'],
 29 |                 clipNames: [],
 30 |                 setupFn: setupEyebot,
 31 |                 applyFn: (modelData) => this.dependencies.npcManager.useEyebotModels(modelData)
 32 |             },
 33 |             'chicken': {
 34 |                 assetNames: ['Chicken Idle Animation', 'Chicken Walking Animation', 'Chicken Running Animation', 'Chicken Alert Animation', 'Chicken Listening Animation'],
 35 |                 clipNames: ['idle', 'walk', 'run', 'alert', 'listen'],
 36 |                 setupFn: setupAnimatedChicken,
 37 |                 applyFn: (modelData) => this.dependencies.npcManager.useAnimatedChickens(modelData)
 38 |             },
 39 |             'wireframe': {
 40 |                 assetNames: ['Wireframe Idle Animation', 'Wireframe Walking Animation', 'Wireframe Running Animation', 'Wireframe Listening Animation'],
 41 |                 clipNames: ['idle', 'walk', 'run', 'listen'],
 42 |                 setupFn: setupAnimatedWireframe,
 43 |                 applyFn: (modelData) => this.dependencies.npcManager.useAnimatedWireframes(modelData)
 44 |             },
 45 |             'alien': {
 46 |                 assetNames: ['Alien Idle Animation', 'Alien Walking Animation', 'Alien Running Animation', 'Alien Listening Animation'],
 47 |                 clipNames: ['idle', 'walk', 'run', 'listen'],
 48 |                 setupFn: setupAnimatedAlien,
 49 |                 applyFn: (modelData) => this.dependencies.npcManager.useAnimatedAliens(modelData)
 50 |             }
 51 |         };
 52 |     }
 53 | 
 54 |     setStatusElement(element) {
 55 |         this.statusElement = element;
 56 |     }
 57 | 
 58 |     updateStatus(message) {
 59 |         if (this.statusElement) {
 60 |             this.statusElement.textContent = message;
 61 |         }
 62 |     }
 63 | 
 64 |     async downloadExternalAssets() {
 65 |         this.updateStatus('Loading asset list...');
 66 |         try {
 67 |             const response = await fetch('assets.json');
 68 |             const data = await response.json();
 69 |             const external = data.assets.filter(a => /^https?:/.test(a.url));
 70 |             this.assets = await this.downloader.preloadAssets(external, (asset, p) => {
 71 |                 this.updateStatus(`Downloading ${asset.name} ${(p * 100).toFixed(0)}%`);
 72 |             });
 73 |             this.updateStatus('All assets downloaded.');
 74 |             return true;
 75 |         } catch (e) {
 76 |             this.updateStatus('Failed to download assets.');
 77 |             console.error(e);
 78 |             return false;
 79 |         }
 80 |     }
 81 | 
 82 |     /* @tweakable Delay in milliseconds between replacing each model type when using 'Use All'. */
 83 |     static allAssetsReplacementDelay = 200;
 84 | 
 85 |     async replaceAllModels() {
 86 |         if (!this.assets) {
 87 |             this.updateStatus('Please download assets first.');
 88 |             return;
 89 |         }
 90 | 
 91 |         this.updateStatus('Replacing all models...');
 92 | 
 93 |         for (const type in this.modelTypes) {
 94 |             if (type === 'player') continue;
 95 |             const modelInfo = this.modelTypes[type];
 96 |             if(this.dependencies.npcManager[`useAnimated${type.charAt(0).toUpperCase() + type.slice(1)}s`]){
 97 |                  this.dependencies.npcManager[`useAnimated${type.charAt(0).toUpperCase() + type.slice(1)}s`]({}, false); // Clear existing
 98 |             } else if(this.dependencies.npcManager[`use${type.charAt(0).toUpperCase() + type.slice(1)}Models`]) {
 99 |                 this.dependencies.npcManager[`use${type.charAt(0).toUpperCase() + type.slice(1)}Models`]({}, false); // Clear existing
100 |             }
101 |         }
102 | 
103 |         for (const type of Object.keys(this.modelTypes)) {
104 |             await this.replaceModel(type, false);
105 |             await new Promise(resolve => setTimeout(resolve, AssetReplacementManager.allAssetsReplacementDelay));
106 |         }
107 |         
108 |         // After all models are loaded and set, respawn NPCs
109 |         this.dependencies.npcManager.updatePlayerModel(null, true);
110 | 
111 |         this.updateStatus('All models have been replaced.');
112 |     }
113 | 
114 |     async replaceModel(type, respawnNpcs = true) {
115 |         const modelInfo = this.modelTypes[type];
116 |         if (!modelInfo) {
117 |             console.error(`Unknown model type: ${type}`);
118 |             return;
119 |         }
120 |         
121 |         if (!this.assets) {
122 |             this.updateStatus('Please download assets first.');
123 |             return;
124 |         }
125 | 
126 |         const requiredAssets = {};
127 |         for (const name of modelInfo.assetNames) {
128 |             if (!this.assets[name]) {
129 |                 this.updateStatus(`${name} asset missing.`);
130 |                 console.error(`${name} asset is missing.`);
131 |                 return;
132 |             }
133 |             requiredAssets[name] = this.assets[name];
134 |         }
135 | 
136 |         this.updateStatus(`Loading ${type} model...`);
137 | 
138 |         const loader = new GLTFLoader();
139 |         const assetUrls = Object.values(requiredAssets).map(asset => URL.createObjectURL(asset));
140 | 
141 |         try {
142 |             const gltfResults = await Promise.all(assetUrls.map(url => loader.loadAsync(url)));
143 | 
144 |             const model = gltfResults[0].scene;
145 |             const animations = gltfResults.map(gltf => gltf.animations[0]).filter(Boolean);
146 | 
147 |             let modelData = { model, setupFn: modelInfo.setupFn };
148 |             if (modelInfo.clipNames && modelInfo.clipNames.length > 0) {
149 |                 animations.forEach((clip, index) => {
150 |                     const clipName = modelInfo.clipNames[index];
151 |                     if (clipName) {
152 |                         modelData[`${clipName}Clip`] = clip;
153 |                     }
154 |                 });
155 |             }
156 | 
157 |             if (type === 'player') {
158 |                 modelInfo.applyFn(modelData);
159 |             } else if (modelInfo.applyFn) {
160 |                 // Pass respawnNpcs flag to NPC replacement methods
161 |                 modelInfo.applyFn(modelData, respawnNpcs);
162 |             }
163 | 
164 |             this.updateStatus(`${type.charAt(0).toUpperCase() + type.slice(1)} model applied.`);
165 |         } catch (error) {
166 |             console.error(`Error loading ${type} model:`, error);
167 |             this.updateStatus(`Failed to load ${type} model.`);
168 |         } finally {
169 |             assetUrls.forEach(url => URL.revokeObjectURL(url));
170 |         }
171 |     }
172 | 
173 |     applyToPlayer(modelData) {
174 |         const { model, setupFn } = modelData;
175 |         const scene = this.dependencies.playerControls.scene;
176 |         const controls = this.dependencies.playerControls;
177 | 
178 |         if (scene && controls) {
179 |             if (controls.playerModel) {
180 |                 scene.remove(controls.playerModel);
181 |             }
182 |             
183 |             if (setupFn) {
184 |                 const modelInfo = this.modelTypes['player'];
185 |                 const clips = modelInfo.clipNames.map(name => modelData[`${name}Clip`]);
186 |                 setupFn(model, ...clips);
187 |             }
188 | 
189 |             model.traverse(c => { c.castShadow = true; });
190 |             scene.add(model);
191 |             controls.playerModel = model;
192 |             controls.playerModel.userData.isGLB = true;
193 |             controls.currentAction = 'idle';
194 |             if (this.onPlayerModelReplaced) {
195 |                 this.onPlayerModelReplaced(model);
196 |             }
197 |         }
198 |     }
199 | }


--------------------------------------------------------------------------------
/js/buildTool.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { AIBuilder } from './aiBuilder.js';
  3 | import { LifespanExtender } from './lifespanExtender.js';
  4 | import { PreviewManager } from './previewManager.js';
  5 | 
  6 | export class BuildTool {
  7 |   constructor(scene, camera, controls, terrain) {
  8 |     this.scene = scene;
  9 |     this.camera = camera;
 10 |     this.controls = controls;
 11 |     this.terrain = terrain;
 12 |     this.enabled = false;
 13 |     this.lastTapTime = 0;
 14 |     this.buildMaterials = this.createBuildMaterials();
 15 |     this.buildObjects = [];
 16 |     this.mousePosition = new THREE.Vector2();
 17 |     this.touchStarted = false;
 18 |     this.room = null; // Will be set from app.js
 19 |     this.aiBuilding = false; // Track if AI is currently building
 20 |     this.extendingLifespan = false; // Track if lifespan extender is active
 21 | 
 22 |     this.previewManager = new PreviewManager(scene, camera, this.buildMaterials, this.terrain);
 23 |     this.aiBuilder = new AIBuilder(this);
 24 |     this.lifespanExtender = new LifespanExtender(scene, this);
 25 | 
 26 |     // Setup event listeners
 27 |     this.setupEventListeners();
 28 |   }
 29 | 
 30 |   createBuildMaterials() {
 31 |     return [
 32 |       new THREE.MeshStandardMaterial({ 
 33 |         color: 0xff4444, roughness: 0.7, metalness: 0.3
 34 |       }),
 35 |       new THREE.MeshStandardMaterial({ 
 36 |         color: 0x44ff44, roughness: 0.7, metalness: 0.3
 37 |       }),
 38 |       new THREE.MeshStandardMaterial({ 
 39 |         color: 0x4444ff, roughness: 0.7, metalness: 0.3
 40 |       }),
 41 |       new THREE.MeshStandardMaterial({ 
 42 |         color: 0xffff44, roughness: 0.7, metalness: 0.3
 43 |       }),
 44 |       new THREE.MeshStandardMaterial({ 
 45 |         color: 0xff44ff, roughness: 0.7, metalness: 0.3
 46 |       }),
 47 |       new THREE.MeshStandardMaterial({ 
 48 |         color: 0x44ffff, roughness: 0.7, metalness: 0.3
 49 |       })
 50 |     ];
 51 |   }
 52 | 
 53 |   setupEventListeners() {
 54 |     // Mouse events for desktop
 55 |     document.addEventListener('mousemove', this.onMouseMove.bind(this));
 56 |     document.addEventListener('click', this.onClick.bind(this));
 57 | 
 58 |     // Touch events for mobile
 59 |     document.addEventListener('touchstart', this.onTouchStart.bind(this));
 60 |     document.addEventListener('touchmove', this.onTouchMove.bind(this));
 61 |     document.addEventListener('touchend', this.onTouchEnd.bind(this));
 62 | 
 63 |     // Listen for shift+click for height adjustment
 64 |     document.addEventListener('mousedown', this.onMouseDown.bind(this));
 65 |   }
 66 | 
 67 |   onMouseMove(event) {
 68 |     if (!this.enabled) return;
 69 | 
 70 |     // Calculate mouse position in normalized device coordinates (-1 to +1)
 71 |     this.mousePosition.x = (event.clientX / window.innerWidth) * 2 - 1;
 72 |     this.mousePosition.y = - (event.clientY / window.innerHeight) * 2 + 1;
 73 | 
 74 |     this.previewManager.updatePosition(this.mousePosition, this.buildObjects);
 75 |   }
 76 | 
 77 |   onClick(event) {
 78 |     if (!this.enabled || this.aiBuilding) return;
 79 | 
 80 |     // Don't process clicks when advanced build tool is enabled
 81 |     if (document.getElementById('advanced-build-controls') && 
 82 |         document.getElementById('advanced-build-controls').style.display === 'flex') {
 83 |       return;
 84 |     }
 85 | 
 86 |     const now = performance.now();
 87 |     const timeSinceLastTap = now - this.lastTapTime;
 88 | 
 89 |     if (timeSinceLastTap < 300) { // Double click threshold (300ms)
 90 |       this.placeBuildObject();
 91 |     }
 92 | 
 93 |     this.lastTapTime = now;
 94 |   }
 95 | 
 96 |   onTouchStart(event) {
 97 |     if (!this.enabled || this.aiBuilding) return;
 98 | 
 99 |     // Don't process touches when advanced build tool is enabled
100 |     if (document.getElementById('advanced-build-controls') && 
101 |         document.getElementById('advanced-build-controls').style.display === 'flex') {
102 |       return;
103 |     }
104 | 
105 |     this.touchStarted = true;
106 |     const touch = event.touches[0];
107 | 
108 |     // Calculate touch position in normalized device coordinates (-1 to +1)
109 |     this.mousePosition.x = (touch.clientX / window.innerWidth) * 2 - 1;
110 |     this.mousePosition.y = - (touch.clientY / window.innerHeight) * 2 + 1;
111 | 
112 |     this.previewManager.updatePosition(this.mousePosition, this.buildObjects);
113 | 
114 |     const now = performance.now();
115 |     const timeSinceLastTap = now - this.lastTapTime;
116 | 
117 |     if (timeSinceLastTap < 300) { // Double tap threshold (300ms)
118 |       this.placeBuildObject();
119 |     }
120 | 
121 |     this.lastTapTime = now;
122 |   }
123 | 
124 |   onTouchMove(event) {
125 |     if (!this.enabled || !this.touchStarted) return;
126 | 
127 |     const touch = event.touches[0];
128 | 
129 |     // Calculate touch position in normalized device coordinates (-1 to +1)
130 |     this.mousePosition.x = (touch.clientX / window.innerWidth) * 2 - 1;
131 |     this.mousePosition.y = - (touch.clientY / window.innerHeight) * 2 + 1;
132 | 
133 |     this.previewManager.updatePosition(this.mousePosition, this.buildObjects);
134 |   }
135 | 
136 |   onTouchEnd() {
137 |     this.touchStarted = false;
138 |   }
139 | 
140 |   placeBuildObject() {
141 |     const previewMesh = this.previewManager.getMesh();
142 |     if (!previewMesh || !this.enabled) return;
143 | 
144 |     if (this.isLocationOccupiedByPlayer(previewMesh.position)) return;
145 | 
146 |     // Create a new object at the preview position
147 |     const buildGeometry = previewMesh.geometry.clone();
148 |     const materialIndex = this.previewManager.getCurrentMaterialIndex();
149 |     const buildMaterial = this.buildMaterials[materialIndex].clone();
150 |     const buildObject = new THREE.Mesh(buildGeometry, buildMaterial);
151 | 
152 |     buildObject.position.copy(previewMesh.position);
153 |     buildObject.scale.copy(previewMesh.scale);
154 |     buildObject.rotation.copy(previewMesh.rotation);
155 | 
156 |     buildObject.castShadow = true;
157 |     buildObject.receiveShadow = true;
158 |     buildObject.userData.isBarrier = true;
159 | 
160 |     // Generate a unique ID for this object
161 |     const objectId = 'build_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
162 |     buildObject.userData.id = objectId;
163 |     buildObject.userData.createdAt = Date.now(); // Store creation time
164 | 
165 |     this.scene.add(buildObject);
166 |     this.buildObjects.push(buildObject);
167 | 
168 |     // Sync build object with other players if room is available
169 |     if (this.room) {
170 |       // Get geometry type
171 |       const geometryType = previewMesh.userData.shapeName || buildObject.geometry.type;
172 | 
173 |       // Create build object data
174 |       const buildData = {
175 |         objectId: objectId,
176 |         position: {
177 |           x: buildObject.position.x,
178 |           y: buildObject.position.y,
179 |           z: buildObject.position.z
180 |         },
181 |         scale: {
182 |           x: buildObject.scale.x,
183 |           y: buildObject.scale.y,
184 |           z: buildObject.scale.z
185 |         },
186 |         rotation: {
187 |           x: buildObject.rotation.x,
188 |           y: buildObject.rotation.y,
189 |           z: buildObject.rotation.z
190 |         },
191 |         materialIndex: materialIndex,
192 |         geometryType: geometryType,
193 |         createdAt: Date.now() // Store creation time
194 |       };
195 | 
196 |       // Send to current players
197 |       this.room.send({
198 |         type: 'build_object',
199 |         ...buildData
200 |       });
201 | 
202 |       // Store in room state for future players
203 |       const updatedBuildObjects = { ...(this.room.roomState.buildObjects || {}) };
204 |       updatedBuildObjects[objectId] = buildData;
205 |       this.room.updateRoomState({
206 |         buildObjects: updatedBuildObjects
207 |       });
208 |     }
209 |   }
210 | 
211 |   // Method to handle receiving build objects from other players
212 |   receiveBuildObject(buildData) {
213 |     if (!buildData) return;
214 | 
215 |     // Check if object already exists (by ID)
216 |     const existingObject = this.buildObjects.find(obj => 
217 |       obj.userData.id === buildData.objectId
218 |     );
219 | 
220 |     if (existingObject) return; // Skip if already exists
221 | 
222 |     // Create appropriate geometry based on type
223 |     let geometry;
224 |     switch (buildData.geometryType) {
225 |       case 'BoxGeometry':
226 |         geometry = new THREE.BoxGeometry(1, 1, 1);
227 |         break;
228 |       case 'SphereGeometry':
229 |         geometry = new THREE.SphereGeometry(0.5, 16, 16);
230 |         break;
231 |       case 'CylinderGeometry':
232 |         geometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 16);
233 |         break;
234 |       case 'ConeGeometry':
235 |         geometry = new THREE.ConeGeometry(0.5, 1, 16);
236 |         break;
237 |       case 'TorusGeometry':
238 |         geometry = new THREE.TorusGeometry(0.5, 0.2, 16, 32);
239 |         break;
240 |       case 'Pyramid':
241 |         geometry = new THREE.ConeGeometry(0.5, 1, 4);
242 |         break;
243 |       default:
244 |         geometry = new THREE.BoxGeometry(1, 1, 1);
245 |     }
246 | 
247 |     // Create material
248 |     const materialIndex = Math.min(
249 |       buildData.materialIndex || 0,
250 |       this.buildMaterials.length - 1
251 |     );
252 |     const material = this.buildMaterials[materialIndex].clone();
253 | 
254 |     // Create mesh
255 |     const buildObject = new THREE.Mesh(geometry, material);
256 |     buildObject.position.set(
257 |       buildData.position.x,
258 |       buildData.position.y,
259 |       buildData.position.z
260 |     );
261 | 
262 |     if (this.isLocationOccupiedByPlayer(buildObject.position)) return;
263 |     buildObject.scale.set(
264 |       buildData.scale.x,
265 |       buildData.scale.y,
266 |       buildData.scale.z
267 |     );
268 |     buildObject.rotation.set(
269 |       buildData.rotation.x,
270 |       buildData.rotation.y,
271 |       buildData.rotation.z
272 |     );
273 | 
274 |     buildObject.castShadow = true;
275 |     buildObject.receiveShadow = true;
276 |     buildObject.userData.isBarrier = true;
277 |     buildObject.userData.id = buildData.objectId;
278 |     buildObject.userData.createdAt = buildData.createdAt || Date.now(); // Use provided time or current time
279 | 
280 |     this.scene.add(buildObject);
281 |     this.buildObjects.push(buildObject);
282 |   }
283 | 
284 |   // Set the room for multiplayer build syncing
285 |   setRoom(room) {
286 |     this.room = room;
287 |   }
288 | 
289 |   isLocationOccupiedByPlayer(position, radius = 1) {
290 |     let occupied = false;
291 |     this.scene.traverse((obj) => {
292 |       if (obj.userData && obj.userData.isPlayer) {
293 |         const playerPos = new THREE.Vector3();
294 |         obj.getWorldPosition(playerPos);
295 |         if (playerPos.distanceTo(position) < radius) occupied = true;
296 |       }
297 |     });
298 |     return occupied;
299 |   }
300 | 
301 |   toggleBuildMode() {
302 |     this.enabled = !this.enabled;
303 | 
304 |     if (this.enabled) {
305 |       this.previewManager.show();
306 | 
307 |       // Create height indicator
308 |       if (!document.getElementById('height-indicator')) {
309 |         const heightIndicator = document.createElement('div');
310 |         heightIndicator.id = 'height-indicator';
311 |         heightIndicator.textContent = `Height: ${this.previewManager.currentHeight.toFixed(1)}`;
312 |         document.getElementById('game-container').appendChild(heightIndicator);
313 |       }
314 |       document.getElementById('height-indicator').style.display = 'block';
315 | 
316 |       // Reset lifespan extender mode
317 |       this.extendingLifespan = false;
318 | 
319 |     } else {
320 |       this.previewManager.hide();
321 |       if (document.getElementById('height-indicator')) {
322 |         document.getElementById('height-indicator').style.display = 'none';
323 |       }
324 | 
325 |       // Reset lifespan extender mode when exiting build mode
326 |       if (this.extendingLifespan) {
327 |         this.extendingLifespan = false;
328 |         this.hideLifespanNotification();
329 | 
330 |         // Reset the button if it exists and has the active class
331 |         const extenderButton = document.getElementById('lifespan-extender-button');
332 |         if (extenderButton) {
333 |           extenderButton.classList.remove('active');
334 |         }
335 |       }
336 |     }
337 | 
338 |     return this.enabled;
339 |   }
340 | 
341 |   changeShape() {
342 |     this.previewManager.changeShape();
343 |   }
344 | 
345 |   changeMaterial() {
346 |     this.previewManager.changeMaterial();
347 |   }
348 | 
349 |   changeSize() {
350 |     this.previewManager.changeSize();
351 |   }
352 | 
353 |   rotatePreview() {
354 |     this.previewManager.rotate();
355 |   }
356 | 
357 |   undoLastObject() {
358 |     if (this.buildObjects.length === 0) return;
359 |     const lastObject = this.buildObjects.pop();
360 |     this.scene.remove(lastObject);
361 |     if (this.room && this.room.roomState.buildObjects && lastObject.userData.id) {
362 |       const updatedBuildObjects = { ...(this.room.roomState.buildObjects) };
363 |       delete updatedBuildObjects[lastObject.userData.id];
364 |       this.room.updateRoomState({
365 |         buildObjects: updatedBuildObjects
366 |       });
367 |       this.room.send({
368 |         type: 'delete_build_object',
369 |         objectId: lastObject.userData.id
370 |       });
371 |     }
372 |   }
373 | 
374 |   onMouseDown(event) {
375 |     if (!this.enabled || !this.previewManager.getMesh()) return;
376 | 
377 |     // Check if shift key is pressed
378 |     if (event.shiftKey) {
379 |       let newHeight;
380 |       if (event.button === 0) { // Left click
381 |         // Increase height
382 |         newHeight = this.previewManager.adjustHeight(0.5);
383 |       } else if (event.button === 2) { // Right click
384 |         // Decrease height
385 |         newHeight = this.previewManager.adjustHeight(-0.5);
386 |       }
387 | 
388 |       // Update height indicator
389 |       const heightIndicator = document.getElementById('height-indicator');
390 |       if (heightIndicator) {
391 |         heightIndicator.textContent = `Height: ${newHeight.toFixed(1)}`;
392 |       }
393 | 
394 |       event.preventDefault();
395 |     }
396 |   }
397 | 
398 |   checkExpiredObjects(currentTime, expirationTime) {
399 |     const objectsToRemove = [];
400 | 
401 |     // Check each build object
402 |     for (let i = 0; i < this.buildObjects.length; i++) {
403 |       const object = this.buildObjects[i];
404 |       if (object.userData.createdAt && !object.userData.extendedUntil && 
405 |           (currentTime - object.userData.createdAt > expirationTime)) {
406 |         objectsToRemove.push(object);
407 |       } else if (object.userData.extendedUntil && currentTime > object.userData.extendedUntil) {
408 |         // For objects with extended lifespan, check if extension has expired
409 |         objectsToRemove.push(object);
410 |       }
411 |     }
412 | 
413 |     // Remove expired objects
414 |     for (const object of objectsToRemove) {
415 |       // Remove from scene
416 |       this.scene.remove(object);
417 | 
418 |       // Remove from build objects array
419 |       const index = this.buildObjects.indexOf(object);
420 |       if (index !== -1) {
421 |         this.buildObjects.splice(index, 1);
422 |       }
423 | 
424 |       // Remove from room state if available
425 |       if (this.room && this.room.roomState.buildObjects && object.userData.id) {
426 |         const updatedBuildObjects = { ...(this.room.roomState.buildObjects) };
427 |         delete updatedBuildObjects[object.userData.id];
428 |         this.room.updateRoomState({
429 |           buildObjects: updatedBuildObjects
430 |         });
431 |       }
432 |     }
433 | 
434 |     if (objectsToRemove.length > 0) {
435 |       console.log(`Removed ${objectsToRemove.length} expired build objects`);
436 |     }
437 |   }
438 | 
439 |   // AI-powered building generation
440 |   aiGenerateStructure(prompt) {
441 |     this.aiBuilder.generateStructure(prompt);
442 |   }
443 | 
444 |   toggleLifespanExtender() {
445 |     this.extendingLifespan = this.lifespanExtender.toggle();
446 | 
447 |     if (this.extendingLifespan) {
448 |       this.previewManager.hide();
449 |     } else {
450 |       if (this.enabled) {
451 |         this.previewManager.show();
452 |       }
453 |     }
454 | 
455 |     return this.extendingLifespan;
456 |   }
457 | 
458 |   extendObjectLifespans(playerPosition) {
459 |     if (!this.extendingLifespan) return;
460 |     this.lifespanExtender.extendObjects(playerPosition, this.buildObjects);
461 |   }
462 | 
463 |   showExtensionEffect(position) {
464 |     this.lifespanExtender.showExtensionEffect(position);
465 |   }
466 | 
467 |   showLifespanNotification(message, isComplete = false) {
468 |     this.lifespanExtender.showNotification(message, isComplete);
469 |   }
470 | 
471 |   hideLifespanNotification() {
472 |     this.lifespanExtender.hideNotification();
473 |   }
474 | 
475 |   receiveLifespanExtension(extensionData) {
476 |     const object = this.buildObjects.find(obj => obj.userData.id === extensionData.objectId);
477 |     if (object) {
478 |       this.lifespanExtender.receiveExtension(object, extensionData);
479 |     }
480 |   }
481 | }


--------------------------------------------------------------------------------
/js/characterCreator.js:
--------------------------------------------------------------------------------
  1 | import { createPlayerModel } from "./playerModel.js";
  2 | import { presetCharacters } from "./characters/presets.js";
  3 | 
  4 | export class CharacterCreator {
  5 |     constructor(THREE, room, playerControls, onApplyCharacter) {
  6 |         this.THREE = THREE;
  7 |         this.room = room;
  8 |         this.playerControls = playerControls;
  9 |         this.onApplyCharacter = onApplyCharacter;
 10 | 
 11 |         this.characterCollection = this.room.collection('characters');
 12 |         this.modal = null;
 13 |         this.previewContainer = null;
 14 |         this.statusEl = null;
 15 |         this.descriptionInput = null;
 16 | 
 17 |         this.previewScene = null;
 18 |         this.previewCamera = null;
 19 |         this.previewRenderer = null;
 20 |         this.previewModel = null;
 21 |         this.previewAnimationId = null;
 22 | 
 23 |         this.currentCharacterDescription = "";
 24 |         window.tempCharacterSpec = null;
 25 |         window.referenceImageUrl = null;
 26 |     }
 27 | 
 28 |     open() {
 29 |         this.modal = document.getElementById('character-creator-modal');
 30 |         this.previewContainer = document.getElementById('character-preview');
 31 |         this.statusEl = document.getElementById('character-status');
 32 |         this.descriptionInput = document.getElementById('character-description');
 33 | 
 34 |         if (!this.modal) {
 35 |             console.error("Character creator modal not found in DOM!");
 36 |             return;
 37 |         }
 38 | 
 39 |         this.modal.style.display = 'block';
 40 |         this.descriptionInput.value = this.currentCharacterDescription;
 41 | 
 42 |         document.getElementById('reference-preview').innerHTML = '';
 43 |         document.getElementById('reference-image').value = '';
 44 |         window.referenceImageUrl = null;
 45 | 
 46 |         if (this.playerControls) {
 47 |             this.playerControls.enabled = false;
 48 |         }
 49 | 
 50 |         this.setupPreviewRenderer();
 51 |         this.populatePresetCharacters();
 52 |         this.loadCommunityCharacters();
 53 |     }
 54 | 
 55 |     close() {
 56 |         if (!this.modal) return;
 57 |         this.modal.style.display = 'none';
 58 |         this.stopPreviewAnimation();
 59 |         if (this.playerControls) {
 60 |             this.playerControls.enabled = true;
 61 |         }
 62 |     }
 63 | 
 64 |     setupPreviewRenderer() {
 65 |         this.previewContainer.innerHTML = '';
 66 |         this.previewScene = new this.THREE.Scene();
 67 |         this.previewScene.background = new this.THREE.Color(0x333333);
 68 | 
 69 |         this.previewCamera = new this.THREE.PerspectiveCamera(50, 2, 0.1, 1000);
 70 |         this.previewCamera.position.set(0, 1, 3);
 71 |         this.previewCamera.lookAt(0, 0.5, 0);
 72 | 
 73 |         this.previewRenderer = new this.THREE.WebGLRenderer({ antialias: true });
 74 |         this.previewRenderer.setSize(this.previewContainer.clientWidth, 150);
 75 |         this.previewRenderer.shadowMap.enabled = true;
 76 |         this.previewContainer.appendChild(this.previewRenderer.domElement);
 77 | 
 78 |         const ambLight = new this.THREE.AmbientLight(0xffffff, 0.5);
 79 |         this.previewScene.add(ambLight);
 80 |         const dirLight = new this.THREE.DirectionalLight(0xffffff, 1);
 81 |         dirLight.position.set(5, 5, 5);
 82 |         this.previewScene.add(dirLight);
 83 |         
 84 |         const grid = new this.THREE.GridHelper(4, 4);
 85 |         this.previewScene.add(grid);
 86 |     }
 87 | 
 88 |     animatePreview() {
 89 |         if (!this.previewScene || !this.previewCamera || !this.previewRenderer) return;
 90 | 
 91 |         const time = performance.now() * 0.001;
 92 |         this.previewAnimationId = requestAnimationFrame(this.animatePreview.bind(this));
 93 | 
 94 |         if (this.previewModel) {
 95 |             this.previewModel.rotation.y += 0.01;
 96 |             if (this.previewModel.userData.updateAnimations) {
 97 |                 this.previewModel.userData.updateAnimations(time);
 98 |             }
 99 |         }
100 |         this.previewRenderer.render(this.previewScene, this.previewCamera);
101 |     }
102 | 
103 |     stopPreviewAnimation() {
104 |         if (this.previewAnimationId !== null) {
105 |             cancelAnimationFrame(this.previewAnimationId);
106 |             this.previewAnimationId = null;
107 |         }
108 |     }
109 | 
110 |     updatePreviewModel(characterSpec) {
111 |         if (this.previewModel) {
112 |             this.previewScene.remove(this.previewModel);
113 |         }
114 |         this.previewModel = createPlayerModel(this.THREE, "preview", characterSpec);
115 |         this.previewModel.position.set(0, 0, 0);
116 |         this.previewScene.add(this.previewModel);
117 | 
118 |         if (this.previewAnimationId === null) {
119 |             this.animatePreview();
120 |         }
121 |     }
122 |     
123 |     async handleReferenceImageUpload(event) {
124 |         const file = event.target.files[0];
125 |         if (!file || !file.type.startsWith('image/')) return;
126 | 
127 |         const previewDiv = document.getElementById('reference-preview');
128 |         previewDiv.innerHTML = '<p>Uploading image...</p>';
129 | 
130 |         try {
131 |             const imageUrl = await websim.upload(file);
132 |             previewDiv.innerHTML = `
133 |                 <img src="${imageUrl}" alt="Reference" id="reference-image-preview">
134 |                 <button id="remove-reference-image">Remove</button>
135 |             `;
136 |             window.referenceImageUrl = imageUrl;
137 | 
138 |             document.getElementById('remove-reference-image').addEventListener('click', () => {
139 |                 previewDiv.innerHTML = ''; window.referenceImageUrl = null; document.getElementById('reference-image').value = '';
140 |             });
141 | 
142 |         } catch (error) {
143 |             console.error('Error uploading image:', error);
144 |             previewDiv.innerHTML = '<p>Error uploading image. Please try again.</p>';
145 |         }
146 |     }
147 | 
148 |     async generateCharacter() {
149 |         const description = this.descriptionInput.value.trim();
150 |         if (description.length < 3) {
151 |             this.statusEl.textContent = 'Please enter a longer description';
152 |             return;
153 |         }
154 | 
155 |         this.statusEl.textContent = 'Generating your character...';
156 |         document.getElementById('generate-character-button').disabled = true;
157 | 
158 |         try {
159 |             // System prompt for AI character generation.
160 |             // Encourages humanoid proportions when appropriate and uses
161 |             // individual primitives for head, torso and limbs.
162 |             // All shapes must stay within a 3x3x3 area for consistent collision.
163 |             const messages = [{
164 |                 role: "system",
165 |                 content: `Convert the user's character description into a structured 3D character model description.
166 |                 The model should reflect what they describe. When a humanoid form is implied, keep roughly human proportions and use separate primitives for the head, torso and each limb.
167 |                 SIZE CONSTRAINT: No dimension should exceed 3x3 units. Keep all features within a 3x3x3 cube for more detailed shapes.
168 |                 Respond with ONLY JSON, following this schema:
169 |                 {
170 |                   "customMode": true,
171 |                   "features": [
172 |                     {
173 |                       "type": "box|sphere|cylinder|cone|torus", 
174 |                       "color": "hexcolor",
175 |                       "position": {"x": number, "y": number, "z": number},
176 |                       "scale": {"x": number, "y": number, "z": number},
177 |                       "rotation": {"x": number, "y": number, "z": number},
178 |                       "roughness": number, "metalness": number, "transparent": boolean, "opacity": number,
179 |                       "name": "string",
180 |                       "texture": { "id": "brick|wood|skin|metal|water|glass", "textureUrl": "url" },
181 |                       "animation": { "type": "jiggly|bobUpDown|spinY|spinX|spinZ|pulse" }
182 |                     }
183 |                   ],
184 |                   "description": "brief description of the character"
185 |                 }
186 |                 Create a fully custom design using multiple primitive shapes.
187 |                 Place at least one feature near Y=0 as the 'base' for proper collision.
188 |                 IMPORTANT: Keep all shapes within a 3x3x3 area centered on the character.
189 |                 Use textures and colors that closely match the description for realism.
190 |                 If legs should animate, name them "leftLeg" and "rightLeg".
191 |                 CRITICAL: Ensure at least one component extends to Y=0 or below for ground anchor.
192 |                 Be creative and interpret the user's description freely while respecting size constraints.`
193 |             }];
194 | 
195 |             const userMessage = { role: "user", content: [] };
196 |             userMessage.content.push({ type: "text", text: description });
197 |             if (window.referenceImageUrl) {
198 |                 userMessage.content.push({ type: "image_url", image_url: { url: window.referenceImageUrl } });
199 |             }
200 |             messages.push(userMessage);
201 | 
202 |             const completion = await websim.chat.completions.create({ messages, json: true });
203 |             const characterSpec = JSON.parse(completion.content);
204 | 
205 |             this.currentCharacterDescription = description;
206 |             this.updatePreviewModel(characterSpec);
207 |             this.statusEl.textContent = 'Ready to apply!';
208 |             document.getElementById('apply-character-button').style.display = 'block';
209 |             window.tempCharacterSpec = characterSpec;
210 |         } catch (error) {
211 |             console.error('Error generating character:', error);
212 |             this.statusEl.textContent = 'Error generating character. Please try again.';
213 |         } finally {
214 |             document.getElementById('generate-character-button').disabled = false;
215 |         }
216 |     }
217 | 
218 |     async applyAndSaveCharacter() {
219 |         if (!window.tempCharacterSpec) {
220 |             this.statusEl.textContent = 'Please generate a character first';
221 |             return;
222 |         }
223 | 
224 |         try {
225 |             const playerModel = this.onApplyCharacter(window.tempCharacterSpec);
226 |             
227 |             await this.characterCollection.create({
228 |                 description: this.currentCharacterDescription,
229 |                 spec: window.tempCharacterSpec,
230 |                 creator: this.room.peers[this.room.clientId]?.username || 'player',
231 |                 referenceImage: window.referenceImageUrl || null
232 |             });
233 | 
234 |             this.room.updatePresence({
235 |                 characterSpec: window.tempCharacterSpec
236 |             });
237 | 
238 |             this.statusEl.textContent = 'Character applied and saved!';
239 |             await this.loadCommunityCharacters();
240 |             setTimeout(() => this.close(), 1500);
241 |         } catch (error) {
242 |             console.error('Error applying character:', error);
243 |             this.statusEl.textContent = 'Error saving character. Please try again.';
244 |         }
245 |     }
246 | 
247 |     loadCommunityCharacters() {
248 |         const gallery = document.getElementById('character-gallery');
249 |         gallery.innerHTML = '';
250 |         const characters = this.characterCollection.getList();
251 | 
252 |         if (characters.length === 0) {
253 |             gallery.innerHTML = '<div style="grid-column: 1/-1; text-align: center;">No characters yet. Be the first!</div>';
254 |             return;
255 |         }
256 |         
257 |         characters.forEach(character => {
258 |             const charEl = document.createElement('div');
259 |             charEl.className = 'character-option';
260 |             
261 |             if (character.referenceImage) {
262 |                 charEl.innerHTML = `
263 |                     <div class="character-thumbnail"><img src="${character.referenceImage}" alt="Ref"></div>
264 |                     <div class="character-name">${character.description.slice(0, 15) + (character.description.length > 15 ? '...' : '')}</div>
265 |                 `;
266 |             } else {
267 |                 charEl.textContent = character.description.slice(0, 30) + (character.description.length > 30 ? '...' : '');
268 |             }
269 |             charEl.title = `${character.description} (by ${character.username})`;
270 | 
271 |             charEl.addEventListener('click', () => {
272 |                 document.querySelectorAll('.character-option').forEach(el => el.classList.remove('selected'));
273 |                 charEl.classList.add('selected');
274 |                 this.descriptionInput.value = character.description;
275 |                 this.updatePreviewModel(character.spec);
276 |                 window.tempCharacterSpec = character.spec;
277 |                 
278 |                 const previewDiv = document.getElementById('reference-preview');
279 |                 if (character.referenceImage) {
280 |                     previewDiv.innerHTML = `<img src="${character.referenceImage}" id="reference-image-preview"><button id="remove-reference-image">Remove</button>`;
281 |                     window.referenceImageUrl = character.referenceImage;
282 |                     document.getElementById('remove-reference-image').addEventListener('click', () => {
283 |                         previewDiv.innerHTML = ''; window.referenceImageUrl = null; document.getElementById('reference-image').value = '';
284 |                     });
285 |                 } else {
286 |                     previewDiv.innerHTML = ''; window.referenceImageUrl = null;
287 |                 }
288 |                 document.getElementById('apply-character-button').style.display = 'block';
289 |             });
290 |             gallery.appendChild(charEl);
291 |         });
292 |     }
293 | 
294 |     populatePresetCharacters() {
295 |         const gallery = document.getElementById('preset-gallery');
296 |         gallery.innerHTML = '';
297 |         presetCharacters.forEach(preset => {
298 |             const presetEl = document.createElement('div');
299 |             presetEl.className = 'character-option';
300 |             presetEl.textContent = preset.name;
301 |             presetEl.title = preset.description;
302 |             presetEl.addEventListener('click', () => {
303 |                 document.querySelectorAll('.character-option').forEach(el => el.classList.remove('selected'));
304 |                 presetEl.classList.add('selected');
305 |                 this.descriptionInput.value = preset.description;
306 |                 this.updatePreviewModel(preset.spec);
307 |                 window.tempCharacterSpec = preset.spec;
308 |                 document.getElementById('apply-character-button').style.display = 'block';
309 |                 this.statusEl.textContent = 'Preset character selected!';
310 |             });
311 |             gallery.appendChild(presetEl);
312 |         });
313 |     }
314 | }


--------------------------------------------------------------------------------
/js/characters/animations.js:
--------------------------------------------------------------------------------
 1 | // Available animation properties for AI character creator
 2 | export const availableAnimations = [
 3 |   {
 4 |     id: "jiggly",
 5 |     name: "Jiggly",
 6 |     description: "Makes the feature jiggle randomly"
 7 |   },
 8 |   {
 9 |     id: "bobUpDown",
10 |     name: "Bob Up & Down",
11 |     description: "Makes the feature move up and down smoothly"
12 |   },
13 |   {
14 |     id: "spinY",
15 |     name: "Spin Y",
16 |     description: "Rotates the feature around the Y axis"
17 |   },
18 |   {
19 |     id: "spinX",
20 |     name: "Spin X",
21 |     description: "Rotates the feature around the X axis"
22 |   },
23 |   {
24 |     id: "spinZ",
25 |     name: "Spin Z",
26 |     description: "Rotates the feature around the Z axis"
27 |   },
28 |   {
29 |     id: "pulse",
30 |     name: "Pulse",
31 |     description: "Makes the feature grow and shrink"
32 |   }
33 | ];


--------------------------------------------------------------------------------
/js/characters/presets.js:
--------------------------------------------------------------------------------
  1 | // Preset character collection
  2 | export const presetCharacters = [
  3 |   {
  4 |     id: "robots",
  5 |     name: "Robots",
  6 |     description: "A walking robot.",
  7 |     spec: {
  8 |       customMode: true,
  9 |       features: [
 10 |         {
 11 |           type: "box",
 12 |           /* @tweakable Color of the robot's base */
 13 |           color: "#777777",
 14 |           position: { x: 0, y: 0.5, z: 0 },
 15 |           scale: { x: 1.2, y: 1, z: 1.2 },
 16 |           roughness: 0.8,
 17 |           metalness: 0.5,
 18 |           name: "base"
 19 |         },
 20 |         // Vertical bars
 21 |         {
 22 |           type: "cylinder",
 23 |           /* @tweakable Color of the robot's frame bars */
 24 |           color: "#333333",
 25 |           position: { x: -0.5, y: 0.5, z: -0.5 },
 26 |           scale: { x: 0.1, y: 2, z: 0.1 },
 27 |           roughness: 0.5,
 28 |           metalness: 0.8
 29 |         },
 30 |         {
 31 |           type: "cylinder",
 32 |           color: "#333333",
 33 |           position: { x: 0.5, y: 0.5, z: -0.5 },
 34 |           scale: { x: 0.1, y: 2, z: 0.1 },
 35 |           roughness: 0.5,
 36 |           metalness: 0.8
 37 |         },
 38 |         {
 39 |           type: "cylinder",
 40 |           color: "#333333",
 41 |           position: { x: -0.5, y: 0.5, z: 0.5 },
 42 |           scale: { x: 0.1, y: 2, z: 0.1 },
 43 |           roughness: 0.5,
 44 |           metalness: 0.8
 45 |         },
 46 |         {
 47 |           type: "cylinder",
 48 |           color: "#333333",
 49 |           position: { x: 0.5, y: 0.5, z: 0.5 },
 50 |           scale: { x: 0.1, y: 2, z: 0.1 },
 51 |           roughness: 0.5,
 52 |           metalness: 0.8
 53 |         },
 54 |         // Horizontal bars
 55 |         {
 56 |           type: "cylinder",
 57 |           color: "#333333",
 58 |           position: { x: 0, y: 0, z: -0.5 },
 59 |           scale: { x: 0.1, y: 1, z: 0.1 },
 60 |           rotation: { x: 0, y: 0, z: Math.PI/2 },
 61 |           roughness: 0.5,
 62 |           metalness: 0.8
 63 |         },
 64 |         {
 65 |           type: "cylinder",
 66 |           color: "#333333",
 67 |           position: { x: 0, y: 1, z: -0.5 },
 68 |           scale: { x: 0.1, y: 1, z: 0.1 },
 69 |           rotation: { x: 0, y: 0, z: Math.PI/2 },
 70 |           roughness: 0.5,
 71 |           metalness: 0.8
 72 |         },
 73 |         // Legs that will animate
 74 |         {
 75 |           type: "cylinder",
 76 |           /* @tweakable Color of the robot's legs */
 77 |           color: "#555555",
 78 |           position: { x: -0.3, y: 0, z: 0 },
 79 |           scale: { x: 0.1, y: 0.5, z: 0.1 },
 80 |           roughness: 0.7,
 81 |           metalness: 0.6,
 82 |           name: "leftLeg"
 83 |         },
 84 |         {
 85 |           type: "cylinder",
 86 |           color: "#555555",
 87 |           position: { x: 0.3, y: 0, z: 0 },
 88 |           scale: { x: 0.1, y: 0.5, z: 0.1 },
 89 |           roughness: 0.7,
 90 |           metalness: 0.6,
 91 |           name: "rightLeg"
 92 |         }
 93 |       ],
 94 |       description: "A walking robot with metallic parts"
 95 |     }
 96 |   },
 97 |   {
 98 |     id: "chicken",
 99 |     name: "Chicken",
100 |     description: "A cartoonish chicken",
101 |     spec: {
102 |       customMode: true,
103 |       features: [
104 |         // Body
105 |         {
106 |           type: "sphere",
107 |           /* @tweakable Color of the chicken's body */
108 |           color: "#ffffff",
109 |           position: { x: 0, y: 0.5, z: 0 },
110 |           scale: { x: 0.8, y: 0.6, z: 1 },
111 |           roughness: 0.9,
112 |           metalness: 0
113 |         },
114 |         // Head
115 |         {
116 |           type: "sphere",
117 |           color: "#ffffff",
118 |           position: { x: 0, y: 0.9, z: 0.5 },
119 |           scale: { x: 0.5, y: 0.5, z: 0.5 },
120 |           roughness: 0.9,
121 |           metalness: 0
122 |         },
123 |         // Beak
124 |         {
125 |           type: "cone",
126 |           /* @tweakable Color of the chicken's beak */
127 |           color: "#ffa500",
128 |           position: { x: 0, y: 0.85, z: 0.9 },
129 |           scale: { x: 0.15, y: 0.4, z: 0.15 },
130 |           rotation: { x: -Math.PI/2, y: 0, z: 0 },
131 |           roughness: 0.7,
132 |           metalness: 0
133 |         },
134 |         // Eyes
135 |         {
136 |           type: "sphere",
137 |           color: "#000000",
138 |           position: { x: -0.15, y: 1, z: 0.7 },
139 |           scale: { x: 0.08, y: 0.08, z: 0.08 },
140 |           roughness: 0.5,
141 |           metalness: 0
142 |         },
143 |         {
144 |           type: "sphere",
145 |           color: "#000000",
146 |           position: { x: 0.15, y: 1, z: 0.7 },
147 |           scale: { x: 0.08, y: 0.08, z: 0.08 },
148 |           roughness: 0.5,
149 |           metalness: 0
150 |         },
151 |         // Wings
152 |         {
153 |           type: "box",
154 |           /* @tweakable Color of the chicken's wings */
155 |           color: "#eeeeee",
156 |           position: { x: -0.7, y: 0.5, z: 0 },
157 |           scale: { x: 0.8, y: 0.1, z: 0.6 },
158 |           rotation: { x: 0, y: 0, z: -0.3 },
159 |           roughness: 0.9,
160 |           metalness: 0
161 |         },
162 |         {
163 |           type: "box",
164 |           color: "#eeeeee",
165 |           position: { x: 0.7, y: 0.5, z: 0 },
166 |           scale: { x: 0.8, y: 0.1, z: 0.6 },
167 |           rotation: { x: 0, y: 0, z: 0.3 },
168 |           roughness: 0.9,
169 |           metalness: 0
170 |         },
171 |         // Legs
172 |         {
173 |           type: "cylinder",
174 |           color: "#ffa500",
175 |           position: { x: -0.2, y: 0, z: 0 },
176 |           scale: { x: 0.08, y: 0.4, z: 0.08 },
177 |           roughness: 0.7,
178 |           metalness: 0,
179 |           name: "leftLeg"
180 |         },
181 |         {
182 |           type: "cylinder",
183 |           color: "#ffa500",
184 |           position: { x: 0.2, y: 0, z: 0 },
185 |           scale: { x: 0.08, y: 0.4, z: 0.08 },
186 |           roughness: 0.7,
187 |           metalness: 0,
188 |           name: "rightLeg"
189 |         },
190 |         // Tail
191 |         {
192 |           type: "box",
193 |           color: "#eeeeee",
194 |           position: { x: 0, y: 0.5, z: -0.6 },
195 |           scale: { x: 0.4, y: 0.1, z: 0.3 },
196 |           roughness: 0.9,
197 |           metalness: 0
198 |         }
199 |       ],
200 |       description: "A cartoonish chicken with animated legs"
201 |     }
202 |   },
203 |   {
204 |     id: "eyebot",
205 |     name: "Eyebot",
206 |     description: "A walking eyebot character.",
207 |     spec: {
208 |       customMode: true,
209 |       features: [
210 |         // Eyebot Eye
211 |         {
212 |           type: "sphere",
213 |           /* @tweakable Color of the eyebot's sclera */
214 |           color: "#ffffff",
215 |           position: { x: 0, y: 1.5, z: 0 },
216 |           scale: { x: 0.5, y: 0.5, z: 0.5 },
217 |           roughness: 0.2,
218 |           metalness: 0.1,
219 |         },
220 |         // Eyebot Pupil
221 |         {
222 |           type: "sphere",
223 |           /* @tweakable Color of the eyebot's pupil */
224 |           color: "#000000",
225 |           position: { x: 0, y: 1.5, z: 0.2 },
226 |           scale: { x: 0.2, y: 0.2, z: 0.1 },
227 |           roughness: 0.1,
228 |           metalness: 0.1,
229 |         },
230 |         // Eyebot body
231 |         {
232 |           type: "box",
233 |           /* @tweakable Color of the eyebot's body */
234 |           color: "#cccccc",
235 |           position: { x: 0, y: 0.9, z: 0 },
236 |           scale: { x: 0.6, y: 0.8, z: 0.3 },
237 |           roughness: 0.2,
238 |           metalness: 0.8,
239 |         },
240 |         // Arms
241 |         {
242 |           type: "cylinder",
243 |           /* @tweakable Color of the eyebot's arms */
244 |           color: "#aaaaaa",
245 |           position: { x: -0.5, y: 1, z: 0 },
246 |           scale: { x: 0.1, y: 0.6, z: 0.1 },
247 |           rotation: { x: 0, y: 0, z: Math.PI/2 },
248 |           roughness: 0.2,
249 |           metalness: 0.8,
250 |         },
251 |         {
252 |           type: "cylinder",
253 |           color: "#aaaaaa",
254 |           position: { x: 0.5, y: 1, z: 0 },
255 |           scale: { x: 0.1, y: 0.6, z: 0.1 },
256 |           rotation: { x: 0, y: 0, z: Math.PI/2 },
257 |           roughness: 0.2,
258 |           metalness: 0.8,
259 |         },
260 |         // Legs
261 |         {
262 |           type: "cylinder",
263 |           /* @tweakable Color of the eyebot's legs */
264 |           color: "#888888",
265 |           position: { x: -0.2, y: 0.2, z: 0 },
266 |           scale: { x: 0.1, y: 0.8, z: 0.1 },
267 |           roughness: 0.2,
268 |           metalness: 0.8,
269 |           name: "leftLeg"
270 |         },
271 |         {
272 |           type: "cylinder",
273 |           color: "#888888",
274 |           position: { x: 0.2, y: 0.2, z: 0 },
275 |           scale: { x: 0.1, y: 0.8, z: 0.1 },
276 |           roughness: 0.2,
277 |           metalness: 0.8,
278 |           name: "rightLeg"
279 |         },
280 |         // Base for collision
281 |         {
282 |           type: "box",
283 |           color: "#666666",
284 |           position: { x: 0, y: 0, z: 0 },
285 |           scale: { x: 0.5, y: 0.1, z: 0.3 },
286 |           roughness: 0.2,
287 |           metalness: 0.8,
288 |         }
289 |       ],
290 |       description: "A metallic eyebot character."
291 |     }
292 |   },
293 |   {
294 |     id: "wireframe",
295 |     name: "Wireframe",
296 |     description: "A walking wireframe character",
297 |     spec: {
298 |       customMode: true,
299 |       features: [
300 |         // Wireframe head
301 |         {
302 |           type: "sphere",
303 |           /* @tweakable Color of the wireframe character */
304 |           color: "#00ff00",
305 |           position: { x: 0, y: 1.5, z: 0 },
306 |           scale: { x: 0.5, y: 0.5, z: 0.5 },
307 |           roughness: 0.2,
308 |           metalness: 0.8,
309 |           transparent: true,
310 |           opacity: 0.8
311 |         },
312 |         // Wireframe body
313 |         {
314 |           type: "box",
315 |           color: "#00ff00",
316 |           position: { x: 0, y: 0.9, z: 0 },
317 |           scale: { x: 0.6, y: 0.8, z: 0.3 },
318 |           roughness: 0.2,
319 |           metalness: 0.8,
320 |           transparent: true,
321 |           opacity: 0.8
322 |         },
323 |         // Arms
324 |         {
325 |           type: "cylinder",
326 |           color: "#00ff00",
327 |           position: { x: -0.5, y: 1, z: 0 },
328 |           scale: { x: 0.1, y: 0.6, z: 0.1 },
329 |           rotation: { x: 0, y: 0, z: Math.PI/2 },
330 |           roughness: 0.2,
331 |           metalness: 0.8,
332 |           transparent: true,
333 |           opacity: 0.8
334 |         },
335 |         {
336 |           type: "cylinder",
337 |           color: "#00ff00",
338 |           position: { x: 0.5, y: 1, z: 0 },
339 |           scale: { x: 0.1, y: 0.6, z: 0.1 },
340 |           rotation: { x: 0, y: 0, z: Math.PI/2 },
341 |           roughness: 0.2,
342 |           metalness: 0.8,
343 |           transparent: true,
344 |           opacity: 0.8
345 |         },
346 |         // Legs
347 |         {
348 |           type: "cylinder",
349 |           color: "#00ff00",
350 |           position: { x: -0.2, y: 0.2, z: 0 },
351 |           scale: { x: 0.1, y: 0.8, z: 0.1 },
352 |           roughness: 0.2,
353 |           metalness: 0.8,
354 |           transparent: true,
355 |           opacity: 0.8,
356 |           name: "leftLeg"
357 |         },
358 |         {
359 |           type: "cylinder",
360 |           color: "#00ff00",
361 |           position: { x: 0.2, y: 0.2, z: 0 },
362 |           scale: { x: 0.1, y: 0.8, z: 0.1 },
363 |           roughness: 0.2,
364 |           metalness: 0.8,
365 |           transparent: true,
366 |           opacity: 0.8,
367 |           name: "rightLeg"
368 |         },
369 |         // Base for collision
370 |         {
371 |           type: "box",
372 |           color: "#00ff00",
373 |           position: { x: 0, y: 0, z: 0 },
374 |           scale: { x: 0.5, y: 0.1, z: 0.3 },
375 |           roughness: 0.2,
376 |           metalness: 0.8,
377 |           transparent: true,
378 |           opacity: 0.8
379 |         }
380 |       ],
381 |       description: "A glowing green wireframe character"
382 |     }
383 |   },
384 |   {
385 |     id: "alien",
386 |     name: "Alien",
387 |     description: "A colorful alien character",
388 |     spec: {
389 |       customMode: true,
390 |       features: [
391 |         // Main alien body
392 |         {
393 |           type: "sphere",
394 |           /* @tweakable The color of the alien's body. */
395 |           color: "#FF6B6B",
396 |           position: { x: 0, y: 0.6, z: 0 },
397 |           scale: { x: 0.6, y: 0.9, z: 0.6 },
398 |           roughness: 0.9,
399 |           metalness: 0.1
400 |         },
401 |         // Bottom part (slightly larger)
402 |         {
403 |           type: "sphere",
404 |           /* @tweakable The color of the alien's lower body. */
405 |           color: "#FF6B6B",
406 |           position: { x: 0, y: 0.3, z: 0 },
407 |           scale: { x: 0.7, y: 0.5, z: 0.7 },
408 |           roughness: 0.9,
409 |           metalness: 0.1
410 |         },
411 |         // Eyes (white part)
412 |         {
413 |           type: "sphere",
414 |           color: "#FFFFFF",
415 |           position: { x: -0.2, y: 0.8, z: 0.4 },
416 |           scale: { x: 0.2, y: 0.2, z: 0.1 },
417 |           roughness: 0.5,
418 |           metalness: 0
419 |         },
420 |         {
421 |           type: "sphere",
422 |           color: "#FFFFFF",
423 |           position: { x: 0.2, y: 0.8, z: 0.4 },
424 |           scale: { x: 0.2, y: 0.2, z: 0.1 },
425 |           roughness: 0.5,
426 |           metalness: 0
427 |         },
428 |         // Pupils
429 |         {
430 |           type: "sphere",
431 |           color: "#000000",
432 |           position: { x: -0.2, y: 0.8, z: 0.5 },
433 |           scale: { x: 0.1, y: 0.1, z: 0.05 },
434 |           roughness: 0.5,
435 |           metalness: 0
436 |         },
437 |         {
438 |           type: "sphere",
439 |           color: "#000000",
440 |           position: { x: 0.2, y: 0.8, z: 0.5 },
441 |           scale: { x: 0.1, y: 0.1, z: 0.05 },
442 |           roughness: 0.5,
443 |           metalness: 0
444 |         },
445 |         // Stubby legs
446 |         {
447 |           type: "cylinder",
448 |           /* @tweakable The color of the alien's legs. */
449 |           color: "#FF6B6B",
450 |           position: { x: -0.3, y: 0, z: 0 },
451 |           scale: { x: 0.15, y: 0.3, z: 0.15 },
452 |           roughness: 0.9,
453 |           metalness: 0.1,
454 |           name: "leftLeg"
455 |         },
456 |         {
457 |           type: "cylinder",
458 |           /* @tweakable The color of the alien's legs. */
459 |           color: "#FF6B6B",
460 |           position: { x: 0.3, y: 0, z: 0 },
461 |           scale: { x: 0.15, y: 0.3, z: 0.15 },
462 |           roughness: 0.9,
463 |           metalness: 0.1,
464 |           name: "rightLeg"
465 |         }
466 |       ],
467 |       description: "A cute alien character with stubby legs"
468 |     }
469 |   }
470 | ];
471 | 
472 | // Available texture materials for AI character creator
473 | export const availableTextures = [
474 |   {
475 |     id: "brick",
476 |     name: "Brick Wall",
477 |     textureUrl: "https://threejs.org/examples/textures/brick_diffuse.jpg",
478 |     normalMap: "https://threejs.org/examples/textures/brick_normal.jpg",
479 |     roughness: 0.8,
480 |     metalness: 0.1
481 |   },
482 |   {
483 |     id: "wood",
484 |     name: "Wood",
485 |     textureUrl: "https://threejs.org/examples/textures/hardwood2_diffuse.jpg",
486 |     normalMap: "https://threejs.org/examples/textures/hardwood2_normal.jpg",
487 |     roughness: 0.7,
488 |     metalness: 0.0
489 |   },
490 |   {
491 |     id: "skin",
492 |     name: "Skin",
493 |     color: "#FFD6C4",
494 |     roughness: 0.6,
495 |     metalness: 0.0,
496 |     subsurface: 0.3
497 |   },
498 |   {
499 |     id: "metal",
500 |     name: "Metal",
501 |     color: "#AAAAAA",
502 |     roughness: 0.2,
503 |     metalness: 0.9,
504 |     envMap: true
505 |   },
506 |   {
507 |     id: "water",
508 |     name: "Water",
509 |     color: "#4444FF",
510 |     roughness: 0.1,
511 |     metalness: 0.3,
512 |     transparent: true,
513 |     opacity: 0.7
514 |   },
515 |   {
516 |     id: "glass",
517 |     name: "Glass",
518 |     color: "#FFFFFF",
519 |     roughness: 0.0,
520 |     metalness: 0.1,
521 |     transparent: true,
522 |     opacity: 0.3,
523 |     envMap: true
524 |   }
525 | ];
526 | 
527 | // Available animation properties for AI character creator
528 | export const availableAnimations = [
529 |   {
530 |     id: "jiggly",
531 |     name: "Jiggly",
532 |     description: "Makes the feature jiggle randomly"
533 |   },
534 |   {
535 |     id: "bobUpDown",
536 |     name: "Bob Up & Down",
537 |     description: "Makes the feature move up and down smoothly"
538 |   },
539 |   {
540 |     id: "spinY",
541 |     name: "Spin Y",
542 |     description: "Rotates the feature around the Y axis"
543 |   },
544 |   {
545 |     id: "spinX",
546 |     name: "Spin X",
547 |     description: "Rotates the feature around the X axis"
548 |   },
549 |   {
550 |     id: "spinZ",
551 |     name: "Spin Z",
552 |     description: "Rotates the feature around the Z axis"
553 |   },
554 |   {
555 |     id: "pulse",
556 |     name: "Pulse",
557 |     description: "Makes the feature grow and shrink"
558 |   }
559 | ];


--------------------------------------------------------------------------------
/js/characters/textures.js:
--------------------------------------------------------------------------------
 1 | // Available texture materials for AI character creator
 2 | export const availableTextures = [
 3 |   {
 4 |     id: "brick",
 5 |     name: "Brick Wall",
 6 |     textureUrl: "https://threejs.org/examples/textures/brick_diffuse.jpg",
 7 |     normalMap: "https://threejs.org/examples/textures/brick_normal.jpg",
 8 |     roughness: 0.8,
 9 |     metalness: 0.1
10 |   },
11 |   {
12 |     id: "wood",
13 |     name: "Wood",
14 |     textureUrl: "https://threejs.org/examples/textures/hardwood2_diffuse.jpg",
15 |     normalMap: "https://threejs.org/examples/textures/hardwood2_normal.jpg",
16 |     roughness: 0.7,
17 |     metalness: 0.0
18 |   },
19 |   {
20 |     id: "skin",
21 |     name: "Skin",
22 |     color: "#FFD6C4",
23 |     roughness: 0.6,
24 |     metalness: 0.0,
25 |     subsurface: 0.3
26 |   },
27 |   {
28 |     id: "metal",
29 |     name: "Metal",
30 |     color: "#AAAAAA",
31 |     roughness: 0.2,
32 |     metalness: 0.9,
33 |     envMap: true
34 |   },
35 |   {
36 |     id: "water",
37 |     name: "Water",
38 |     color: "#4444FF",
39 |     roughness: 0.1,
40 |     metalness: 0.3,
41 |     transparent: true,
42 |     opacity: 0.7
43 |   },
44 |   {
45 |     id: "glass",
46 |     name: "Glass",
47 |     color: "#FFFFFF",
48 |     roughness: 0.0,
49 |     metalness: 0.1,
50 |     transparent: true,
51 |     opacity: 0.3,
52 |     envMap: true
53 |   }
54 | ];


--------------------------------------------------------------------------------
/js/collisionManager.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | 
  3 | /* @tweakable The radius around the player to check for collisions. Lower values can improve performance but may cause missed collisions with distant objects. */
  4 | const COLLISION_CHECK_RADIUS = 10;
  5 | /* @tweakable Maximum height the player can step onto without jumping. */
  6 | const STEP_HEIGHT = 1.0;
  7 | /* @tweakable Additional padding around NPCs for collision detection. */
  8 | const NPC_COLLISION_PADDING = 0.2;
  9 | /* @tweakable Additional padding for player collision with amphitheater seats. A larger value creates a bigger buffer but might feel 'sticky'. */
 10 | const SEAT_COLLISION_PADDING = 0.2;
 11 | 
 12 | export class CollisionManager {
 13 |     constructor(scene) {
 14 |         this.scene = scene;
 15 |     }
 16 | 
 17 |     /**
 18 |      * Checks for collisions and updates player's new position and velocity.
 19 |      * @param {THREE.Vector3} currentPosition - The player's current position.
 20 |      * @param {THREE.Vector3} proposedPosition - The proposed movement vector for this frame.
 21 |      * @param {THREE.Vector3} velocity - The player's current velocity.
 22 |      * @param {number} playerRadius - The radius of the player's collision cylinder.
 23 |      * @param {number} playerHeight - The height of the player's collision cylinder.
 24 |      * @returns {{
 25 |      *  finalPosition: THREE.Vector3,
 26 |      *  finalVelocity: THREE.Vector3,
 27 |      *  canJump: boolean,
 28 |      *  standingOnBlock: boolean
 29 |      * }}
 30 |      */
 31 |     checkCollisions(currentPosition, proposedPosition, velocity, playerRadius, playerHeight) {
 32 |         const blockMeshes = [];
 33 |         const worldPosition = new THREE.Vector3();
 34 | 
 35 |         this.scene.traverse(child => {
 36 |             // This is a more robust way of collecting collidable objects,
 37 |             // as it checks the entire scene graph, not just direct children.
 38 |             if (child.userData.isBlock || child.userData.isBarrier || (child.type === "Group" && child.userData.isTree) || child.userData.isNpc) {
 39 |                 child.getWorldPosition(worldPosition);
 40 |                 /* @tweakable The distance from the player to check for collidable objects. Lowering may improve performance but can cause missed collisions with large objects. */
 41 |                 const effectiveCollisionRadius = COLLISION_CHECK_RADIUS + (child.geometry?.boundingSphere?.radius || 0);
 42 |                 if (worldPosition.distanceTo(currentPosition) < effectiveCollisionRadius) {
 43 |                     blockMeshes.push(child);
 44 |                 }
 45 |             }
 46 |         });
 47 | 
 48 |         let finalPosition = proposedPosition.clone();
 49 |         let finalVelocity = velocity.clone();
 50 |         let canJump = false;
 51 |         let standingOnBlock = false;
 52 |         
 53 |         const movementVector = new THREE.Vector3().subVectors(proposedPosition, currentPosition);
 54 | 
 55 |         blockMeshes.forEach(block => {
 56 |             const result = this._checkCollisionWithBlock(currentPosition, finalPosition, finalVelocity, playerRadius, playerHeight, block);
 57 |             if(result.standingOnBlock) {
 58 |                 standingOnBlock = true;
 59 |                 finalPosition.y = result.newY;
 60 |                 finalVelocity.y = 0;
 61 |                 canJump = true;
 62 |             } else if (result.collided) {
 63 |                 // If a side collision is detected, revert movement on that axis.
 64 |                 // This is a simplified resolution and could be improved.
 65 |                 if (Math.abs(movementVector.x) > 0) finalPosition.x = currentPosition.x;
 66 |                 if (Math.abs(movementVector.z) > 0) finalPosition.z = currentPosition.z;
 67 |             }
 68 |         });
 69 | 
 70 |         return { finalPosition, finalVelocity, canJump, standingOnBlock };
 71 |     }
 72 |     
 73 |     _checkCollisionWithBlock(currentPosition, newPosition, velocity, playerRadius, playerHeight, block) {
 74 |         if (block.userData.isSeatRow) {
 75 |             return this._checkCollisionWithSeatRow(currentPosition, newPosition, velocity, playerRadius, playerHeight, block);
 76 |         }
 77 | 
 78 |         const boundingBox = new THREE.Box3().setFromObject(block);
 79 |         const blockSize = new THREE.Vector3();
 80 |         boundingBox.getSize(blockSize);
 81 |         const blockCenter = new THREE.Vector3();
 82 |         boundingBox.getCenter(blockCenter);
 83 | 
 84 |         // Allow override for trees which are groups
 85 |         let blockWidth = blockSize.x;
 86 |         let blockHeight = blockSize.y;
 87 |         let blockDepth = blockSize.z;
 88 |         if (block.type === "Group" && block.userData.isTree) {
 89 |              blockWidth = 1.0;
 90 |              blockHeight = 2.0;
 91 |              blockDepth = 1.0;
 92 |         }
 93 | 
 94 |         const collisionPadding = block.userData.isNpc ? NPC_COLLISION_PADDING : 0;
 95 |         const effectivePlayerRadius = playerRadius + collisionPadding;
 96 | 
 97 |         const blockTop = blockCenter.y + blockHeight / 2;
 98 |         let standingOnBlock = false;
 99 |         let newY = newPosition.y;
100 |         let collided = false;
101 | 
102 |         // Check if player is landing on top of the block
103 |         if (
104 |             !block.userData.isNpc && // Prevent standing on NPCs
105 |             velocity.y <= 0 &&
106 |             currentPosition.y >= blockTop - 0.2 &&
107 |             newPosition.y <= (blockTop + 0.20) &&
108 |             Math.abs(newPosition.x - blockCenter.x) < (blockWidth / 2 + effectivePlayerRadius) &&
109 |             Math.abs(newPosition.z - blockCenter.z) < (blockDepth / 2 + effectivePlayerRadius)
110 |         ) {
111 |             standingOnBlock = true;
112 |             newY = blockTop; // Player's feet height
113 |         } else if (
114 |             block.userData.isStair &&
115 |             velocity.y <= 0 &&
116 |             currentPosition.y >= blockTop - STEP_HEIGHT &&
117 |             newPosition.y <= blockTop + 0.2 &&
118 |             Math.abs(newPosition.x - blockCenter.x) < (blockWidth / 2 + effectivePlayerRadius) &&
119 |             Math.abs(newPosition.z - blockCenter.z) < (blockDepth / 2 + effectivePlayerRadius)
120 |         ) {
121 |             // Allow stepping onto stairs and seat rows without jumping
122 |             standingOnBlock = true;
123 |             newY = blockTop;
124 |         }
125 |         // Check for side collision
126 |         else if (
127 |             Math.abs(newPosition.x - blockCenter.x) < (blockWidth / 2 + effectivePlayerRadius) &&
128 |             Math.abs(newPosition.z - blockCenter.z) < (blockDepth / 2 + effectivePlayerRadius) &&
129 |             newPosition.y < (blockTop) && // Bottom of player is below top of block
130 |             newPosition.y + playerHeight > (blockCenter.y - blockHeight / 2) // Top of player is above bottom of block
131 |         ) {
132 |             collided = true;
133 |         }
134 | 
135 |         return { collided, standingOnBlock, newY };
136 |     }
137 | 
138 |     _checkCollisionWithSeatRow(currentPosition, newPosition, velocity, playerRadius, playerHeight, block) {
139 |         // Get world position of the specific seat segment (the 'block')
140 |         const blockWorldPosition = new THREE.Vector3();
141 |         block.getWorldPosition(blockWorldPosition);
142 | 
143 |         const seatData = block.userData.seatRowData;
144 |         if (!seatData) return { collided: false, standingOnBlock: false, newY: newPosition.y };
145 |         
146 |         // Player position relative to the block's center (on the XZ plane)
147 |         const playerRelativePos = new THREE.Vector2(newPosition.x - blockWorldPosition.x, newPosition.z - blockWorldPosition.z);
148 |         
149 |         // This check is flawed because the block is just a segment.
150 |         // We need a better way to check if the player is "inside" the arc segment.
151 |         // Let's use a simpler AABB check on the block itself.
152 |         const boundingBox = new THREE.Box3().setFromObject(block);
153 |         const effectivePlayerRadius = playerRadius + SEAT_COLLISION_PADDING;
154 | 
155 |         const blockTop = boundingBox.max.y;
156 |         
157 |         let standingOnBlock = false;
158 |         let newY = newPosition.y;
159 |         let collided = false;
160 | 
161 |         // Broad-phase check using bounding box
162 |         if (boundingBox.intersectsBox(new THREE.Box3().setFromCenterAndSize(
163 |             newPosition,
164 |             new THREE.Vector3(effectivePlayerRadius * 2, playerHeight, effectivePlayerRadius * 2)
165 |         ))) {
166 |             // Check if player is landing on top of the seat
167 |             if (
168 |                 velocity.y <= 0 &&
169 |                 currentPosition.y >= blockTop - 0.2 &&
170 |                 newPosition.y <= (blockTop + 0.2)
171 |             ) {
172 |                 standingOnBlock = true;
173 |                 newY = blockTop;
174 |             } else if (
175 |                 // Allow stepping up
176 |                 velocity.y <= 0 &&
177 |                 currentPosition.y >= blockTop - STEP_HEIGHT &&
178 |                 newPosition.y <= (blockTop + 0.2)
179 |             ) {
180 |                 standingOnBlock = true;
181 |                 newY = blockTop;
182 |             }
183 |             // Check for side collision
184 |             else if (
185 |                 newPosition.y < blockTop &&
186 |                 newPosition.y + playerHeight > boundingBox.min.y
187 |             ) {
188 |                 collided = true;
189 |             }
190 |         }
191 |         
192 |         return { collided, standingOnBlock, newY };
193 |     }
194 | }


--------------------------------------------------------------------------------
/js/controls/InputManager.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from "three";
  2 | import { SPEED, MOBILE_SPEED_MULTIPLIER } from "./constants.js";
  3 | 
  4 | /* @tweakable Multiplier for movement joystick sensitivity on mobile. */
  5 | const MOVE_JOYSTICK_SENSITIVITY = 1.2;
  6 | /* @tweakable Multiplier for camera touch sensitivity on mobile. */
  7 | const CAMERA_TOUCH_SENSITIVITY = 0.005;
  8 | /* @tweakable The exponent for joystick input curve. >1 for slower start, <1 for faster start. */
  9 | const JOYSTICK_INPUT_CURVE = 1.2;
 10 | 
 11 | export class InputManager {
 12 |   constructor(isMobile, cameraTouchElement) {
 13 |     this.isMobile = isMobile;
 14 |     this.keysPressed = new Set();
 15 |     this.moveJoystick = null;
 16 |     this.cameraTouchElement = cameraTouchElement;
 17 |     this.moveForward = 0;
 18 |     this.moveRight = 0;
 19 |     this.cameraX = 0;
 20 |     this.cameraY = 0;
 21 |     this.jumpRequested = false;
 22 |     this.cameraMoving = false;
 23 | 
 24 |     if (this.isMobile) {
 25 |       this.initializeMobileInput();
 26 |     } else {
 27 |       this.initializeDesktopInput();
 28 |     }
 29 |   }
 30 | 
 31 |   initializeDesktopInput() {
 32 |     document.addEventListener("keydown", (e) => {
 33 |       if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') {
 34 |         return;
 35 |       }
 36 |       this.keysPressed.add(e.key.toLowerCase());
 37 |     });
 38 | 
 39 |     document.addEventListener("keyup", (e) => {
 40 |       this.keysPressed.delete(e.key.toLowerCase());
 41 |     });
 42 |   }
 43 | 
 44 |   initializeMobileInput() {
 45 |     const moveJoystickContainer = document.getElementById('joystick-container');
 46 |     if (!moveJoystickContainer) {
 47 |       console.error("Joystick container not found!");
 48 |       return;
 49 |     }
 50 | 
 51 |     this.moveJoystick = nipplejs.create({
 52 |       zone: moveJoystickContainer,
 53 |       mode: 'static',
 54 |       position: { left: '50%', top: '50%' },
 55 |       color: 'rgba(255, 255, 255, 0.5)',
 56 |       size: 120
 57 |     });
 58 | 
 59 |     this.moveJoystick.on('move', (evt, data) => {
 60 |       const baseForce = Math.min(data.force, 1.0);
 61 |       /* @tweakable Adjusts the sensitivity curve of the movement joystick. Higher values mean more precision at low intensity. */
 62 |       const force = Math.pow(baseForce, JOYSTICK_INPUT_CURVE) * MOVE_JOYSTICK_SENSITIVITY;
 63 |       const angle = data.angle.radian;
 64 |       this.moveForward = Math.sin(angle) * force;
 65 |       this.moveRight = Math.cos(angle) * force;
 66 |     });
 67 | 
 68 |     this.moveJoystick.on('end', () => {
 69 |       this.moveForward = 0;
 70 |       this.moveRight = 0;
 71 |     });
 72 | 
 73 |     if (this.cameraTouchElement) {
 74 |         let lastTouchX = 0;
 75 |         let lastTouchY = 0;
 76 | 
 77 |         this.cameraTouchElement.addEventListener('touchstart', (e) => {
 78 |             if (e.touches.length === 1) {
 79 |                 lastTouchX = e.touches[0].clientX;
 80 |                 lastTouchY = e.touches[0].clientY;
 81 |                 this.cameraMoving = true;
 82 |             }
 83 |         });
 84 | 
 85 |         this.cameraTouchElement.addEventListener('touchmove', (e) => {
 86 |             if (e.touches.length === 1) {
 87 |                 const touch = e.touches[0];
 88 |                 this.cameraX = (touch.clientX - lastTouchX) * CAMERA_TOUCH_SENSITIVITY;
 89 |                 this.cameraY = (touch.clientY - lastTouchY) * CAMERA_TOUCH_SENSITIVITY;
 90 |                 lastTouchX = touch.clientX;
 91 |                 lastTouchY = touch.clientY;
 92 |             }
 93 |         });
 94 |         
 95 |         this.cameraTouchElement.addEventListener('touchend', () => {
 96 |             this.cameraX = 0;
 97 |             this.cameraY = 0;
 98 |             this.cameraMoving = false;
 99 |         });
100 |     }
101 | 
102 |     const jumpButton = document.getElementById('jump-button');
103 |     if (jumpButton) {
104 |       jumpButton.addEventListener('touchstart', (e) => {
105 |         e.preventDefault();
106 |         this.jumpRequested = true;
107 |       });
108 |       jumpButton.addEventListener('touchend', (e) => {
109 |         e.preventDefault();
110 |         this.jumpRequested = false;
111 |       });
112 |     }
113 |   }
114 | 
115 |   getMovementDirection() {
116 |     const moveDirection = new THREE.Vector3(0, 0, 0);
117 | 
118 |     if (this.isMobile) {
119 |         // z becomes forward/backward, x becomes left/right
120 |         moveDirection.z = this.moveForward;
121 |         moveDirection.x = this.moveRight;
122 |     } else {
123 |       if (this.keysPressed.has("w") || this.keysPressed.has("arrowup")) {
124 |         moveDirection.z = 1;
125 |       } else if (this.keysPressed.has("s") || this.keysPressed.has("arrowdown")) {
126 |         moveDirection.z = -1;
127 |       }
128 | 
129 |       if (this.keysPressed.has("a") || this.keysPressed.has("arrowleft")) {
130 |         moveDirection.x = -1;
131 |       } else if (this.keysPressed.has("d") || this.keysPressed.has("arrowright")) {
132 |         moveDirection.x = 1;
133 |       }
134 | 
135 |        if (moveDirection.length() > 0) {
136 |         moveDirection.normalize();
137 |       }
138 |     }
139 | 
140 |     return moveDirection;
141 |   }
142 |   
143 |   getCameraMovement() {
144 |       const movement = { x: this.cameraX, y: this.cameraY };
145 |       if (this.isMobile) {
146 |           // decay movement for smoother stop
147 |           this.cameraX *= 0.5;
148 |           this.cameraY *= 0.5;
149 |       }
150 |       return movement;
151 |   }
152 |   
153 |   isCameraMoving() {
154 |       return this.cameraMoving;
155 |   }
156 | 
157 |   isJumping() {
158 |     if (this.isMobile) {
159 |       const shouldJump = this.jumpRequested;
160 |       if (shouldJump) {
161 |         this.jumpRequested = false; // Consume the jump request
162 |       }
163 |       return shouldJump;
164 |     }
165 |     return this.keysPressed.has(" ");
166 |   }
167 | 
168 |   isRunning() {
169 |     if (this.isMobile) {
170 |       // For now, mobile users can't run. This can be expanded with a run button.
171 |       return false;
172 |     }
173 |     return this.keysPressed.has("shift");
174 |   }
175 | 
176 |   resetJump() {
177 |     // This method is no longer needed for mobile jump logic
178 |     // but we keep it in case it's used elsewhere or for future features.
179 |     if (this.isMobile) {
180 |         this.jumpRequested = false;
181 |     }
182 |   }
183 | }


--------------------------------------------------------------------------------
/js/controls/constants.js:
--------------------------------------------------------------------------------
 1 | /* @tweakable Base movement speed for the player. */
 2 | export const SPEED = 0.08;
 3 | /* @tweakable Gravity force applied to the player. */
 4 | export const GRAVITY = 0.01;
 5 | /* @tweakable The upward force applied when jumping. */
 6 | export const JUMP_FORCE = 0.25;
 7 | /* @tweakable The upward force applied when jumping on mobile. */
 8 | export const MOBILE_JUMP_FORCE = 0.25;
 9 | /* @tweakable Speed multiplier for mobile joystick controls. */
10 | export const MOBILE_SPEED_MULTIPLIER = 1.0;
11 | /* @tweakable Multiplier for player speed when running. */
12 | export const RUN_SPEED_MULTIPLIER = 1.8;
13 | 
14 | /* @tweakable Force mobile controls for testing on desktop. Reload is required. */
15 | export const FORCE_MOBILE_MODE = false;


--------------------------------------------------------------------------------
/js/downloader.js:
--------------------------------------------------------------------------------
 1 | export class Downloader {
 2 |   async download(url, progressCallback) {
 3 |     const response = await fetch(url);
 4 |     if (!response.ok) {
 5 |       throw new Error(`Failed to fetch ${url}`);
 6 |     }
 7 |     const contentLength = parseInt(response.headers.get('Content-Length')) || 0;
 8 |     const reader = response.body.getReader();
 9 |     let received = 0;
10 |     const chunks = [];
11 |     while (true) {
12 |       const { done, value } = await reader.read();
13 |       if (done) break;
14 |       chunks.push(value);
15 |       received += value.length;
16 |       if (progressCallback && contentLength) {
17 |         progressCallback(received / contentLength);
18 |       }
19 |     }
20 |     return new Blob(chunks);
21 |   }
22 | 
23 |   async preloadAssets(assets, progressCallback) {
24 |     const results = {};
25 |     for (const asset of assets) {
26 |       const blob = await this.download(asset.url, p => {
27 |         if (progressCallback) progressCallback(asset, p);
28 |       });
29 |       results[asset.name] = blob;
30 |     }
31 |     return results;
32 |   }
33 | }
34 | 


--------------------------------------------------------------------------------
/js/interaction.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | 
  3 | /* @tweakable The distance in world units within which player can interact with an NPC. */
  4 | const INTERACTION_RADIUS = 3;
  5 | /* @tweakable The vertical offset for the interaction prompt above the NPC's head. */
  6 | const PROMPT_VERTICAL_OFFSET = 2.5;
  7 | /* @tweakable Font size for the NPC's name in the interaction prompt. */
  8 | const NPC_NAME_FONT_SIZE = '16px';
  9 | /* @tweakable Font size for the instruction text in the interaction prompt. */
 10 | const INSTRUCTION_FONT_SIZE = '14px';
 11 | /* @tweakable The delay in milliseconds between checks for interactable NPCs. Higher values improve performance but reduce responsiveness. */
 12 | const INTERACTION_CHECK_DELAY = 250; // ms
 13 | 
 14 | export class InteractionManager {
 15 |     constructor(dependencies) {
 16 |         this.playerControls = dependencies.playerControls;
 17 |         this.npcManager = dependencies.npcManager;
 18 |         this.camera = dependencies.camera;
 19 |         this.renderer = dependencies.renderer;
 20 |         
 21 |         this.isDesktop = !/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
 22 |         this.interactionPrompt = null;
 23 |         this.conversationModal = null;
 24 |         this.targetNpc = null;
 25 |         this.lastCheckTime = 0;
 26 |     }
 27 | 
 28 |     init() {
 29 |         if (!this.isDesktop) return;
 30 | 
 31 |         // Create interaction prompt UI
 32 |         const promptEl = document.createElement('div');
 33 |         promptEl.id = 'interaction-prompt';
 34 |         promptEl.style.display = 'none';
 35 |         promptEl.innerHTML = `
 36 |             <div class="interaction-npc-name"></div>
 37 |             <div class="interaction-instruction"></div>
 38 |         `;
 39 |         document.getElementById('game-container').appendChild(promptEl);
 40 |         this.interactionPrompt = promptEl;
 41 | 
 42 |         // Create conversation modal UI
 43 |         const modalEl = document.createElement('div');
 44 |         modalEl.id = 'npc-conversation-modal';
 45 |         modalEl.style.display = 'none';
 46 |         modalEl.innerHTML = `
 47 |             <div id="npc-conversation-content">
 48 |                 <h3 id="npc-name"></h3>
 49 |                 <p id="npc-dialogue"></p>
 50 |                 <button id="close-conversation">Close</button>
 51 |             </div>
 52 |         `;
 53 |         document.getElementById('game-container').appendChild(modalEl);
 54 |         this.conversationModal = modalEl;
 55 | 
 56 |         // Add event listeners
 57 |         document.addEventListener('keydown', this.handleKeyDown.bind(this));
 58 |         modalEl.querySelector('#close-conversation').addEventListener('click', this.closeModal.bind(this));
 59 |     }
 60 | 
 61 |     update() {
 62 |         const now = performance.now();
 63 |         if (!this.isDesktop || this.conversationModal.style.display === 'flex' || (now - this.lastCheckTime < INTERACTION_CHECK_DELAY)) {
 64 |             if (this.conversationModal.style.display === 'flex' && this.interactionPrompt.style.display !== 'none') {
 65 |                 this.interactionPrompt.style.display = 'none';
 66 |                 this.targetNpc = null;
 67 |             }
 68 |             return;
 69 |         }
 70 |         
 71 |         this.lastCheckTime = now;
 72 | 
 73 |         const playerPos = this.playerControls.getPlayerModel().position;
 74 |         let closestNpc = null;
 75 |         let minDistance = INTERACTION_RADIUS;
 76 | 
 77 |         this.npcManager.npcs.forEach(npc => {
 78 |             const distance = playerPos.distanceTo(npc.model.position);
 79 |             if (distance < minDistance) {
 80 |                 minDistance = distance;
 81 |                 closestNpc = npc;
 82 |             }
 83 |         });
 84 | 
 85 |         this.targetNpc = closestNpc;
 86 | 
 87 |         if (this.targetNpc) {
 88 |             this.updatePromptPosition();
 89 |             const nameEl = this.interactionPrompt.querySelector('.interaction-npc-name');
 90 |             const instructionEl = this.interactionPrompt.querySelector('.interaction-instruction');
 91 |             
 92 |             nameEl.innerText = this.targetNpc.model.name || 'NPC';
 93 |             instructionEl.innerText = 'Press F to talk';
 94 |             
 95 |             nameEl.style.fontSize = NPC_NAME_FONT_SIZE;
 96 |             instructionEl.style.fontSize = INSTRUCTION_FONT_SIZE;
 97 | 
 98 |         } else if (this.interactionPrompt.style.display !== 'none') {
 99 |             this.interactionPrompt.style.display = 'none';
100 |         }
101 |     }
102 | 
103 |     updatePromptPosition() {
104 |         if (!this.targetNpc) return;
105 | 
106 |         const pos = this.targetNpc.model.position.clone();
107 |         pos.y += PROMPT_VERTICAL_OFFSET;
108 | 
109 |         const screenPos = this._getScreenPosition(pos);
110 |         if (screenPos && screenPos.visible) {
111 |             this.interactionPrompt.style.left = `${screenPos.x}px`;
112 |             this.interactionPrompt.style.top = `${screenPos.y}px`;
113 |             this.interactionPrompt.style.transform = 'translate(-50%, -50%)';
114 |             this.interactionPrompt.style.display = 'block';
115 |         } else {
116 |             this.interactionPrompt.style.display = 'none';
117 |         }
118 |     }
119 |     
120 |     _getScreenPosition(position) {
121 |         const vector = new THREE.Vector3();
122 |         vector.copy(position);
123 |         vector.project(this.camera);
124 | 
125 |         const widthHalf = this.renderer.domElement.width / 2;
126 |         const heightHalf = this.renderer.domElement.height / 2;
127 | 
128 |         return {
129 |             x: (vector.x * widthHalf) + widthHalf,
130 |             y: -(vector.y * heightHalf) + heightHalf,
131 |             visible: vector.z < 1
132 |         };
133 |     }
134 | 
135 |     handleKeyDown(event) {
136 |         if (event.key.toLowerCase() === 'f' && this.targetNpc && this.conversationModal.style.display === 'none') {
137 |             this.startConversation();
138 |         }
139 |     }
140 | 
141 |     async startConversation() {
142 |         if (!this.targetNpc) return;
143 | 
144 |         this.npcManager.setInteracting(this.targetNpc, true);
145 | 
146 |         this.openModal("Thinking...", this.targetNpc);
147 |         
148 |         try {
149 |             const dialogue = await this.generateDialogue(this.targetNpc);
150 |             const dialogueTextEl = this.conversationModal.querySelector('#npc-dialogue');
151 |             dialogueTextEl.innerText = dialogue;
152 |         } catch(e) {
153 |             console.error("Failed to generate NPC dialogue:", e);
154 |             const dialogueTextEl = this.conversationModal.querySelector('#npc-dialogue');
155 |             dialogueTextEl.innerText = "I... don't have much to say right now.";
156 |         }
157 |     }
158 | 
159 |     async generateDialogue(npc) {
160 |         const characterSpec = npc.model.userData.characterSpec;
161 |         const description = characterSpec?.description || "a mysterious figure";
162 | 
163 |         const messages = [
164 |             {
165 |                 role: "system",
166 |                 content: `You are an NPC in a 3D world. Your appearance is described as: "${description}". You are a clone of the player's character. Generate a short, in-character, one-paragraph dialogue for when a player interacts with you for the first time. Be welcoming, maybe a little curious. Do not break character. Respond with only the dialogue text.`
167 |             },
168 |             {
169 |                 role: "user",
170 |                 content: "Hello there!"
171 |             }
172 |         ];
173 |         
174 |         const completion = await websim.chat.completions.create({ messages });
175 |         return completion.content;
176 |     }
177 | 
178 |     openModal(text, npc) {
179 |         this.conversationModal.querySelector('#npc-name').innerText = npc.model.name || 'NPC';
180 |         this.conversationModal.querySelector('#npc-dialogue').innerText = text;
181 |         this.conversationModal.style.display = 'flex';
182 |         this.playerControls.enabled = false;
183 |         this.interactionPrompt.style.display = 'none';
184 |     }
185 | 
186 |     closeModal() {
187 |         this.conversationModal.style.display = 'none';
188 |         this.playerControls.enabled = true;
189 |         if (this.targetNpc) {
190 |             this.npcManager.setInteracting(this.targetNpc, false);
191 |         }
192 |     }
193 | }


--------------------------------------------------------------------------------
/js/inventoryManager.js:
--------------------------------------------------------------------------------
 1 | export class InventoryManager {
 2 |     constructor(dependencies) {
 3 |         this.playerControls = dependencies.playerControls;
 4 |         this.inventoryUI = null; // Will be set after UIManager initializes it
 5 |         this.isOpen = false;
 6 |     }
 7 | 
 8 |     init() {
 9 |         window.addEventListener('keydown', (e) => {
10 |             // Do not toggle if user is typing in an input
11 |             if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') {
12 |                 return;
13 |             }
14 |             if (e.key.toLowerCase() === 'i') {
15 |                 this.toggle();
16 |             }
17 |         });
18 |     }
19 | 
20 |     toggle() {
21 |         this.isOpen = !this.isOpen;
22 |         if (this.inventoryUI) {
23 |             this.inventoryUI.toggle(this.isOpen);
24 |         }
25 |         if (this.playerControls) {
26 |             this.playerControls.enabled = !this.isOpen;
27 |         }
28 |     }
29 | }


--------------------------------------------------------------------------------
/js/lifespanExtender.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | 
  3 | export class LifespanExtender {
  4 |     constructor(scene, buildTool) {
  5 |         this.scene = scene;
  6 |         this.buildTool = buildTool;
  7 |         this.room = buildTool.room;
  8 |         this.enabled = false;
  9 |     }
 10 | 
 11 |     toggle() {
 12 |         this.enabled = !this.enabled;
 13 | 
 14 |         if (this.enabled) {
 15 |             this.showNotification("Lifespan Extender active. Click to extend object lifespans.", false);
 16 |         } else {
 17 |             this.hideNotification();
 18 |         }
 19 | 
 20 |         return this.enabled;
 21 |     }
 22 | 
 23 |     extendObjects(playerPosition, buildObjects) {
 24 |         const currentTime = Date.now();
 25 |         const extendedTime = currentTime + (24 * 60 * 60 * 1000); // 24 hours in milliseconds
 26 |         const radius = 10;
 27 |         let extendedCount = 0;
 28 | 
 29 |         for (let i = 0; i < buildObjects.length; i++) {
 30 |             const object = buildObjects[i];
 31 |             const distance = playerPosition.distanceTo(object.position);
 32 | 
 33 |             if (distance <= radius) {
 34 |                 object.userData.extendedUntil = extendedTime;
 35 |                 extendedCount++;
 36 |                 this.showExtensionEffect(object.position.clone());
 37 | 
 38 |                 if (this.room && object.userData.id) {
 39 |                     const buildData = {
 40 |                         type: 'extend_lifespan',
 41 |                         objectId: object.userData.id,
 42 |                         extendedUntil: extendedTime
 43 |                     };
 44 | 
 45 |                     this.room.send(buildData);
 46 | 
 47 |                     if (this.room.roomState.buildObjects && this.room.roomState.buildObjects[object.userData.id]) {
 48 |                         const updatedBuildObjects = { ...(this.room.roomState.buildObjects) };
 49 |                         updatedBuildObjects[object.userData.id].extendedUntil = extendedTime;
 50 |                         this.room.updateRoomState({ buildObjects: updatedBuildObjects });
 51 |                     }
 52 |                 }
 53 |             }
 54 |         }
 55 | 
 56 |         if (extendedCount > 0) {
 57 |             this.showNotification(`Extended lifespan of ${extendedCount} objects for 24 hours!`, true);
 58 |         } else {
 59 |             this.showNotification("No objects found within range to extend.", true);
 60 |         }
 61 |         setTimeout(() => this.hideNotification(), 3000);
 62 |     }
 63 | 
 64 |     receiveExtension(object, extensionData) {
 65 |         object.userData.extendedUntil = extensionData.extendedUntil;
 66 |         this.showExtensionEffect(object.position.clone());
 67 |     }
 68 | 
 69 |     showExtensionEffect(position) {
 70 |         const geometry = new THREE.SphereGeometry(0.5, 8, 8);
 71 |         const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.7 });
 72 |         const effect = new THREE.Mesh(geometry, material);
 73 |         effect.position.copy(position);
 74 |         this.scene.add(effect);
 75 | 
 76 |         const startTime = Date.now();
 77 |         const duration = 1000;
 78 | 
 79 |         const animateEffect = () => {
 80 |             const elapsed = Date.now() - startTime;
 81 |             const progress = Math.min(elapsed / duration, 1);
 82 |             effect.scale.set(1 + progress * 2, 1 + progress * 2, 1 + progress * 2);
 83 |             effect.material.opacity = 0.7 * (1 - progress);
 84 | 
 85 |             if (progress < 1) {
 86 |                 requestAnimationFrame(animateEffect);
 87 |             } else {
 88 |                 this.scene.remove(effect);
 89 |             }
 90 |         };
 91 |         animateEffect();
 92 |     }
 93 | 
 94 |     showNotification(message, isComplete = false) {
 95 |         let notification = document.getElementById('lifespan-notification');
 96 |         if (!notification) {
 97 |             notification = document.createElement('div');
 98 |             notification.id = 'lifespan-notification';
 99 |             document.getElementById('game-container').appendChild(notification);
100 |         }
101 |         notification.innerHTML = `<div>${isComplete ? '' : '<div class="ai-loading-spinner"></div>'} ${message}</div>`;
102 |         notification.style.display = 'block';
103 |     }
104 | 
105 |     hideNotification() {
106 |         const notification = document.getElementById('lifespan-notification');
107 |         if (notification) {
108 |             notification.style.display = 'none';
109 |         }
110 |     }
111 | }


--------------------------------------------------------------------------------
/js/multiplayerManager.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | 
  3 | export class MultiplayerManager {
  4 |     constructor(dependencies) {
  5 |         this.room = dependencies.room;
  6 |         this.scene = dependencies.scene;
  7 |         this.camera = dependencies.camera;
  8 |         this.renderer = dependencies.renderer;
  9 |         this.buildTool = dependencies.buildTool;
 10 |         this.advancedBuildTool = dependencies.advancedBuildTool;
 11 |         this.createPlayerModel = dependencies.createPlayerModel;
 12 |         this.playerControls = dependencies.playerControls;
 13 | 
 14 |         this.otherPlayers = {};
 15 |         this.playerLabels = {};
 16 |         this.chatMessages = {};
 17 |         this.collectedRemotes = {};
 18 |         this.chatLogMessageHandler = null;
 19 |     }
 20 | 
 21 |     init() {
 22 |         this.subscribeToPresence();
 23 |         this.subscribeToMessages();
 24 |         this.subscribeToRoomState();
 25 |         this.chatMessages[this.room.clientId] = this._createChatMessageElement(this.room.clientId);
 26 |     }
 27 |     
 28 |     setChatLogMessageHandler(handler) {
 29 |         this.chatLogMessageHandler = handler;
 30 |     }
 31 | 
 32 |     subscribeToPresence() {
 33 |         this.room.subscribePresence((presence) => {
 34 |             for (const clientId in presence) {
 35 |                 if (clientId === this.room.clientId) {
 36 |                     this.handleLocalPlayerChat(presence[clientId]);
 37 |                     continue;
 38 |                 };
 39 | 
 40 |                 const playerData = presence[clientId];
 41 |                 if (!playerData) continue;
 42 | 
 43 |                 if (!this.otherPlayers[clientId] && playerData.x !== undefined) {
 44 |                     this.addPlayer(clientId, playerData);
 45 |                 } else if (this.otherPlayers[clientId] && playerData.x !== undefined) {
 46 |                     this.updatePlayer(clientId, playerData);
 47 |                 }
 48 |             }
 49 | 
 50 |             for (const clientId in this.otherPlayers) {
 51 |                 if (!presence[clientId]) {
 52 |                     this.removePlayer(clientId);
 53 |                 }
 54 |             }
 55 |         });
 56 |     }
 57 | 
 58 |     handleLocalPlayerChat(playerData) {
 59 |         if (playerData.chat && this.chatMessages[this.room.clientId]?.lastTimestamp !== playerData.chat.timestamp) {
 60 |             this.chatMessages[this.room.clientId].lastTimestamp = playerData.chat.timestamp;
 61 |             this.displayChatMessage(this.room.clientId, playerData.chat.message);
 62 |         }
 63 |     }
 64 | 
 65 |     subscribeToMessages() {
 66 |         this.room.onmessage = (event) => {
 67 |             const data = event.data;
 68 |             switch(data.type) {
 69 |                 case 'build_object':
 70 |                     if (data.isAdvanced) this.advancedBuildTool.receiveBuildObject(data);
 71 |                     else this.buildTool.receiveBuildObject(data);
 72 |                     break;
 73 |                 case 'transform_object': this.advancedBuildTool.receiveObjectTransform(data); break;
 74 |                 case 'delete_build_object': this.advancedBuildTool.receiveDeleteObject(data.objectId); break;
 75 |                 case 'color_object': this.advancedBuildTool.receiveObjectColor(data); break;
 76 |                 case 'extend_lifespan': this.buildTool.receiveLifespanExtension(data); break;
 77 |             }
 78 |         };
 79 |     }
 80 |     
 81 |     subscribeToRoomState() {
 82 |         this.room.subscribeRoomState((roomState) => {
 83 |             if (roomState.collectedRemotes) {
 84 |                 this.collectedRemotes = {...roomState.collectedRemotes};
 85 |                 this.scene.traverse((object) => {
 86 |                     if (object.userData.isRemote && this.collectedRemotes[object.userData.remoteId]) {
 87 |                         object.visible = false;
 88 |                     }
 89 |                 });
 90 |                 if (Object.keys(this.collectedRemotes).length > 0 && document.getElementById('useless-button')) {
 91 |                     document.getElementById('useless-button').style.display = 'block';
 92 |                 }
 93 |             }
 94 |         });
 95 |     }
 96 | 
 97 |     addPlayer(clientId, playerData) {
 98 |         const peerInfo = this.room.peers[clientId] || {};
 99 |         const peerName = peerInfo.username || `Player${clientId.substring(0, 4)}`;
100 |         
101 |         const playerModel = this.createPlayerModel(THREE, peerName, playerData.characterSpec);
102 |         playerModel.position.set(playerData.x, playerData.y || 0.5, playerData.z);
103 |         if (playerData.rotation) {
104 |              const offset = playerModel.userData.isAnimatedGLB ? (playerModel.userData.rotationOffset || 0) : 0;
105 |              playerModel.rotation.y = playerData.rotation + offset;
106 |         }
107 |         this.scene.add(playerModel);
108 |         this.otherPlayers[clientId] = playerModel;
109 |         
110 |         this.playerLabels[clientId] = this._createPlayerLabelElement(clientId, peerName);
111 |         this.chatMessages[clientId] = this._createChatMessageElement(clientId);
112 |     }
113 | 
114 |     updatePlayer(clientId, playerData) {
115 |         const playerModel = this.otherPlayers[clientId];
116 |         if (playerData.characterSpec && JSON.stringify(playerModel.userData.characterSpec) !== JSON.stringify(playerData.characterSpec)) {
117 |             this.scene.remove(playerModel);
118 |             this.addPlayer(clientId, playerData);
119 |         } else {
120 |             playerModel.position.set(playerData.x, playerData.y || 0, playerData.z);
121 |             if (playerData.rotation) {
122 |                 const offset = playerModel.userData.isAnimatedGLB ? (playerModel.userData.rotationOffset || 0) : 0;
123 |                 playerModel.rotation.y = playerData.rotation - offset; 
124 |             }
125 |         }
126 | 
127 |         const leftLeg = playerModel.getObjectByName("leftLeg");
128 |         const rightLeg = playerModel.getObjectByName("rightLeg");
129 |         if (playerData.moving && leftLeg && rightLeg) {
130 |             const animPhase = performance.now() * 0.05;
131 |             leftLeg.rotation.x = Math.sin(animPhase) * 0.3;
132 |             rightLeg.rotation.x = Math.sin(animPhase + Math.PI) * 0.3;
133 |         } else if(leftLeg && rightLeg) {
134 |             leftLeg.rotation.x = 0;
135 |             rightLeg.rotation.x = 0;
136 |         }
137 |         
138 |         if (playerData.chat && this.chatMessages[clientId].lastTimestamp !== playerData.chat.timestamp) {
139 |             this.chatMessages[clientId].lastTimestamp = playerData.chat.timestamp;
140 |             this.displayChatMessage(clientId, playerData.chat.message);
141 |         }
142 | 
143 |         // Handle animation state for GLB models
144 |         if (playerModel.userData.isAnimatedGLB) {
145 |             const actions = playerModel.userData.actions;
146 |             const fadeDuration = playerModel.userData.animationFadeDuration || 0.5;
147 |             let newActionName = 'idle';
148 |             if (playerData.moving) {
149 |                 newActionName = playerData.running ? 'run' : 'walk';
150 |             }
151 | 
152 |             const currentActionName = playerModel.userData.currentAction || 'idle';
153 |             if (currentActionName !== newActionName) {
154 |                 const from = actions[currentActionName];
155 |                 const to = actions[newActionName];
156 |                 if (from && to) {
157 |                     from.fadeOut(fadeDuration);
158 |                     to.reset().fadeIn(fadeDuration).play();
159 |                 }
160 |                 playerModel.userData.currentAction = newActionName;
161 |             }
162 |         }
163 |     }
164 | 
165 |     displayChatMessage(clientId, message) {
166 |         const bubble = this.chatMessages[clientId];
167 |         bubble.textContent = message;
168 |         bubble.style.display = 'block';
169 |         bubble.style.opacity = '1';
170 |         bubble.classList.remove('fade-out');
171 | 
172 |         if (this.chatLogMessageHandler) {
173 |             const peerInfo = this.room.peers[clientId] || {};
174 |             const name = peerInfo.username || `Player${clientId.substring(0, 4)}`;
175 |             this.chatLogMessageHandler({ clientId, username: name, message });
176 |         }
177 |         
178 |         setTimeout(() => {
179 |             if (bubble) {
180 |                 const endHandler = () => {
181 |                     bubble.style.display = 'none';
182 |                     bubble.removeEventListener('transitionend', endHandler);
183 |                 };
184 |                 bubble.addEventListener('transitionend', endHandler, { once: true });
185 |                 bubble.classList.add('fade-out');
186 |             }
187 |         }, 5000);
188 |     }
189 | 
190 |     removePlayer(clientId) {
191 |         this.scene.remove(this.otherPlayers[clientId]);
192 |         delete this.otherPlayers[clientId];
193 |         
194 |         document.getElementById('game-container').removeChild(this.playerLabels[clientId]);
195 |         delete this.playerLabels[clientId];
196 | 
197 |         document.getElementById('game-container').removeChild(this.chatMessages[clientId]);
198 |         delete this.chatMessages[clientId];
199 |     }
200 |     
201 |     collectRemote(remoteId, remoteObject) {
202 |         this.collectedRemotes[remoteId] = true;
203 |         remoteObject.visible = false;
204 |         document.getElementById('useless-button').style.display = 'block';
205 |         
206 |         const updatedRemotes = { ...(this.room.roomState.collectedRemotes || {}) };
207 |         updatedRemotes[remoteId] = true;
208 |         this.room.updateRoomState({ collectedRemotes: updatedRemotes });
209 |         console.log("Remote collected! Useless button unlocked!");
210 |     }
211 | 
212 |     updatePlayerLabels() {
213 |         const playerModel = this.playerControls.getPlayerModel();
214 |         const time = performance.now() * 0.001;
215 | 
216 |         for (const clientId in this.otherPlayers) {
217 |             const model = this.otherPlayers[clientId];
218 |             const label = this.playerLabels[clientId];
219 |             const chatBubble = this.chatMessages[clientId];
220 |             if (model && model.userData.updateAnimations) {
221 |                 model.userData.updateAnimations(time);
222 |             }
223 |             if (label && model) {
224 |                 this.updateLabelPosition(model, label, chatBubble);
225 |             }
226 |         }
227 | 
228 |         const localChatBubble = this.chatMessages[this.room.clientId];
229 |         if (localChatBubble && playerModel) {
230 |             this.updateLabelPosition(playerModel, null, localChatBubble);
231 |         }
232 |     }
233 |     
234 |     updateLabelPosition(model, label, chatBubble) {
235 |         const screenPos = this._getScreenPosition(model.position);
236 |         if (screenPos) {
237 |             if (label) {
238 |                 label.style.left = `${screenPos.x}px`;
239 |                 label.style.top = `${screenPos.y - 20}px`;
240 |                 label.style.display = screenPos.visible ? 'block' : 'none';
241 |             }
242 |             if (chatBubble) {
243 |                 chatBubble.style.left = `${screenPos.x}px`;
244 |                 chatBubble.style.top = `${screenPos.y - 45}px`;
245 |                 if (chatBubble.textContent && screenPos.visible) {
246 |                     chatBubble.style.display = 'block';
247 |                 }
248 |             }
249 |         } else {
250 |             if (label) label.style.display = 'none';
251 |             if (chatBubble) chatBubble.style.display = 'none';
252 |         }
253 |     }
254 | 
255 |     _createPlayerLabelElement(clientId, username) {
256 |         const label = document.createElement('div');
257 |         label.className = 'player-name';
258 |         label.textContent = username;
259 |         document.getElementById('game-container').appendChild(label);
260 |         return label;
261 |     }
262 | 
263 |     _createChatMessageElement(clientId) {
264 |         const message = document.createElement('div');
265 |         message.className = 'chat-message';
266 |         message.style.display = 'none';
267 |         document.getElementById('game-container').appendChild(message);
268 |         return message;
269 |     }
270 | 
271 |     _getScreenPosition(position) {
272 |         const vector = new THREE.Vector3();
273 |         vector.copy(position);
274 |         vector.y += 1.5;
275 |         vector.project(this.camera);
276 | 
277 |         const widthHalf = this.renderer.domElement.width / 2;
278 |         const heightHalf = this.renderer.domElement.height / 2;
279 | 
280 |         return {
281 |             x: (vector.x * widthHalf) + widthHalf,
282 |             y: -(vector.y * heightHalf) + heightHalf,
283 |             visible: vector.z < 1
284 |         };
285 |     }
286 | }


--------------------------------------------------------------------------------
/js/npc/NPC.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import {
  3 |     NPC_SPEED,
  4 |     MIN_WANDER_WAIT_SECONDS,
  5 |     MAX_WANDER_WAIT_SECONDS,
  6 |     WANDER_RADIUS,
  7 |     POST_INTERACTION_IDLE_SECONDS,
  8 |     EYEBOT_HEIGHT_VARIATION,
  9 |     MIN_FLY_HEIGHT
 10 | } from './constants.js';
 11 | 
 12 | export class NPC {
 13 |     constructor(model, presetId, zoneKey, isEyebot, startPosition, terrain) {
 14 |         this.model = model;
 15 |         this.presetId = presetId;
 16 |         this.zoneKey = zoneKey;
 17 |         this.isEyebot = isEyebot;
 18 |         this.startPosition = startPosition;
 19 |         this.terrain = terrain;
 20 | 
 21 |         this.state = 'idle';
 22 |         this.targetPosition = null;
 23 |         this.idleTimer = 0;
 24 |         this.velocity = new THREE.Vector3();
 25 | 
 26 |         if (isEyebot) {
 27 |             this.model.userData.baseY = startPosition.y;
 28 |         }
 29 | 
 30 |         this.setIdle();
 31 |     }
 32 | 
 33 |     setIdle(durationSeconds = null) {
 34 |         this.state = 'idle';
 35 |         if (durationSeconds === null) {
 36 |             this.idleTimer = (MIN_WANDER_WAIT_SECONDS + Math.random() * (MAX_WANDER_WAIT_SECONDS - MIN_WANDER_WAIT_SECONDS)) * 1000;
 37 |         } else {
 38 |             this.idleTimer = durationSeconds * 1000;
 39 |         }
 40 |         this.targetPosition = null;
 41 |     }
 42 | 
 43 |     setInteracting(isInteracting) {
 44 |         if (isInteracting) {
 45 |             this.state = 'interacting';
 46 |         } else {
 47 |             this.setIdle(POST_INTERACTION_IDLE_SECONDS);
 48 |         }
 49 |     }
 50 | 
 51 |     setNewWanderTarget() {
 52 |         const angle = Math.random() * Math.PI * 2;
 53 |         const distance = Math.random() * WANDER_RADIUS;
 54 |         
 55 |         const targetX = this.startPosition.x + Math.cos(angle) * distance;
 56 |         const targetZ = this.startPosition.z + Math.sin(angle) * distance;
 57 |         let targetY;
 58 | 
 59 |         if (this.isEyebot) {
 60 |             const terrainHeight = this.terrain.userData.getHeight(targetX, targetZ);
 61 |             targetY = this.startPosition.y + (Math.random() - 0.5) * EYEBOT_HEIGHT_VARIATION;
 62 |             targetY = Math.max(terrainHeight + MIN_FLY_HEIGHT, targetY);
 63 |         } else {
 64 |             targetY = this.model.position.y;
 65 |         }
 66 | 
 67 |         this.targetPosition = new THREE.Vector3(targetX, targetY, targetZ);
 68 |         this.state = 'wandering';
 69 |     }
 70 | 
 71 |     update(delta, isVisible, playerModel) {
 72 |         if (!isVisible) return;
 73 | 
 74 |         let isMoving = false;
 75 | 
 76 |         if (this.state === 'interacting') {
 77 |             this.updateAnimation(false, true, isVisible);
 78 |             return;
 79 |         }
 80 | 
 81 |         if (this.state === 'idle') {
 82 |             this.idleTimer -= delta;
 83 |             if (this.idleTimer <= 0) {
 84 |                 this.setNewWanderTarget();
 85 |             }
 86 |             isMoving = false;
 87 |         } else if (this.state === 'wandering') {
 88 |             isMoving = true;
 89 |             if (!this.targetPosition) {
 90 |                 this.setNewWanderTarget();
 91 |                 return;
 92 |             }
 93 | 
 94 |             const direction = this.targetPosition.clone().sub(this.model.position);
 95 | 
 96 |             if (!this.isEyebot) {
 97 |                 direction.y = 0;
 98 |             }
 99 | 
100 |             if (direction.length() < 1) { // Reached target
101 |                 this.setIdle();
102 |                 return;
103 |             }
104 | 
105 |             direction.normalize();
106 |             
107 |             const step = direction.clone().multiplyScalar(NPC_SPEED);
108 |             const newPos = this.model.position.clone().add(step);
109 |             
110 |             let collision = false;
111 |             if (playerModel) {
112 |                 const playerPosition = playerModel.position;
113 |                 /* @tweakable The effective collision radius for an NPC for NPC-player collision. */
114 |                 const npcCollisionRadius = 0.5;
115 |                 /* @tweakable The effective collision radius for the player for NPC-player collision. */
116 |                 const playerCollisionRadius = 0.5;
117 |                 const minDistance = npcCollisionRadius + playerCollisionRadius;
118 |                 
119 |                 const npcPos2D = new THREE.Vector2(newPos.x, newPos.z);
120 |                 const playerPos2D = new THREE.Vector2(playerPosition.x, playerPosition.z);
121 |                 
122 |                 if (npcPos2D.distanceTo(playerPos2D) < minDistance) {
123 |                     collision = true;
124 |                 }
125 |             }
126 |             
127 |             if (collision) {
128 |                 isMoving = false; // NPC stops moving
129 |             } else {
130 |                 // No collision, update position
131 |                 if (this.isEyebot) {
132 |                     this.model.position.copy(newPos);
133 |                     this.model.userData.baseY = newPos.y;
134 |                 } else {
135 |                     const terrainHeight = this.terrain.userData.getHeight(newPos.x, newPos.z) + 0.2;
136 |                     this.model.position.set(newPos.x, terrainHeight, newPos.z);
137 |                 }
138 |                 
139 |                 if (!this.isEyebot) {
140 |                     const angle = Math.atan2(direction.x, direction.z);
141 |                     this.model.rotation.y = angle;
142 |                 }
143 |             }
144 |         }
145 |         
146 |         this.updateAnimation(isMoving, false, isVisible);
147 | 
148 |         if (isVisible && this.model.userData.updateAnimations) {
149 |             this.model.userData.updateAnimations(performance.now() * 0.001);
150 |         }
151 |     }
152 | 
153 |     updateAnimation(isMoving, isInteracting = false, isVisible = true) {
154 |         if (this.isEyebot) {
155 |             return;
156 |         }
157 |         const leftLeg = this.model.getObjectByName("leftLeg");
158 |         const rightLeg = this.model.getObjectByName("rightLeg");
159 |         
160 |         if (leftLeg && rightLeg) {
161 |             if (isMoving) {
162 |               const walkSpeed = 5;
163 |               const walkAmplitude = 0.3;
164 |               leftLeg.rotation.x = Math.sin(performance.now() * 0.01 * walkSpeed) * walkAmplitude;
165 |               rightLeg.rotation.x = Math.sin(performance.now() * 0.01 * walkSpeed + Math.PI) * walkAmplitude;
166 |             } else {
167 |               leftLeg.rotation.x = 0;
168 |               rightLeg.rotation.x = 0;
169 |             }
170 |         }
171 |         
172 |         if (this.model.userData.isAnimatedGLB) {
173 |             const actions = this.model.userData.actions;
174 |             const fadeDuration = this.model.userData.animationFadeDuration || 0.5;
175 |             
176 |             let newActionName = 'idle';
177 |             if (isInteracting && actions.listen) {
178 |                 newActionName = 'listen';
179 |             } else if (isMoving) {
180 |                 newActionName = 'walk';
181 |             }
182 |             
183 |             let currentActionName = this.model.userData.currentAction || 'idle';
184 |             
185 |             if (currentActionName !== newActionName) {
186 |                 const from = actions[currentActionName];
187 |                 const to = actions[newActionName];
188 |                 if(from && to) {
189 |                     from.fadeOut(fadeDuration);
190 |                     to.reset().fadeIn(fadeDuration).play();
191 |                 } else if(to) { // if from is null
192 |                     to.reset().fadeIn(fadeDuration).play();
193 |                 }
194 |                 this.model.userData.currentAction = newActionName;
195 |             }
196 |         }
197 |         
198 |         if (isVisible && this.model.userData.mixer) {
199 |             const delta = (performance.now() - (this.model.userData.lastMixerUpdate || performance.now())) / 1000;
200 |             this.model.userData.mixer.update(delta);
201 |             this.model.userData.lastMixerUpdate = performance.now();
202 |         }
203 |     }
204 | }


--------------------------------------------------------------------------------
/js/npc/NPCSpawner.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { createPlayerModel } from '../playerModel.js';
  3 | import { setupAnimatedRobot, setupEyebot, setupAnimatedChicken, setupAnimatedWireframe, setupAnimatedAlien } from '../animationSetup.js';
  4 | import { presetCharacters } from '../characters/presets.js';
  5 | import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';
  6 | import { NPC } from './NPC.js';
  7 | import {
  8 |     USE_BOUNDING_BOX_CULLING,
  9 |     ROBOT_SPAWN_CHANCE,
 10 |     EYEBOT_SPAWN_CHANCE,
 11 |     NPC_ADJECTIVES,
 12 |     MIN_NPCS_PER_ZONE,
 13 |     MAX_NPCS_PER_ZONE,
 14 |     ROBOT_NPC_SCALE,
 15 |     CHICKEN_NPC_SCALE,
 16 |     WIREFRAME_NPC_SCALE,
 17 |     ALIEN_NPC_SCALE,
 18 |     EYEBOT_NPC_SCALE,
 19 |     EYEBOT_FLY_HEIGHT,
 20 |     FIX_FRUSTUM_CULLING_BUG
 21 | } from './constants.js';
 22 | import { ZONE_SIZE } from '../worldGeneration.js';
 23 | 
 24 | 
 25 | export class NPCSpawner {
 26 |     constructor(scene, terrain) {
 27 |         this.scene = scene;
 28 |         this.terrain = terrain;
 29 |         this.animatedData = {};
 30 |     }
 31 |     
 32 |     setAnimatedData(type, data) {
 33 |         if (data.model && type === 'robot' && FIX_FRUSTUM_CULLING_BUG) {
 34 |              data.model.traverse(c => {
 35 |                 if (c.type === 'Object3D' && !c.isGroup) {
 36 |                     c.isGroup = true;
 37 |                 }
 38 |             });
 39 |         }
 40 |         
 41 |         if (data.model && type === 'robot' && USE_BOUNDING_BOX_CULLING) {
 42 |             data.model.userData.boundingBox = new THREE.Box3().setFromObject(data.model);
 43 |         }
 44 |         
 45 |         this.animatedData[type] = data;
 46 |     }
 47 | 
 48 |     spawnNpcsForZone(zoneKey) {
 49 |         const [zoneGridX, zoneGridZ] = zoneKey.split(',').map(Number);
 50 |         const numNpcs = MIN_NPCS_PER_ZONE + Math.floor(Math.random() * (MAX_NPCS_PER_ZONE - MIN_NPCS_PER_ZONE + 1));
 51 |         const zoneNpcs = [];
 52 | 
 53 |         for (let i = 0; i < numNpcs; i++) {
 54 |             let npcModel;
 55 |             let adjective = NPC_ADJECTIVES[Math.floor(Math.random() * NPC_ADJECTIVES.length)];
 56 |             let preset;
 57 |             let isEyebot = false;
 58 | 
 59 |             if (this.animatedData.eyebot && Math.random() < EYEBOT_SPAWN_CHANCE) {
 60 |                 const eyebotData = this.animatedData.eyebot;
 61 |                 npcModel = eyebotData.model.clone();
 62 |                 isEyebot = true;
 63 |                 eyebotData.setupFn(npcModel);
 64 |                 npcModel.name = `${adjective} Eyebot`;
 65 |                 npcModel.traverse(c => { c.castShadow = true; });
 66 |                 npcModel.scale.set(EYEBOT_NPC_SCALE, EYEBOT_NPC_SCALE, EYEBOT_NPC_SCALE);
 67 |                 preset = { id: 'eyebot' };
 68 |             }
 69 |             else if (this.animatedData.robot && Math.random() < ROBOT_SPAWN_CHANCE) {
 70 |                 preset = presetCharacters.find(p => p.id === 'robots');
 71 |                 const robotData = this.animatedData.robot;
 72 |                 npcModel = SkeletonUtils.clone(robotData.model);
 73 | 
 74 |                 if (USE_BOUNDING_BOX_CULLING && robotData.model.userData.boundingBox) {
 75 |                     npcModel.userData.boundingBox = new THREE.Box3().setFromObject(npcModel);
 76 |                 }
 77 | 
 78 |                 robotData.setupFn(npcModel, robotData.idleClip, robotData.walkClip, robotData.listenClip);
 79 |                 npcModel.name = `${adjective} Robot`;
 80 |                 npcModel.traverse(c => { c.castShadow = true; });
 81 |                 npcModel.scale.set(ROBOT_NPC_SCALE, ROBOT_NPC_SCALE, ROBOT_NPC_SCALE);
 82 |             } else if (this.animatedData.wireframe && Math.random() < ROBOT_SPAWN_CHANCE) {
 83 |                 preset = presetCharacters.find(p => p.id === 'wireframe');
 84 |                 const wireframeData = this.animatedData.wireframe;
 85 |                 npcModel = SkeletonUtils.clone(wireframeData.model);
 86 |                 wireframeData.setupFn(npcModel, wireframeData.idleClip, wireframeData.walkClip, wireframeData.runClip, wireframeData.listenClip);
 87 |                 npcModel.name = `${adjective} Wireframe`;
 88 |                 npcModel.traverse(c => { c.castShadow = true; });
 89 |                 npcModel.scale.set(WIREFRAME_NPC_SCALE, WIREFRAME_NPC_SCALE, WIREFRAME_NPC_SCALE);
 90 |             } else if (this.animatedData.alien && Math.random() < ROBOT_SPAWN_CHANCE) {
 91 |                 preset = presetCharacters.find(p => p.id === 'alien');
 92 |                 const alienData = this.animatedData.alien;
 93 |                 npcModel = SkeletonUtils.clone(alienData.model);
 94 |                 alienData.setupFn(npcModel, alienData.idleClip, alienData.walkClip, alienData.runClip, alienData.listenClip);
 95 |                 npcModel.name = `${adjective} Alien`;
 96 |                 npcModel.traverse(c => { c.castShadow = true; });
 97 |                 npcModel.scale.set(ALIEN_NPC_SCALE, ALIEN_NPC_SCALE, ALIEN_NPC_SCALE);
 98 |             } else if (this.animatedData.chicken && Math.random() < ROBOT_SPAWN_CHANCE) {
 99 |                 preset = presetCharacters.find(p => p.id === 'chicken');
100 |                 const chickenData = this.animatedData.chicken;
101 |                 npcModel = SkeletonUtils.clone(chickenData.model);
102 |                 chickenData.setupFn(npcModel, chickenData.idleClip, chickenData.walkClip, chickenData.runClip, chickenData.alertClip, chickenData.listenClip);
103 |                 npcModel.name = `${adjective} Chicken`;
104 |                 npcModel.traverse(c => { c.castShadow = true; });
105 |                 npcModel.scale.set(CHICKEN_NPC_SCALE, CHICKEN_NPC_SCALE, CHICKEN_NPC_SCALE);
106 |             }
107 |             else {
108 |                 let availablePresets = presetCharacters;
109 |                 if (this.animatedData.robot) {
110 |                     availablePresets = availablePresets.filter(p => p.id !== 'robots');
111 |                 }
112 |                  if (this.animatedData.chicken) {
113 |                     availablePresets = availablePresets.filter(p => p.id !== 'chicken');
114 |                 }
115 |                 if (this.animatedData.wireframe) {
116 |                     availablePresets = availablePresets.filter(p => p.id !== 'wireframe');
117 |                 }
118 |                 if (this.animatedData.alien) {
119 |                     availablePresets = availablePresets.filter(p => p.id !== 'alien');
120 |                 }
121 |                 if(availablePresets.length === 0) availablePresets = presetCharacters; // Fallback
122 |                 
123 |                 preset = availablePresets[Math.floor(Math.random() * availablePresets.length)];
124 |                 const uniqueId = `${preset.name}_${zoneKey}_${i}`;
125 |                 npcModel = createPlayerModel(THREE, uniqueId, preset.spec);
126 |                 npcModel.name = `${adjective} ${preset.name}`;
127 |             }
128 | 
129 |             npcModel.userData.isNpc = true;
130 | 
131 |             const zoneCenterX = zoneGridX * ZONE_SIZE;
132 |             const zoneCenterZ = zoneGridZ * ZONE_SIZE;
133 |             
134 |             const offsetX = (Math.random() - 0.5) * ZONE_SIZE;
135 |             const offsetZ = (Math.random() - 0.5) * ZONE_SIZE;
136 |             
137 |             const startX = zoneCenterX + offsetX;
138 |             const startZ = zoneCenterZ + offsetZ;
139 |             const startY = this.terrain.userData.getHeight(startX, startZ) + (isEyebot ? EYEBOT_FLY_HEIGHT : 0.2);
140 | 
141 |             npcModel.position.set(startX, startY, startZ);
142 | 
143 |             if (isEyebot) {
144 |                 npcModel.userData.baseY = startY;
145 |             }
146 | 
147 |             this.scene.add(npcModel);
148 | 
149 |             const npc = new NPC(
150 |                 npcModel,
151 |                 preset.id,
152 |                 zoneKey,
153 |                 isEyebot,
154 |                 npcModel.position.clone(),
155 |                 this.terrain
156 |             );
157 |             
158 |             zoneNpcs.push(npc);
159 |         }
160 |         
161 |         return zoneNpcs;
162 |     }
163 | 
164 |     replaceNpcModels(npcType) {
165 |         if (!this.animatedData[npcType]) return;
166 | 
167 |         const allNpcData = [...this.scene.children.filter(c => c.userData.isNpcInstance)];
168 |         
169 |         allNpcData.forEach(npc => {
170 |             if (npc.presetId !== npcType) return;
171 | 
172 |             this.scene.remove(npc.model);
173 | 
174 |             let newModel;
175 |             if (npcType === 'eyebot') {
176 |                 newModel = this.animatedData.eyebot.model.clone();
177 |                 setupEyebot(newModel);
178 |             } else {
179 |                 newModel = SkeletonUtils.clone(this.animatedData[npcType].model);
180 |                 if (npcType === 'robot') {
181 |                     if (USE_BOUNDING_BOX_CULLING && this.animatedData.robot.model.userData.boundingBox) {
182 |                         newModel.userData.boundingBox = new THREE.Box3().setFromObject(newModel);
183 |                     }
184 |                     setupAnimatedRobot(newModel, this.animatedData.robot.idleClip, this.animatedData.robot.walkClip, this.animatedData.robot.listenClip);
185 |                 } else if (npcType === 'chicken') {
186 |                      setupAnimatedChicken(newModel, this.animatedData.chicken.idleClip, this.animatedData.chicken.walkClip, this.animatedData.chicken.runClip, this.animatedData.chicken.alertClip, this.animatedData.chicken.listenClip);
187 |                 } else if (npcType === 'wireframe') {
188 |                     setupAnimatedWireframe(newModel, this.animatedData.wireframe.idleClip, this.animatedData.wireframe.walkClip, this.animatedData.wireframe.runClip, this.animatedData.wireframe.listenClip);
189 |                 } else if (npcType === 'alien') {
190 |                     setupAnimatedAlien(newModel, this.animatedData.alien.idleClip, this.animatedData.alien.walkClip, this.animatedData.alien.runClip, this.animatedData.alien.listenClip);
191 |                 }
192 |             }
193 |             
194 |             const adjective = NPC_ADJECTIVES[Math.floor(Math.random() * NPC_ADJECTIVES.length)];
195 |             
196 |             let scale;
197 |             switch(npcType) {
198 |                 case 'robot': newModel.name = `${adjective} Robot`; scale = ROBOT_NPC_SCALE; break;
199 |                 case 'eyebot': newModel.name = `${adjective} Eyebot`; scale = EYEBOT_NPC_SCALE; break;
200 |                 case 'chicken': newModel.name = `${adjective} Chicken`; scale = CHICKEN_NPC_SCALE; break;
201 |                 case 'wireframe': newModel.name = `${adjective} Wireframe`; scale = WIREFRAME_NPC_SCALE; break;
202 |                 case 'alien': newModel.name = `${adjective} Alien`; scale = ALIEN_NPC_SCALE; break;
203 |             }
204 | 
205 |             newModel.traverse(c => { c.castShadow = true; });
206 |             newModel.scale.set(scale, scale, scale);
207 | 
208 |             newModel.position.copy(npc.model.position);
209 |             npc.model = newModel;
210 |             
211 |             this.scene.add(newModel);
212 |         });
213 |     }
214 | }


--------------------------------------------------------------------------------
/js/npc/ZoneManager.js:
--------------------------------------------------------------------------------
 1 | import { ACTIVE_ZONE_RADIUS } from './constants.js';
 2 | import { ZONE_SIZE } from '../worldGeneration.js';
 3 | 
 4 | export class ZoneManager {
 5 |     constructor(playerControls, onActivate, onDeactivate) {
 6 |         this.playerControls = playerControls;
 7 |         this.onActivate = onActivate;
 8 |         this.onDeactivate = onDeactivate;
 9 | 
10 |         this.activeZones = new Set();
11 |         this.playerZoneKey = null;
12 |     }
13 | 
14 |     _getZoneKey(position) {
15 |         const x = Math.floor((position.x + ZONE_SIZE / 2) / ZONE_SIZE);
16 |         const z = Math.floor((position.z + ZONE_SIZE / 2) / ZONE_SIZE);
17 |         return `${x},${z}`;
18 |     }
19 | 
20 |     update() {
21 |         const playerPos = this.playerControls.getPlayerModel().position;
22 |         const currentZoneKey = this._getZoneKey(playerPos);
23 | 
24 |         if (currentZoneKey === this.playerZoneKey) {
25 |             return; // No change in zone
26 |         }
27 |         this.playerZoneKey = currentZoneKey;
28 | 
29 |         const [zoneX, zoneZ] = currentZoneKey.split(',').map(Number);
30 |         const newActiveZones = new Set();
31 | 
32 |         for (let x = zoneX - ACTIVE_ZONE_RADIUS; x <= zoneX + ACTIVE_ZONE_RADIUS; x++) {
33 |             for (let z = zoneZ - ACTIVE_ZONE_RADIUS; z <= zoneZ + ACTIVE_ZONE_RADIUS; z++) {
34 |                 newActiveZones.add(`${x},${z}`);
35 |             }
36 |         }
37 | 
38 |         const zonesToDeactivate = [...this.activeZones].filter(zone => !newActiveZones.has(zone));
39 |         const zonesToActivate = [...newActiveZones].filter(zone => !this.activeZones.has(zone));
40 | 
41 |         zonesToDeactivate.forEach(zoneKey => this.onDeactivate(zoneKey));
42 |         zonesToActivate.forEach(zoneKey => this.onActivate(zoneKey));
43 | 
44 |         this.activeZones = newActiveZones;
45 |     }
46 | 
47 |     reset() {
48 |         this.playerZoneKey = null;
49 |         this.activeZones.clear();
50 |     }
51 | }


--------------------------------------------------------------------------------
/js/npc/constants.js:
--------------------------------------------------------------------------------
 1 | /* @tweakable A flag to enable a workaround for a Three.js bug related to frustum culling. Disable this if you upgrade Three.js to a version higher than r160. */
 2 | export const FIX_FRUSTUM_CULLING_BUG = true;
 3 | /* @tweakable Use bounding box for frustum culling on complex models. May improve performance and fix crashes. Set to false for debugging culling issues. */
 4 | export const USE_BOUNDING_BOX_CULLING = true;
 5 | /* @tweakable NPC movement speed. */
 6 | export const NPC_SPEED = 0.03;
 7 | /* @tweakable How far the NPC wanders from its initial spawn point. */
 8 | export const WANDER_RADIUS = 20;
 9 | /* @tweakable Minimum time in seconds the NPC waits before wandering to a new spot. */
10 | export const MIN_WANDER_WAIT_SECONDS = 5;
11 | /* @tweakable Maximum time in seconds the NPC waits before wandering to a new spot. */
12 | export const MAX_WANDER_WAIT_SECONDS = 15;
13 | /* @tweakable The chance (from 0 to 1) that a spawned NPC will be a robot when animated robots are enabled. */
14 | export const ROBOT_SPAWN_CHANCE = 0.25;
15 | /* @tweakable The chance (from 0 to 1) that a spawned NPC will be an eyebot when eyebots are enabled. */
16 | export const EYEBOT_SPAWN_CHANCE = 0.35;
17 | /* @tweakable Adjectives to describe NPCs. An adjective is randomly picked from this list. */
18 | export const NPC_ADJECTIVES = ["Wandering", "Mysterious", "Lost", "Curious", "Silent", "Ancient", "Jolly", "Grumpy"];
19 | /* @tweakable Min NPCs per zone. */
20 | export const MIN_NPCS_PER_ZONE = 1;
21 | /* @tweakable Max NPCs per zone. This has a large impact on performance. */
22 | export const MAX_NPCS_PER_ZONE = 4;
23 | /* @tweakable Radius of active zones around player (in zones). 1 = 3x3 grid. A lower number improves performance by having fewer active NPCs. */
24 | export const ACTIVE_ZONE_RADIUS = 1;
25 | /* @tweakable When an NPC is being interacted with, this is how long they will remain idle after the conversation ends. */
26 | export const POST_INTERACTION_IDLE_SECONDS = 5;
27 | /* @tweakable The scale of the animated robot NPCs. */
28 | export const ROBOT_NPC_SCALE = 0.3;
29 | /* @tweakable The scale of the animated chicken NPCs. */
30 | export const CHICKEN_NPC_SCALE = 1.0;
31 | /* @tweakable The scale of the animated wireframe NPCs. */
32 | export const WIREFRAME_NPC_SCALE = 0.8;
33 | /* @tweakable The scale of the animated alien NPCs. */
34 | export const ALIEN_NPC_SCALE = 1.0;
35 | /* @tweakable The scale of the eyebot NPCs. */
36 | export const EYEBOT_NPC_SCALE = 0.5;
37 | /* @tweakable Base height of eyebots above terrain. */
38 | export const EYEBOT_FLY_HEIGHT = 2.0;
39 | /* @tweakable Variation in eyebot flying height when wandering. */
40 | export const EYEBOT_HEIGHT_VARIATION = 3.0;
41 | /* @tweakable Minimum height for eyebots above terrain */
42 | export const MIN_FLY_HEIGHT = 1.5;


--------------------------------------------------------------------------------
/js/npcManager.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import * as SkeletonUtils from 'three/addons/utils/SkeletonUtils.js';
  3 | import { ZoneManager } from './npc/ZoneManager.js';
  4 | import { NPCSpawner } from './npc/NPCSpawner.js';
  5 | import {
  6 |     USE_BOUNDING_BOX_CULLING,
  7 | } from './npc/constants.js';
  8 | 
  9 | export class NPCManager {
 10 |     constructor(scene, terrain, playerControls) {
 11 |         this.scene = scene;
 12 |         this.terrain = terrain;
 13 |         this.playerControls = playerControls;
 14 |         this.npcs = [];
 15 |         this.lastUpdateTime = 0;
 16 |         
 17 |         // Spawner is initialized later, once terrain is available
 18 |         this.npcSpawner = null;
 19 |         this.zoneManager = new ZoneManager(
 20 |             playerControls,
 21 |             (zoneKey) => this.activateZone(zoneKey),
 22 |             (zoneKey) => this.deactivateZone(zoneKey)
 23 |         );
 24 | 
 25 |         this.frustum = new THREE.Frustum();
 26 |         this.cameraMatrix = new THREE.Matrix4();
 27 |         this.zoneCache = new Map();
 28 |     }
 29 | 
 30 |     initializeSpawner(terrain) {
 31 |         this.terrain = terrain;
 32 |         this.npcSpawner = new NPCSpawner(this.scene, this.terrain);
 33 |     }
 34 | 
 35 |     addNpc(npc) {
 36 |         this.npcs.push(npc);
 37 |         this.scene.add(npc.model);
 38 |     }
 39 | 
 40 |     useAnimatedRobots(data, replaceExisting = true) {
 41 |         this.npcSpawner.setAnimatedData('robot', data);
 42 |         if (replaceExisting) {
 43 |             this.npcSpawner.replaceNpcModels('robot');
 44 |         }
 45 |     }
 46 | 
 47 |     useEyebotModels(data, replaceExisting = true) {
 48 |         this.npcSpawner.setAnimatedData('eyebot', data);
 49 |         if (replaceExisting) {
 50 |             this.npcSpawner.replaceNpcModels('eyebot');
 51 |         }
 52 |     }
 53 | 
 54 |     useAnimatedWireframes(data, replaceExisting = true) {
 55 |         this.npcSpawner.setAnimatedData('wireframe', data);
 56 |         if (replaceExisting) {
 57 |             this.npcSpawner.replaceNpcModels('wireframe');
 58 |         }
 59 |     }
 60 | 
 61 |     useAnimatedAliens(data, replaceExisting = true) {
 62 |         this.npcSpawner.setAnimatedData('alien', data);
 63 |         if (replaceExisting) {
 64 |             this.npcSpawner.replaceNpcModels('alien');
 65 |         }
 66 |     }
 67 | 
 68 |     useAnimatedChickens(data, replaceExisting = true) {
 69 |         this.npcSpawner.setAnimatedData('chicken', data);
 70 |         if (replaceExisting) {
 71 |             this.npcSpawner.replaceNpcModels('chicken');
 72 |         }
 73 |     }
 74 | 
 75 |     activateZone(zoneKey) {
 76 |         if (!this.npcSpawner) return; // Don't spawn if spawner isn't ready
 77 | 
 78 |         if (this.zoneCache.has(zoneKey)) {
 79 |             const cachedNpcs = this.zoneCache.get(zoneKey);
 80 |             cachedNpcs.forEach(npc => {
 81 |                 this.scene.add(npc.model);
 82 |                 this.npcs.push(npc);
 83 |             });
 84 |         } else {
 85 |             const newNpcs = this.npcSpawner.spawnNpcsForZone(zoneKey);
 86 |             this.npcs.push(...newNpcs);
 87 |             this.zoneCache.set(zoneKey, newNpcs);
 88 |         }
 89 |     }
 90 | 
 91 |     deactivateZone(zoneKey) {
 92 |         const npcsInZone = this.npcs.filter(npc => npc.zoneKey === zoneKey);
 93 |         npcsInZone.forEach(npc => {
 94 |             this.scene.remove(npc.model);
 95 |         });
 96 |         this.npcs = this.npcs.filter(npc => npc.zoneKey !== zoneKey);
 97 |     }
 98 |     
 99 |     updatePlayerModel(newSpec, forceRespawn = false) {
100 |         this.npcs.forEach(npc => this.scene.remove(npc.model));
101 |         this.npcs = [];
102 |         this.zoneCache.clear();
103 |         if (forceRespawn) {
104 |             this.zoneManager.reset();
105 |         }
106 |         this.zoneManager.update();
107 |     }
108 |     
109 |     setInteracting(npc, isInteracting) {
110 |         if (!npc) return;
111 |         npc.setInteracting(isInteracting);
112 |     }
113 | 
114 |     update() {
115 |         this.zoneManager.update();
116 | 
117 |         const now = performance.now();
118 |         const delta = now - (this.lastUpdateTime || now);
119 |         this.lastUpdateTime = now;
120 |         
121 |         this.cameraMatrix.multiplyMatrices(this.playerControls.camera.projectionMatrix, this.playerControls.camera.matrixWorldInverse);
122 |         this.frustum.setFromProjectionMatrix(this.cameraMatrix);
123 | 
124 |         const playerModel = this.playerControls.getPlayerModel();
125 | 
126 |         this.npcs.forEach(npc => {
127 |             if (!npc || !npc.model) return;
128 | 
129 |             let isVisible;
130 |             const model = npc.model;
131 | 
132 |             if (USE_BOUNDING_BOX_CULLING && model.userData.boundingBox) {
133 |                 const tempBox = model.userData.boundingBox.clone();
134 |                 tempBox.applyMatrix4(model.matrixWorld);
135 |                 isVisible = this.frustum.intersectsBox(tempBox);
136 |             } else {
137 |                 if (model.geometry) {
138 |                     isVisible = this.frustum.intersectsObject(model);
139 |                 } else if (model.isGroup) {
140 |                     isVisible = true; 
141 |                 } else {
142 |                     isVisible = false;
143 |                 }
144 |             }
145 |             
146 |             npc.update(delta, isVisible, playerModel);
147 |         });
148 |     }
149 | }


--------------------------------------------------------------------------------
/js/objectCreator.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | 
  3 | export class ObjectCreator {
  4 |     constructor(scene, camera, room, buildTool) {
  5 |         this.scene = scene;
  6 |         this.camera = camera;
  7 |         this.room = room;
  8 |         this.buildTool = buildTool;
  9 | 
 10 |         this.objectLibrary = [
 11 |             { name: 'Box', geometry: 'BoxGeometry', params: [1, 1, 1] },
 12 |             { name: 'Sphere', geometry: 'SphereGeometry', params: [0.5, 16, 16] },
 13 |             { name: 'Cylinder', geometry: 'CylinderGeometry', params: [0.5, 0.5, 1, 16] },
 14 |             { name: 'Cone', geometry: 'ConeGeometry', params: [0.5, 1, 16] },
 15 |             { name: 'Torus', geometry: 'TorusGeometry', params: [0.5, 0.2, 16, 32] },
 16 |             { name: 'Pyramid', geometry: 'ConeGeometry', params: [0.5, 1, 4] }
 17 |         ];
 18 |     }
 19 | 
 20 |     createObject(objectType) {
 21 |         const objectDef = this.objectLibrary.find(obj => obj.name === objectType);
 22 |         if (!objectDef) return null;
 23 | 
 24 |         const geometry = new THREE[objectDef.geometry](...objectDef.params);
 25 |         const materialIndex = this.buildTool.previewManager.getCurrentMaterialIndex();
 26 |         const material = this.buildTool.buildMaterials[materialIndex].clone();
 27 |         const mesh = new THREE.Mesh(geometry, material);
 28 | 
 29 |         mesh.castShadow = true;
 30 |         mesh.receiveShadow = true;
 31 |         mesh.userData.isBarrier = true;
 32 | 
 33 |         const distance = 5;
 34 |         const vector = new THREE.Vector3(0, 0, -distance);
 35 |         vector.applyQuaternion(this.camera.quaternion);
 36 |         vector.add(this.camera.position);
 37 |         mesh.position.copy(vector);
 38 | 
 39 |         if (this.buildTool.isLocationOccupiedByPlayer(mesh.position)) return null;
 40 | 
 41 |         const objectId = 'adv_build_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
 42 |         mesh.userData.id = objectId;
 43 |         mesh.userData.createdAt = Date.now();
 44 |         this.scene.add(mesh);
 45 |         
 46 |         this.syncObjectWithRoom(mesh, true);
 47 |         return mesh;
 48 |     }
 49 | 
 50 |     duplicateObject(objectToDuplicate) {
 51 |         const geometry = objectToDuplicate.geometry.clone();
 52 |         const material = objectToDuplicate.material.clone();
 53 |         const duplicatedObject = new THREE.Mesh(geometry, material);
 54 | 
 55 |         duplicatedObject.position.copy(objectToDuplicate.position).add(new THREE.Vector3(0.5, 0, 0.5));
 56 |         duplicatedObject.rotation.copy(objectToDuplicate.rotation);
 57 |         duplicatedObject.scale.copy(objectToDuplicate.scale);
 58 | 
 59 |         if (this.buildTool.isLocationOccupiedByPlayer(duplicatedObject.position)) return null;
 60 | 
 61 |         duplicatedObject.castShadow = true;
 62 |         duplicatedObject.receiveShadow = true;
 63 |         duplicatedObject.userData.isBarrier = true;
 64 | 
 65 |         const objectId = 'adv_build_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
 66 |         duplicatedObject.userData.id = objectId;
 67 |         duplicatedObject.userData.createdAt = Date.now();
 68 |         
 69 |         this.scene.add(duplicatedObject);
 70 |         this.syncObjectWithRoom(duplicatedObject, true);
 71 | 
 72 |         return duplicatedObject;
 73 |     }
 74 | 
 75 |     createFromData(buildData) {
 76 |         let geometry;
 77 |         switch (buildData.geometryType) {
 78 |             case 'BoxGeometry': geometry = new THREE.BoxGeometry(1, 1, 1); break;
 79 |             case 'SphereGeometry': geometry = new THREE.SphereGeometry(0.5, 16, 16); break;
 80 |             case 'CylinderGeometry': geometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 16); break;
 81 |             case 'ConeGeometry': geometry = new THREE.ConeGeometry(0.5, 1, 16); break;
 82 |             case 'TorusGeometry': geometry = new THREE.TorusGeometry(0.5, 0.2, 16, 32); break;
 83 |             case 'Pyramid': geometry = new THREE.ConeGeometry(0.5, 1, 4); break;
 84 |             default: geometry = new THREE.BoxGeometry(1, 1, 1);
 85 |         }
 86 | 
 87 |         const materialIndex = Math.min(buildData.materialIndex || 0, this.buildTool.buildMaterials.length - 1);
 88 |         const material = this.buildTool.buildMaterials[materialIndex].clone();
 89 |         
 90 |         if (buildData.color) {
 91 |             material.color.setRGB(buildData.color.r, buildData.color.g, buildData.color.b);
 92 |         }
 93 | 
 94 |         const buildObject = new THREE.Mesh(geometry, material);
 95 |         buildObject.position.set(buildData.position.x, buildData.position.y, buildData.position.z);
 96 | 
 97 |         if (this.buildTool.isLocationOccupiedByPlayer(buildObject.position)) return null;
 98 |         buildObject.scale.set(buildData.scale.x, buildData.scale.y, buildData.scale.z);
 99 |         buildObject.rotation.set(buildData.rotation.x, buildData.rotation.y, buildData.rotation.z);
100 |         
101 |         buildObject.castShadow = true;
102 |         buildObject.receiveShadow = true;
103 |         buildObject.userData.isBarrier = true;
104 |         buildObject.userData.id = buildData.objectId;
105 |         buildObject.userData.createdAt = buildData.createdAt || Date.now();
106 |         if(buildData.extendedUntil) buildObject.userData.extendedUntil = buildData.extendedUntil;
107 | 
108 |         return buildObject;
109 |     }
110 | 
111 |     syncObjectWithRoom(object, isNew = false) {
112 |         if (!this.room) return;
113 | 
114 |         const buildData = {
115 |             objectId: object.userData.id,
116 |             position: { x: object.position.x, y: object.position.y, z: object.position.z },
117 |             scale: { x: object.scale.x, y: object.scale.y, z: object.scale.z },
118 |             rotation: { x: object.rotation.x, y: object.rotation.y, z: object.rotation.z },
119 |             materialIndex: this.buildTool.buildMaterials.findIndex(m => m.color.equals(object.material.color)),
120 |             color: { r: object.material.color.r, g: object.material.color.g, b: object.material.color.b },
121 |             geometryType: object.geometry.type,
122 |             createdAt: object.userData.createdAt,
123 |             isAdvanced: true
124 |         };
125 |         
126 |         if(isNew) {
127 |             this.room.send({ type: 'build_object', ...buildData });
128 |         }
129 | 
130 |         const updatedBuildObjects = { ...(this.room.roomState.buildObjects || {}) };
131 |         updatedBuildObjects[object.userData.id] = buildData;
132 |         this.room.updateRoomState({ buildObjects: updatedBuildObjects });
133 |     }
134 | }


--------------------------------------------------------------------------------
/js/player.js:
--------------------------------------------------------------------------------
 1 | // This file has been refactored. Its contents were moved to:
 2 | // - js/playerModel.js
 3 | // - js/animationSetup.js
 4 | 
 5 | // removed function setupAnimatedPlayer(model, idleClip, walkClip, runClip) {}
 6 | // removed function setupAnimatedRobot(model, idleClip, walkClip, listenClip) {}
 7 | // removed function setupAnimatedChicken(model, idleClip, walkClip, runClip, alertClip, listenClip) {}
 8 | // removed function setupAnimatedWireframe(model, idleClip, walkClip, runClip, listenClip) {}
 9 | // removed function setupAnimatedAlien(model, idleClip, walkClip, runClip, listenClip) {}
10 | // removed function setupEyebot(model) {}
11 | // removed function _createCustomPlayerModel(playerGroup, characterSpec) {}
12 | // removed function _createDefaultPlayerModel(playerGroup, username, characterSpec, defaultColor) {}
13 | // removed function createPlayerModel(three, username, characterSpec) {}
14 | 
15 | 


--------------------------------------------------------------------------------
/js/playerControls.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from "three";
  2 | import { OrbitControls } from "three/addons/controls/OrbitControls.js";
  3 | import { SPEED, GRAVITY, JUMP_FORCE, MOBILE_SPEED_MULTIPLIER, FORCE_MOBILE_MODE, RUN_SPEED_MULTIPLIER } from "./controls/constants.js";
  4 | import { InputManager } from "./controls/InputManager.js";
  5 | import { CollisionManager } from "./collisionManager.js";
  6 | 
  7 | /* @tweakable Speed of camera rotation with the joystick on mobile. */
  8 | const mobileCameraRotateSpeed = 0.05;
  9 | /* @tweakable Minimum camera zoom distance on mobile */
 10 | const mobileMinZoom = 2;
 11 | /* @tweakable Maximum camera zoom distance on mobile */
 12 | const mobileMaxZoom = 10;
 13 | /* @tweakable The radius of the player's collision shape. */
 14 | const PLAYER_COLLISION_RADIUS = 0.3;
 15 | /* @tweakable The height of the player's collision shape. */
 16 | const PLAYER_COLLISION_HEIGHT = 1.8;
 17 | 
 18 | export class PlayerControls {
 19 |   constructor(scene, room, options = {}) {
 20 |     this.scene = scene;
 21 |     this.room = room;
 22 |     this.camera = options.camera || new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
 23 |     this.renderer = options.renderer;
 24 |     this.domElement = this.renderer ? this.renderer.domElement : document.body;
 25 |     this.playerModel = options.playerModel;
 26 |     this.terrain = options.terrain;
 27 |     this.lastPosition = new THREE.Vector3();
 28 |     this.isMoving = false;
 29 |     this.wasMoving = false;
 30 |     this.isRunning = false;
 31 |     this.wasRunning = false;
 32 |     this.lastUpdateTime = 0;
 33 |     this.currentAction = 'idle';
 34 |     
 35 |     // Player state
 36 |     this.velocity = new THREE.Vector3();
 37 |     this.canJump = true;
 38 |     this.isMobile = FORCE_MOBILE_MODE || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
 39 |     
 40 |     // Add mobile-device class to body for CSS styling
 41 |     if (this.isMobile) {
 42 |       document.body.classList.add('mobile-device');
 43 |     }
 44 | 
 45 |     // Input manager
 46 |     this.inputManager = new InputManager(this.isMobile, this.isMobile ? document.getElementById('right-side-touch-area') : this.domElement);
 47 |     this.collisionManager = new CollisionManager(scene);
 48 | 
 49 |     // Initial player position
 50 |     const initialPos = options.initialPosition || {};
 51 |     this.playerX = initialPos.x || (Math.random() * 10) - 5;
 52 |     this.playerY = initialPos.y || 0.20;
 53 |     this.playerZ = initialPos.z || (Math.random() * 10) - 5;
 54 |     
 55 |     // Set initial player model position if it exists
 56 |     if (this.playerModel) {
 57 |       this.setPlayerModel(this.playerModel);
 58 |     }
 59 |     
 60 |     // Set camera to third-person perspective
 61 |     const targetY = this.playerModel ? this.playerModel.position.y + 1 : this.playerY + 1;
 62 |     this.camera.position.set(this.playerX, targetY + 2, this.playerZ + 5);
 63 |     this.camera.lookAt(this.playerX, targetY, this.playerZ);
 64 |     // Store the initial camera offset (relative to player's target position)
 65 |     this.cameraOffset = new THREE.Vector3();
 66 |     this.cameraOffset.copy(this.camera.position).sub(new THREE.Vector3(this.playerX, targetY, this.playerZ));
 67 |     
 68 |     // Initialize controls
 69 |     this.initializeControls();
 70 |     
 71 |     // Setup event listeners
 72 |     this.setupEventListeners();
 73 |     
 74 |     // If room is provided, initialize multiplayer presence
 75 |     if (this.room) {
 76 |       // Initialize player presence in the room - include characterSpec if available
 77 |       const presenceData = {
 78 |         x: this.playerX,
 79 |         y: this.playerY,
 80 |         z: this.playerZ,
 81 |         rotation: 0,
 82 |         moving: false,
 83 |         running: false
 84 |       };
 85 |       if (this.playerModel && this.playerModel.userData.characterSpec) {
 86 |         presenceData.characterSpec = this.playerModel.userData.characterSpec;
 87 |       }
 88 |       this.room.updatePresence(presenceData);
 89 |     }
 90 |     
 91 |     this.enabled = true; // Add enabled flag for chat input
 92 |   }
 93 |   
 94 |   setPlayerModel(model) {
 95 |     this.playerModel = model;
 96 |     if (this.terrain) {
 97 |         const terrainHeight = this.terrain.userData.getHeight(this.playerX, this.playerZ);
 98 |         this.playerModel.position.set(this.playerX, terrainHeight + this.playerY, this.playerZ);
 99 |     } else {
100 |         this.playerModel.position.set(this.playerX, this.playerY, this.playerZ);
101 |     }
102 |     this.lastPosition.copy(this.playerModel.position);
103 |   }
104 | 
105 |   getGroundHeight(x, z) {
106 |     if (!this.terrain) return 0;
107 | 
108 |     const raycaster = new THREE.Raycaster();
109 |     /* @tweakable The starting height of the raycast used to detect ground collision. Should be higher than the highest point in the world. */
110 |     const rayOriginHeight = 50;
111 |     const rayOrigin = new THREE.Vector3(x, rayOriginHeight, z);
112 |     const rayDirection = new THREE.Vector3(0, -1, 0);
113 |     raycaster.set(rayOrigin, rayDirection);
114 | 
115 |     // Only check for intersection with the terrain object
116 |     const intersects = raycaster.intersectObject(this.terrain);
117 | 
118 |     if (intersects.length > 0) {
119 |       return intersects[0].point.y; // Return the precise intersection point's y-coordinate
120 |     }
121 | 
122 |     // Fallback to the noise function if raycast fails for some reason
123 |     return this.terrain.userData.getHeight(x, z);
124 |   }
125 | 
126 |   initializeControls() {
127 |     // Use OrbitControls for third-person view on both platforms
128 |     this.controls = new OrbitControls(this.camera, this.domElement);
129 |     this.controls.enableDamping = true;
130 |     this.controls.dampingFactor = 0.1;
131 |     this.controls.maxPolarAngle = Math.PI * 0.9; // Prevent going below ground
132 |     this.controls.minDistance = this.isMobile ? mobileMinZoom : 3; // Minimum zoom distance
133 |     this.controls.maxDistance = this.isMobile ? mobileMaxZoom : 10; // Maximum zoom distance
134 |     
135 |     // Update camera offset when controls change
136 |     this.controls.addEventListener('change', () => {
137 |       this.cameraOffset.copy(this.camera.position).sub(this.controls.target);
138 |     });
139 | 
140 |     if (this.isMobile) {
141 |       // The jump button is created in app.js.
142 |       // The event listener is handled by InputManager.js.
143 |     } else {
144 |       // Add instructions for desktop
145 |       const instructionsDiv = document.createElement('div');
146 |       instructionsDiv.className = "instructions";
147 |       instructionsDiv.innerHTML = "Click to begin. <br>Use WASD to move, Space to jump.";
148 |       document.getElementById('game-container').appendChild(instructionsDiv);
149 |       
150 |       // Hide instructions on first click
151 |       document.addEventListener('click', () => {
152 |         if (document.querySelector(".instructions")) {
153 |           document.querySelector(".instructions").style.display = 'none';
154 |         }
155 |       }, { once: true });
156 |     }
157 |   }
158 | 
159 |   setupEventListeners() {
160 |     // Listen for jump key on desktop
161 |     document.addEventListener("keydown", (e) => {
162 |       if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') {
163 |           return;
164 |       }
165 |       if (this.inputManager.isJumping() && this.canJump && !this.isMobile) {
166 |         this.velocity.y = JUMP_FORCE;
167 |         this.canJump = false;
168 |       }
169 |     });
170 |     
171 |     // Handle window resize
172 |     window.addEventListener('resize', () => {
173 |       this.camera.aspect = window.innerWidth / window.innerHeight;
174 |       this.camera.updateProjectionMatrix();
175 |       if (this.renderer) {
176 |         this.renderer.setSize(window.innerWidth, window.innerHeight);
177 |       }
178 |     });
179 |   }
180 |   
181 |   processMovement() {
182 |     // Skip movement processing if controls are disabled
183 |     if (!this.enabled) return;
184 | 
185 |     if (this.isMobile && this.inputManager.isJumping() && this.canJump) {
186 |       this.velocity.y = JUMP_FORCE;
187 |       this.canJump = false;
188 |     }
189 |     
190 |     const x = this.playerModel.position.x;
191 |     const y = this.playerModel.position.y;
192 |     const z = this.playerModel.position.z;
193 |     
194 |     const moveDirection = this.inputManager.getMovementDirection();
195 |     const isRunning = this.inputManager.isRunning();
196 |     
197 |     const cameraDirection = new THREE.Vector3();
198 |     this.camera.getWorldDirection(cameraDirection);
199 |     cameraDirection.y = 0; 
200 |     cameraDirection.normalize();
201 |     
202 |     const rightVector = new THREE.Vector3();
203 |     rightVector.crossVectors(this.camera.up, cameraDirection).normalize();
204 |     
205 |     const movement = new THREE.Vector3();
206 |     if (this.isMobile) {
207 |         // For mobile, moveDirection.z is forward/backward from joystick
208 |         // moveDirection.x is left/right from joystick
209 |         movement.addScaledVector(cameraDirection, moveDirection.z);
210 |         // rightVector points left relative to the camera, so invert for correct orientation
211 |         movement.addScaledVector(rightVector, moveDirection.x * -1);
212 |     } else {
213 |         if (moveDirection.z !== 0) {
214 |             movement.add(cameraDirection.clone().multiplyScalar(moveDirection.z));
215 |         }
216 |         if (moveDirection.x !== 0) {
217 |             movement.add(rightVector.clone().multiplyScalar(moveDirection.x * -1)); // Invert for desktop standard
218 |         }
219 |     }
220 |     
221 |     if (movement.length() > 0) {
222 |         let moveSpeed = this.isMobile ? SPEED * MOBILE_SPEED_MULTIPLIER : SPEED;
223 |         if (isRunning) {
224 |           moveSpeed *= RUN_SPEED_MULTIPLIER;
225 |         }
226 |         movement.normalize().multiplyScalar(moveSpeed);
227 |     }
228 | 
229 |     this.velocity.y -= GRAVITY;
230 |     
231 |     let newX = x + movement.x;
232 |     let newY = y + this.velocity.y;
233 |     let newZ = z + movement.z;
234 |     
235 |     // Use the CollisionManager to check for collisions
236 |     const { finalPosition, finalVelocity, canJump, standingOnBlock } = this.collisionManager.checkCollisions(
237 |         this.playerModel.position,
238 |         new THREE.Vector3(newX, newY, newZ),
239 |         this.velocity,
240 |         PLAYER_COLLISION_RADIUS,
241 |         PLAYER_COLLISION_HEIGHT
242 |     );
243 |     
244 |     newX = finalPosition.x;
245 |     newY = finalPosition.y;
246 |     newZ = finalPosition.z;
247 |     this.velocity.copy(finalVelocity);
248 |     
249 |     if (canJump) {
250 |         this.canJump = true;
251 |     }
252 |     
253 |     // Ground collision logic moved here to always check against terrain after object collision
254 |     const terrainHeight = this.getGroundHeight(newX, newZ);
255 |     /* @tweakable The vertical offset of the player model from the ground to prevent clipping. */
256 |     const groundOffset = 0;
257 |     const groundLevel = terrainHeight + groundOffset;
258 | 
259 |     // If standing on a block, the newY is already set by the collision manager.
260 |     // We just need to make sure we don't fall through it to the terrain below.
261 |     if (standingOnBlock) {
262 |         if (newY < groundLevel) {
263 |             // This case is unlikely but handles situations where a block might be slightly below terrain
264 |             newY = groundLevel;
265 |             this.velocity.y = 0;
266 |             this.canJump = true;
267 |         }
268 |     } else {
269 |         // Not standing on a block, so check against terrain.
270 |         // Apply gravity.
271 |         this.velocity.y -= GRAVITY;
272 |         newY = this.playerModel.position.y + this.velocity.y;
273 | 
274 |         if (newY < groundLevel) {
275 |             newY = groundLevel;
276 |             this.velocity.y = 0;
277 |             this.canJump = true;
278 |         }
279 |     }
280 |     
281 |     const isMovingNow = movement.length() > 0.001;
282 |     this.isMoving = isMovingNow;
283 |     
284 |     if (this.playerModel) {
285 |       this.playerModel.position.set(newX, newY, newZ);
286 |       
287 |       if (isMovingNow) {
288 |         const angle = Math.atan2(movement.x, movement.z);
289 |         const offset = this.playerModel.userData.isAnimatedGLB ? (this.playerModel.userData.rotationOffset || 0) : 0;
290 |         this.playerModel.rotation.y = angle - offset; 
291 |       }
292 |       
293 |       // Handle animations
294 |       if (this.playerModel.userData.isAnimatedGLB) {
295 |         const actions = this.playerModel.userData.actions;
296 |         const fadeDuration = this.playerModel.userData.animationFadeDuration || 0.5;
297 |         
298 |         let newActionName = 'idle';
299 |         if (isMovingNow) {
300 |           newActionName = isRunning ? 'run' : 'walk';
301 |         }
302 |         
303 |         if (this.currentAction !== newActionName) {
304 |             const from = actions[this.currentAction];
305 |             const to = actions[newActionName];
306 |             if(from && to) {
307 |                 from.fadeOut(fadeDuration);
308 |                 to.reset().fadeIn(fadeDuration).play();
309 |             }
310 |             this.currentAction = newActionName;
311 |         }
312 |       } else {
313 |         if (isMovingNow) {
314 |             const leftLeg = this.playerModel.getObjectByName("leftLeg");
315 |             const rightLeg = this.playerModel.getObjectByName("rightLeg");
316 |             
317 |             if (leftLeg && rightLeg) {
318 |               /* @tweakable Speed of the procedural leg swing animation. */
319 |               const walkSpeed = 5; 
320 |               /* @tweakable Amplitude of the procedural leg swing animation. */
321 |               const walkAmplitude = 0.3;
322 |               leftLeg.rotation.x = Math.sin(this.time * walkSpeed) * walkAmplitude;
323 |               rightLeg.rotation.x = Math.sin(this.time * walkSpeed + Math.PI) * walkAmplitude;
324 |             }
325 |         } else {
326 |             const leftLeg = this.playerModel.getObjectByName("leftLeg");
327 |             const rightLeg = this.playerModel.getObjectByName("rightLeg");
328 |             
329 |             if (leftLeg && rightLeg) {
330 |               leftLeg.rotation.x = 0;
331 |               rightLeg.rotation.x = 0;
332 |             }
333 |         }
334 |       }
335 |       
336 |       const newTarget = new THREE.Vector3(this.playerModel.position.x, this.playerModel.position.y + 1, this.playerModel.position.z);
337 |       if (this.controls) this.controls.target.copy(newTarget);
338 |       this.camera.position.copy(newTarget).add(this.cameraOffset);
339 |       
340 |       if (this.room && (
341 |           Math.abs(this.lastPosition.x - newX) > 0.01 ||
342 |           Math.abs(this.lastPosition.y - newY) > 0.01 ||
343 |           Math.abs(this.lastPosition.z - newZ) > 0.01 ||
344 |           this.isMoving !== this.wasMoving ||
345 |           isRunning !== this.wasRunning
346 |         )) {
347 |         
348 |         const offset = this.playerModel.userData.rotationOffset || 0;
349 |         const presenceData = {
350 |           x: newX,
351 |           y: newY,
352 |           z: newZ,
353 |           rotation: this.playerModel.rotation.y - offset,
354 |           moving: this.isMoving,
355 |           running: isRunning,
356 |         };
357 | 
358 |         if (this.playerModel.userData.isGLB) {
359 |           presenceData.isGLB = true;
360 |         } else if (this.playerModel.userData.characterSpec) {
361 |           presenceData.characterSpec = this.playerModel.userData.characterSpec;
362 |         }
363 |         
364 |         this.room.updatePresence(presenceData);
365 |         
366 |         this.lastPosition.set(newX, newY, newZ);
367 |         this.wasMoving = this.isMoving;
368 |         this.wasRunning = isRunning;
369 |       }
370 |     }
371 |     
372 |     this.controls.update();
373 |   }
374 |   
375 |   update() {
376 |     const now = performance.now();
377 |     const delta = (now - (this.lastUpdateTime || now)) / 1000;
378 |     this.lastUpdateTime = now;
379 | 
380 |     this.time = (now * 0.01) % 1000;
381 |     
382 |     if (this.enabled) {
383 |       this.processMovement();
384 |     } else {
385 |         // Still update controls for camera movement when player movement is disabled
386 |         if (this.controls) this.controls.update();
387 |     }
388 | 
389 |     if (this.isMobile) {
390 |       this.controls.enabled = !this.inputManager.isCameraMoving();
391 |       const cameraMove = this.inputManager.getCameraMovement();
392 |       if (cameraMove.x !== 0 || cameraMove.y !== 0) {
393 |         const rotateSpeed = mobileCameraRotateSpeed;
394 |         this.controls.rotateLeft(-cameraMove.x * rotateSpeed);
395 |         this.controls.rotateUp(-cameraMove.y * rotateSpeed);
396 |       }
397 |     }
398 |     
399 |     // Update animation mixer if it exists
400 |     if (this.playerModel && this.playerModel.userData.mixer) {
401 |         this.playerModel.userData.mixer.update(delta);
402 |     }
403 |   }
404 |   
405 |   getCamera() {
406 |     return this.camera;
407 |   }
408 |   
409 |   getPlayerModel() {
410 |     return this.playerModel;
411 |   }
412 | }


--------------------------------------------------------------------------------
/js/playerModel.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | 
  3 | function _createCustomPlayerModel(playerGroup, characterSpec) {
  4 |     if (!characterSpec.features || !Array.isArray(characterSpec.features)) {
  5 |         return;
  6 |     }
  7 | 
  8 |     let minY = Infinity;
  9 |     const animatedFeatures = [];
 10 | 
 11 |     characterSpec.features.forEach(feature => {
 12 |         let geometry;
 13 |         switch (feature.type.toLowerCase()) {
 14 |             case 'box': geometry = new THREE.BoxGeometry(1, 1, 1); break;
 15 |             case 'sphere': geometry = new THREE.SphereGeometry(0.5, 16, 16); break;
 16 |             case 'cylinder': geometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 16); break;
 17 |             case 'cone': geometry = new THREE.ConeGeometry(0.5, 1, 16); break;
 18 |             case 'torus': geometry = new THREE.TorusGeometry(0.5, 0.2, 16, 32); break;
 19 |             default: geometry = new THREE.BoxGeometry(1, 1, 1);
 20 |         }
 21 | 
 22 |         let material;
 23 |         if (feature.texture) {
 24 |             if (feature.texture.textureUrl) {
 25 |                 const textureLoader = new THREE.TextureLoader();
 26 |                 const texture = textureLoader.load(feature.texture.textureUrl);
 27 |                 const materialParams = {
 28 |                     map: texture,
 29 |                     roughness: feature.roughness || feature.texture.roughness || 0.7,
 30 |                     metalness: feature.metalness || feature.texture.metalness || 0.2,
 31 |                     transparent: feature.transparent || false,
 32 |                     opacity: feature.opacity !== undefined ? feature.opacity : 1.0
 33 |                 };
 34 |                 if (feature.texture.normalMap) {
 35 |                     materialParams.normalMap = textureLoader.load(feature.texture.normalMap);
 36 |                 }
 37 |                 material = new THREE.MeshStandardMaterial(materialParams);
 38 |             } else {
 39 |                 material = new THREE.MeshStandardMaterial({
 40 |                     color: feature.color || feature.texture.color || 0xffffff,
 41 |                     roughness: feature.roughness || feature.texture.roughness || 0.7,
 42 |                     metalness: feature.metalness || feature.texture.metalness || 0.2,
 43 |                     transparent: feature.transparent || feature.texture.transparent || false,
 44 |                     opacity: feature.opacity !== undefined ? feature.opacity :
 45 |                            (feature.texture.opacity !== undefined ? feature.texture.opacity : 1.0)
 46 |                 });
 47 |             }
 48 |         } else {
 49 |             material = new THREE.MeshStandardMaterial({
 50 |                 color: feature.color || 0xffffff,
 51 |                 roughness: feature.roughness || 0.7,
 52 |                 metalness: feature.metalness || 0.2,
 53 |                 transparent: feature.transparent || false,
 54 |                 opacity: feature.opacity !== undefined ? feature.opacity : 1.0
 55 |             });
 56 |         }
 57 | 
 58 |         const mesh = new THREE.Mesh(geometry, material);
 59 | 
 60 |         if (feature.position) {
 61 |             mesh.position.set(
 62 |                 Math.max(-1, Math.min(1, feature.position.x || 0)),
 63 |                 Math.max(-1, Math.min(1, feature.position.y || 0)),
 64 |                 Math.max(-1, Math.min(1, feature.position.z || 0))
 65 |             );
 66 |         }
 67 | 
 68 |         if (feature.position && feature.scale) {
 69 |             const halfHeight = (feature.scale.y || 1) / 2;
 70 |             const bottomY = (feature.position.y || 0) - halfHeight;
 71 |             minY = Math.min(minY, bottomY);
 72 |         } else if (feature.position) {
 73 |             minY = Math.min(minY, (feature.position.y || 0) - 0.5);
 74 |         }
 75 | 
 76 |         if (feature.scale) {
 77 |             mesh.scale.set(
 78 |                 Math.min(2, feature.scale.x || 1),
 79 |                 Math.min(2, feature.scale.y || 1),
 80 |                 Math.min(2, feature.scale.z || 1)
 81 |             );
 82 |         }
 83 | 
 84 |         if (feature.rotation) {
 85 |             mesh.rotation.set(
 86 |                 feature.rotation.x || 0,
 87 |                 feature.rotation.y || 0,
 88 |                 feature.rotation.z || 0
 89 |             );
 90 |         }
 91 |         
 92 |         if (feature.animation) {
 93 |             animatedFeatures.push({
 94 |                 mesh: mesh,
 95 |                 animation: feature.animation,
 96 |                 initialPosition: feature.position ? {...feature.position} : {x:0,y:0,z:0},
 97 |                 initialRotation: feature.rotation ? {...feature.rotation} : {x:0,y:0,z:0},
 98 |                 initialScale: feature.scale ? {...feature.scale} : {x:1,y:1,z:1}
 99 |             });
100 |         }
101 |         
102 |         if (feature.name === "leftLeg" || feature.name === "rightLeg") {
103 |             mesh.name = feature.name;
104 |             const legHeight = feature.scale?.y || 1;
105 |             mesh.geometry.translate(0, -legHeight / 2, 0); // Set pivot to top of leg
106 |         }
107 |         
108 |         mesh.castShadow = true;
109 |         playerGroup.add(mesh);
110 |     });
111 | 
112 |     if (minY !== Infinity && minY < 0) {
113 |         playerGroup.position.y = -minY;
114 |     } else if (minY > 0) {
115 |         const hitboxGeometry = new THREE.BoxGeometry(0.5, 0.1, 0.5);
116 |         const hitboxMaterial = new THREE.MeshBasicMaterial({ visible: false, transparent: true, opacity: 0 });
117 |         const hitbox = new THREE.Mesh(hitboxGeometry, hitboxMaterial);
118 |         hitbox.position.y = 0;
119 |         playerGroup.add(hitbox);
120 |     }
121 |     
122 |     if (animatedFeatures.length > 0) {
123 |         playerGroup.userData.animatedFeatures = animatedFeatures;
124 |         playerGroup.userData.updateAnimations = (time) => {
125 |             animatedFeatures.forEach(feature => {
126 |                 const { mesh, animation, initialPosition, initialRotation, initialScale } = {
127 |                     mesh: feature.mesh,
128 |                     animation: feature.animation,
129 |                     initialPosition: feature.initialPosition || {x:0,y:0,z:0},
130 |                     initialRotation: feature.initialRotation || {x:0,y:0,z:0},
131 |                     initialScale: feature.initialScale || {x:1,y:1,z:1}
132 |                 };
133 |                 
134 |                 switch(animation.type) {
135 |                     case 'jiggly':
136 |                         mesh.position.x = initialPosition.x + (Math.sin(time * 10) * 0.03);
137 |                         mesh.position.y = initialPosition.y + (Math.cos(time * 8) * 0.03);
138 |                         mesh.position.z = initialPosition.z + (Math.sin(time * 12) * 0.03);
139 |                         break;
140 |                     case 'bobUpDown':
141 |                         mesh.position.y = initialPosition.y + (Math.sin(time * 2) * 0.1);
142 |                         break;
143 |                     case 'spinY': mesh.rotation.y = initialRotation.y + time * 2; break;
144 |                     case 'spinX': mesh.rotation.x = initialRotation.x + time * 2; break;
145 |                     case 'spinZ': mesh.rotation.z = initialRotation.z + time * 2; break;
146 |                     case 'pulse':
147 |                         const scaleFactor = 1 + (Math.sin(time * 3) * 0.1);
148 |                         mesh.scale.set(initialScale.x * scaleFactor, initialScale.y * scaleFactor, initialScale.z * scaleFactor);
149 |                         break;
150 |                 }
151 |             });
152 |         };
153 |     }
154 | }
155 | 
156 | function _createDefaultPlayerModel(playerGroup, username, characterSpec, defaultColor) {
157 |     const bodyColor = characterSpec?.bodyColor ? new THREE.Color(characterSpec.bodyColor) : defaultColor;
158 |     const legColor = characterSpec?.legColor ? new THREE.Color(characterSpec.legColor) : defaultColor.clone().multiplyScalar(0.8);
159 |     const eyeColor = characterSpec?.eyeColor ? new THREE.Color(characterSpec.eyeColor) : 0xffffff;
160 |     
161 |     const bodyGeometry = new THREE.BoxGeometry(0.6 * 0.7, 1.4 * 0.7, 0.3 * 0.7);
162 |     const bodyMaterial = new THREE.MeshStandardMaterial({ color: bodyColor });
163 |     const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
164 |     body.position.y = 1.1 * 0.7;
165 |     body.castShadow = true;
166 |     playerGroup.add(body);
167 |     
168 |     const eyeGeometry = new THREE.SphereGeometry(0.08 * 0.7, 8, 8);
169 |     const eyeMaterial = new THREE.MeshStandardMaterial({ color: eyeColor });
170 |     const eyePupilMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
171 |     
172 |     const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
173 |     leftEye.position.set(-0.15 * 0.7, 1.6 * 0.7, 0.15 * 0.7);
174 |     playerGroup.add(leftEye);
175 |     
176 |     const leftPupil = new THREE.Mesh(new THREE.SphereGeometry(0.04 * 0.7, 8, 8), eyePupilMaterial);
177 |     leftPupil.position.set(0, 0, 0.05 * 0.7);
178 |     leftEye.add(leftPupil);
179 |     
180 |     const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
181 |     rightEye.position.set(0.15 * 0.7, 1.6 * 0.7, 0.15 * 0.7);
182 |     playerGroup.add(rightEye);
183 |     
184 |     const rightPupil = new THREE.Mesh(new THREE.SphereGeometry(0.04 * 0.7, 8, 8), eyePupilMaterial);
185 |     rightPupil.position.set(0, 0, 0.05 * 0.7);
186 |     rightEye.add(rightPupil);
187 |     
188 |     const legGeometry = new THREE.BoxGeometry(0.2 * 0.7, 0.5 * 0.7, 0.2 * 0.7);
189 |     const legMaterial = new THREE.MeshStandardMaterial({ color: legColor });
190 |     
191 |     const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
192 |     leftLeg.position.set(-0.2 * 0.7, 0.45 * 0.7, 0); // Adjusted Y position
193 |     leftLeg.geometry.translate(0, -0.25 * 0.7, 0);
194 |     leftLeg.name = "leftLeg";
195 |     playerGroup.add(leftLeg);
196 |     
197 |     const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
198 |     rightLeg.position.set(0.2 * 0.7, 0.45 * 0.7, 0); // Adjusted Y position
199 |     rightLeg.geometry.translate(0, -0.25 * 0.7, 0);
200 |     rightLeg.name = "rightLeg";
201 |     playerGroup.add(rightLeg);
202 |     
203 |     if (characterSpec && characterSpec.features && Array.isArray(characterSpec.features)) {
204 |         characterSpec.features.forEach(feature => {
205 |             let geometry;
206 |             switch (feature.type.toLowerCase()) {
207 |                 case 'box': geometry = new THREE.BoxGeometry(1, 1, 1); break;
208 |                 case 'sphere': geometry = new THREE.SphereGeometry(0.5, 16, 16); break;
209 |                 case 'cylinder': geometry = new THREE.CylinderGeometry(0.5, 0.5, 1, 16); break;
210 |                 default: geometry = new THREE.BoxGeometry(1, 1, 1);
211 |             }
212 |             const material = new THREE.MeshStandardMaterial({ color: feature.color || 0xffffff, roughness: 0.7, metalness: 0.2 });
213 |             const mesh = new THREE.Mesh(geometry, material);
214 |             if (feature.position) mesh.position.set(feature.position.x || 0, feature.position.y || 0, feature.position.z || 0);
215 |             if (feature.scale) mesh.scale.set(feature.scale.x || 1, feature.scale.y || 1, feature.scale.z || 1);
216 |             if (feature.rotation) mesh.rotation.set(feature.rotation.x || 0, feature.rotation.y || 0, feature.rotation.z || 0);
217 |             mesh.castShadow = true;
218 |             playerGroup.add(mesh);
219 |         });
220 |     }
221 | }
222 | 
223 | export function createPlayerModel(three, username, characterSpec) {
224 |     const playerGroup = new THREE.Group();
225 |     playerGroup.userData.isPlayer = true;
226 |     
227 |     // Store character spec in userData for reference
228 |     if (characterSpec) {
229 |         playerGroup.userData.characterSpec = characterSpec;
230 |     }
231 |     
232 |     // Generate consistent color from username for default appearance
233 |     const hash = username.split('').reduce((a, b) => {
234 |         a = ((a << 5) - a) + b.charCodeAt(0);
235 |         return a & a;
236 |     }, 0);
237 |     const defaultColor = new THREE.Color(Math.abs(hash) % 0xffffff);
238 |     
239 |     // If there's a character spec and it includes a custom mode flag, create a fully custom character
240 |     if (characterSpec && characterSpec.customMode) {
241 |         _createCustomPlayerModel(playerGroup, characterSpec);
242 |     } else {
243 |         _createDefaultPlayerModel(playerGroup, username, characterSpec, defaultColor);
244 |     }
245 |     
246 |     // Add a billboarded text plane for chat messages (not visible by default)
247 |     const canvas = document.createElement('canvas');
248 |     canvas.width = 256;
249 |     canvas.height = 64;
250 |     const context = canvas.getContext('2d');
251 |     context.fillStyle = 'rgba(0, 0, 0, 0)'; // Transparent background
252 |     context.fillRect(0, 0, canvas.width, canvas.height);
253 |     
254 |     const texture = new THREE.CanvasTexture(canvas);
255 |     texture.needsUpdate = true;
256 |     
257 |     const chatMaterial = new THREE.MeshBasicMaterial({
258 |       map: texture,
259 |       transparent: true,
260 |       depthWrite: false,
261 |       side: THREE.DoubleSide
262 |     });
263 |     
264 |     const chatGeometry = new THREE.PlaneGeometry(1, 0.25);
265 |     const chatMesh = new THREE.Mesh(chatGeometry, chatMaterial);
266 |     chatMesh.position.y = 2.3 * 0.7; 
267 |     chatMesh.rotation.x = Math.PI / 12;
268 |     chatMesh.visible = false;
269 |     chatMesh.name = "chatBillboard";
270 |     playerGroup.add(chatMesh);
271 |     
272 |     return playerGroup;
273 | }


--------------------------------------------------------------------------------
/js/previewManager.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | 
  3 | export class PreviewManager {
  4 |     constructor(scene, camera, buildMaterials, terrain) {
  5 |         this.scene = scene;
  6 |         this.camera = camera;
  7 |         this.buildMaterials = buildMaterials;
  8 |         this.terrain = terrain;
  9 | 
 10 |         this.previewMesh = null;
 11 |         this.currentMaterialIndex = 0;
 12 |         this.currentHeight = 0.5;
 13 | 
 14 |         this.shapes = [
 15 |             { geometry: new THREE.BoxGeometry(1, 1, 1), name: 'BoxGeometry' },
 16 |             { geometry: new THREE.SphereGeometry(0.5, 16, 16), name: 'SphereGeometry' },
 17 |             { geometry: new THREE.CylinderGeometry(0.5, 0.5, 1, 16), name: 'CylinderGeometry' },
 18 |             { geometry: new THREE.ConeGeometry(0.5, 1, 16), name: 'ConeGeometry' },
 19 |             { geometry: new THREE.TorusGeometry(0.5, 0.2, 16, 32), name: 'TorusGeometry' },
 20 |             { geometry: new THREE.ConeGeometry(0.5, 1, 4), name: 'Pyramid' }
 21 |         ];
 22 |         this.currentShapeIndex = 0;
 23 | 
 24 |         this.raycaster = new THREE.Raycaster();
 25 |         this.mousePosition = new THREE.Vector2();
 26 | 
 27 |         this.createPreviewMesh();
 28 |     }
 29 | 
 30 |     createPreviewMesh() {
 31 |         if (this.previewMesh) {
 32 |             this.scene.remove(this.previewMesh);
 33 |         }
 34 |         const geometry = this.shapes[this.currentShapeIndex].geometry.clone();
 35 |         const material = this.buildMaterials[this.currentMaterialIndex].clone();
 36 |         material.transparent = true;
 37 |         material.opacity = 0.5;
 38 | 
 39 |         this.previewMesh = new THREE.Mesh(geometry, material);
 40 |         this.previewMesh.castShadow = false;
 41 |         this.previewMesh.receiveShadow = false;
 42 |         this.previewMesh.userData.heightAdjusted = false;
 43 |         this.previewMesh.userData.shapeName = this.shapes[this.currentShapeIndex].name;
 44 |         this.scene.add(this.previewMesh);
 45 |     }
 46 | 
 47 |     updatePosition(mousePosition, buildObjects) {
 48 |         if (!this.previewMesh) return;
 49 | 
 50 |         this.mousePosition.copy(mousePosition);
 51 |         this.raycaster.setFromCamera(this.mousePosition, this.camera);
 52 |         const intersects = this.raycaster.intersectObjects([...this.scene.children], true);
 53 | 
 54 |         for (let i = 0; i < intersects.length; i++) {
 55 |             if (intersects[i].object === this.previewMesh || buildObjects.includes(intersects[i].object)) {
 56 |                 continue;
 57 |             }
 58 | 
 59 |             const point = intersects[i].point;
 60 | 
 61 |             const gridSize = 1;
 62 |             point.x = Math.round(point.x / gridSize) * gridSize;
 63 |             point.z = Math.round(point.z / gridSize) * gridSize;
 64 | 
 65 |             if (!this.previewMesh.userData.heightAdjusted) {
 66 |                 const terrainHeight = this.terrain ? this.terrain.userData.getHeight(point.x, point.z) : 0;
 67 |                 point.y = terrainHeight + this.currentHeight;
 68 |                 if (point.y < terrainHeight + 0.5) point.y = terrainHeight + 0.5;
 69 |             } else {
 70 |                 this.previewMesh.position.x = point.x;
 71 |                 this.previewMesh.position.z = point.z;
 72 |                 return;
 73 |             }
 74 | 
 75 |             this.previewMesh.position.copy(point);
 76 |             break;
 77 |         }
 78 |     }
 79 | 
 80 |     changeShape() {
 81 |         if (!this.previewMesh) return;
 82 |         this.scene.remove(this.previewMesh);
 83 | 
 84 |         this.currentShapeIndex = (this.currentShapeIndex + 1) % this.shapes.length;
 85 | 
 86 |         const geometry = this.shapes[this.currentShapeIndex].geometry.clone();
 87 |         const material = this.buildMaterials[this.currentMaterialIndex].clone();
 88 |         material.transparent = true;
 89 |         material.opacity = 0.5;
 90 |         this.previewMesh = new THREE.Mesh(geometry, material);
 91 |         this.previewMesh.castShadow = false;
 92 |         this.previewMesh.receiveShadow = false;
 93 |         this.previewMesh.userData.shapeName = this.shapes[this.currentShapeIndex].name;
 94 |         this.scene.add(this.previewMesh);
 95 |     }
 96 | 
 97 |     changeMaterial() {
 98 |         if (!this.previewMesh) return;
 99 |         this.currentMaterialIndex = (this.currentMaterialIndex + 1) % this.buildMaterials.length;
100 |         const material = this.buildMaterials[this.currentMaterialIndex].clone();
101 |         material.transparent = true;
102 |         material.opacity = 0.5;
103 |         this.previewMesh.material = material;
104 |     }
105 | 
106 |     changeSize() {
107 |         if (!this.previewMesh) return;
108 |         const scales = [
109 |             new THREE.Vector3(1, 1, 1),
110 |             new THREE.Vector3(0.5, 0.5, 0.5),
111 |             new THREE.Vector3(2, 2, 2),
112 |             new THREE.Vector3(1, 2, 1),
113 |             new THREE.Vector3(2, 1, 1),
114 |             new THREE.Vector3(1, 1, 2)
115 |         ];
116 |         let nextScaleIndex = 0;
117 |         for (let i = 0; i < scales.length; i++) {
118 |             if (this.previewMesh.scale.equals(scales[i])) {
119 |                 nextScaleIndex = (i + 1) % scales.length;
120 |                 break;
121 |             }
122 |         }
123 |         this.previewMesh.scale.copy(scales[nextScaleIndex]);
124 |     }
125 | 
126 |     rotate() {
127 |         if (!this.previewMesh) return;
128 |         this.previewMesh.rotation.y += Math.PI / 2;
129 |     }
130 |     
131 |     adjustHeight(delta) {
132 |         if (!this.previewMesh) return;
133 |         this.previewMesh.position.y += delta;
134 |         const terrainHeight = this.terrain ? this.terrain.userData.getHeight(this.previewMesh.position.x, this.previewMesh.position.z) : 0;
135 |         if (this.previewMesh.position.y < terrainHeight + 0.5) this.previewMesh.position.y = terrainHeight + 0.5;
136 |         this.previewMesh.userData.heightAdjusted = true;
137 |         return this.previewMesh.position.y;
138 |     }
139 | 
140 |     setCurrentHeight(height) {
141 |         this.currentHeight = height;
142 |         if (this.previewMesh) {
143 |             const terrainHeight = this.terrain ? this.terrain.userData.getHeight(this.previewMesh.position.x, this.previewMesh.position.z) : 0;
144 |             this.previewMesh.position.y = terrainHeight + this.currentHeight;
145 |             this.previewMesh.userData.heightAdjusted = false;
146 |         }
147 |     }
148 | 
149 |     getMesh() {
150 |         return this.previewMesh;
151 |     }
152 | 
153 |     show() {
154 |         if (this.previewMesh) this.previewMesh.visible = true;
155 |     }
156 | 
157 |     hide() {
158 |         if (this.previewMesh) this.previewMesh.visible = false;
159 |     }
160 |     
161 |     getCurrentMaterialIndex() {
162 |         return this.currentMaterialIndex;
163 |     }
164 | }


--------------------------------------------------------------------------------
/js/uiManager.js:
--------------------------------------------------------------------------------
  1 | import { BuildUI } from '../ui/buildUI.js';
  2 | import { AdvancedBuildUI } from '../ui/advancedBuildUI.js';
  3 | import { ChatUI } from '../ui/chatUI.js';
  4 | import { ChangelogUI } from '../ui/changelogUI.js';
  5 | import { CharacterCreatorUI } from '../ui/characterCreatorUI.js';
  6 | import { AdModal } from '../ui/adModal.js';
  7 | import { InventoryUI } from '../ui/inventoryUI.js';
  8 | import { MapUI } from '../ui/mapUI.js';
  9 | import { OptionsUI } from '../ui/optionsUI.js';
 10 | import { CompassUI } from '../ui/compassUI.js';
 11 | 
 12 | export class UIManager {
 13 |     constructor(dependencies) {
 14 |         this.dependencies = dependencies;
 15 |         this.inventoryUI = null;
 16 |         this.mapUI = null;
 17 |         this.optionsUI = null;
 18 |         this.chatUI = null;
 19 |         this.compassUI = null;
 20 |         this.tooltipElement = null;
 21 |     }
 22 | 
 23 |     init() {
 24 |         new BuildUI(this.dependencies).create();
 25 |         new AdvancedBuildUI(this.dependencies).create();
 26 |         new ChangelogUI(this.dependencies).create();
 27 |         
 28 |         this.chatUI = new ChatUI(this.dependencies);
 29 |         this.chatUI.create();
 30 |         
 31 |         new CharacterCreatorUI(this.dependencies).create();
 32 |         
 33 |         this.optionsUI = new OptionsUI(this.dependencies);
 34 |         this.optionsUI.create();
 35 |         
 36 |         new AdModal(this.dependencies).setup();
 37 | 
 38 |         this.inventoryUI = new InventoryUI(this.dependencies);
 39 |         this.inventoryUI.create();
 40 | 
 41 |         this.mapUI = new MapUI(this.dependencies);
 42 |         this.mapUI.create();
 43 | 
 44 |         this.compassUI = new CompassUI(this.dependencies);
 45 |         this.compassUI.create();
 46 | 
 47 |         this.initTooltip();
 48 | 
 49 |         return {
 50 |             inventoryUI: this.inventoryUI,
 51 |             mapUI: this.mapUI,
 52 |         };
 53 |     }
 54 | 
 55 |     initTooltip() {
 56 |         this.tooltipElement = document.createElement('div');
 57 |         this.tooltipElement.className = 'tooltip';
 58 |         document.body.appendChild(this.tooltipElement);
 59 |         
 60 |         document.addEventListener('mouseover', (e) => {
 61 |             const target = e.target.closest('[data-tooltip]');
 62 |             if (target) {
 63 |                 this.tooltipElement.textContent = target.getAttribute('data-tooltip');
 64 |                 this.tooltipElement.style.opacity = '1';
 65 |                 this.updateTooltipPosition(e);
 66 |             }
 67 |         });
 68 | 
 69 |         document.addEventListener('mouseout', (e) => {
 70 |             const target = e.target.closest('[data-tooltip]');
 71 |             if (target) {
 72 |                 this.tooltipElement.style.opacity = '0';
 73 |             }
 74 |         });
 75 |         
 76 |         document.addEventListener('mousemove', (e) => {
 77 |             if (this.tooltipElement.style.opacity === '1') {
 78 |                 this.updateTooltipPosition(e);
 79 |             }
 80 |         });
 81 |     }
 82 | 
 83 |     updateTooltipPosition(event) {
 84 |         let x = event.clientX + 15;
 85 |         let y = event.clientY + 15;
 86 |         
 87 |         const tooltipRect = this.tooltipElement.getBoundingClientRect();
 88 |         const bodyRect = document.body.getBoundingClientRect();
 89 | 
 90 |         if (x + tooltipRect.width > bodyRect.width) {
 91 |             x = event.clientX - tooltipRect.width - 15;
 92 |         }
 93 |         if (y + tooltipRect.height > bodyRect.height) {
 94 |             y = event.clientY - tooltipRect.height - 15;
 95 |         }
 96 | 
 97 |         this.tooltipElement.style.left = `${x}px`;
 98 |         this.tooltipElement.style.top = `${y}px`;
 99 |     }
100 | 
101 |     update() {
102 |         if (this.chatUI) {
103 |             this.chatUI.update();
104 |         }
105 |         if (this.compassUI) {
106 |             this.compassUI.update();
107 |         }
108 |     }
109 | }


--------------------------------------------------------------------------------
/js/world.js:
--------------------------------------------------------------------------------
 1 | import * as THREE from 'three';
 2 | import { createTerrain, createBarriers, createTrees, createClouds, createStarterHouse, createShopkeeper, createAmphitheatre } from './worldGeneration.js';
 3 | 
 4 | export class World {
 5 |     constructor(scene, npcManager) {
 6 |         this.scene = scene;
 7 |         this.npcManager = npcManager;
 8 |         this.terrain = null;
 9 |     }
10 | 
11 |     generate(listener) {
12 |         this.terrain = createTerrain(this.scene);
13 |         createBarriers(this.scene, this.terrain.userData.getHeight);
14 |         createTrees(this.scene, this.terrain.userData.getHeight);
15 |         createClouds(this.scene);
16 |         const house = createStarterHouse(this.scene, this.terrain.userData.getHeight);
17 |         createShopkeeper(this.scene, this.terrain, this.npcManager, house.position);
18 |         createAmphitheatre(this.scene, this.terrain.userData.getHeight, listener);
19 |         return this.terrain;
20 |     }
21 | }
22 | 
23 | 


--------------------------------------------------------------------------------
/js/worldGeneration.js:
--------------------------------------------------------------------------------
 1 | export * from './worldgen/constants.js';
 2 | export { createTerrain } from './worldgen/terrain.js';
 3 | export { createBarriers } from './worldgen/barriers.js';
 4 | export { createTrees } from './worldgen/trees.js';
 5 | export { createClouds } from './worldgen/clouds.js';
 6 | export { createStarterHouse } from './worldgen/starterHouse.js';
 7 | export { createGroundGrid } from './worldgen/groundGrid.js';
 8 | export { createShopkeeper } from './worldgen/shopkeeper.js';
 9 | export { createAmphitheatre } from './worldgen/amphitheatre.js';
10 | 
11 | 
12 | 


--------------------------------------------------------------------------------
/js/worldgen/amphitheatre.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | 
  3 | /* =====================
  4 |    GENERAL TWEAKABLES
  5 |    ===================== */
  6 | /* @tweakable The color of the stone used for the amphitheater seats and structure. */
  7 | const stoneColor = 0x888888;
  8 | /* @tweakable The color of the stage platform. */
  9 | const stageColor = 0x4a2a0a;
 10 | /* @tweakable Set to false to disable the video backdrop, which may prevent console errors from ad-blockers. */
 11 | const enableVideoBackdrop = true;
 12 | 
 13 | /* =====================
 14 |    MICROPHONE STAND
 15 |    ===================== */
 16 | function createMicrophoneStand() {
 17 |     const standGroup = new THREE.Group();
 18 | 
 19 |     /* @tweakable The color of the microphone stand. */
 20 |     const standColor = 0x333333;
 21 |     /* @tweakable The color of the microphone head. */
 22 |     const micColor = 0x111111;
 23 | 
 24 |     const standMaterial = new THREE.MeshStandardMaterial({ color: standColor, roughness: 0.4, metalness: 0.8 });
 25 |     const micMaterial = new THREE.MeshStandardMaterial({ color: micColor, roughness: 0.6, metalness: 0.2 });
 26 | 
 27 |     // Base
 28 |     const baseRadius = 0.3;
 29 |     const baseHeight = 0.05;
 30 |     const baseGeometry = new THREE.CylinderGeometry(baseRadius, baseRadius, baseHeight, 16);
 31 |     const base = new THREE.Mesh(baseGeometry, standMaterial);
 32 |     base.position.y = baseHeight / 2;
 33 |     standGroup.add(base);
 34 | 
 35 |     // Pole
 36 |     const poleHeight = 1.5;
 37 |     const poleRadius = 0.02;
 38 |     const poleGeometry = new THREE.CylinderGeometry(poleRadius, poleRadius, poleHeight, 8);
 39 |     const pole = new THREE.Mesh(poleGeometry, standMaterial);
 40 |     pole.position.y = baseHeight + poleHeight / 2;
 41 |     standGroup.add(pole);
 42 | 
 43 |     // Mic head
 44 |     const micHeadRadius = 0.08;
 45 |     const micHeadGeometry = new THREE.SphereGeometry(micHeadRadius, 16, 16);
 46 |     const micHead = new THREE.Mesh(micHeadGeometry, micMaterial);
 47 |     micHead.position.y = baseHeight + poleHeight + micHeadRadius * 0.8;
 48 |     standGroup.add(micHead);
 49 | 
 50 |     standGroup.traverse(child => { if (child.isMesh) child.castShadow = true; });
 51 |     return standGroup;
 52 | }
 53 | 
 54 | /* =====================
 55 |    STAGE
 56 |    ===================== */
 57 | function createStage(dimensions) {
 58 |     const stageGroup = new THREE.Group();
 59 |     const stageMaterial = new THREE.MeshStandardMaterial({ color: stageColor, roughness: 0.8, metalness: 0.1 });
 60 | 
 61 |     // Platform
 62 |     const stageGeometry = new THREE.BoxGeometry(dimensions.width, dimensions.height, dimensions.depth);
 63 |     const stage = new THREE.Mesh(stageGeometry, stageMaterial);
 64 |     stage.position.y = dimensions.height / 2;
 65 |     stage.castShadow = true;
 66 |     stage.receiveShadow = true;
 67 |     stage.userData.isBlock = true;
 68 |     stageGroup.add(stage);
 69 | 
 70 |     // Central Stairs
 71 |     const stairRotationY = 0;
 72 |     const stairsGroup = new THREE.Group();
 73 |     stairsGroup.rotation.y = THREE.MathUtils.degToRad(stairRotationY);
 74 |     stageGroup.add(stairsGroup);
 75 | 
 76 |     const stairCount = 4;
 77 |     const stairHeight = dimensions.height / stairCount;
 78 |     const stairDepth = 0.5;
 79 |     const stairStartZ = -dimensions.depth / 2 - stairDepth / 2;
 80 | 
 81 |     for (let i = 0; i < stairCount; i++) {
 82 |         const stairWidth = dimensions.width * (0.4 - i * 0.05);
 83 |         const stairGeometry = new THREE.BoxGeometry(stairWidth, stairHeight, stairDepth);
 84 |         const stair = new THREE.Mesh(stairGeometry, stageMaterial);
 85 |         stair.position.set(0, i * stairHeight + stairHeight / 2, stairStartZ - (stairCount - 1 - i) * stairDepth);
 86 |         stair.castShadow = true;
 87 |         stair.receiveShadow = true;
 88 |         stair.userData.isBlock = true;
 89 |         stair.userData.isStair = true;
 90 |         stairsGroup.add(stair);
 91 |     }
 92 | 
 93 |     return stageGroup;
 94 | }
 95 | 
 96 | /* =====================
 97 |    SEATING ROWS (NEW)
 98 |    ===================== */
 99 | const tierThickness = 0.3;
100 | const tierDepth = 1.6;
101 | const benchWidth = 1.2;
102 | const benchDepth = 0.5;
103 | const benchHeight = 0.6;
104 | 
105 | function createSeatRow(rowIndex, innerRadius, seatCount, rowHeightStep) {
106 |     const rowGroup = new THREE.Group();
107 |     const seatingMaterial = new THREE.MeshStandardMaterial({ color: stoneColor, roughness: 0.9, metalness: 0.05 });
108 | 
109 |     const outerRadius = innerRadius + tierDepth;
110 |     const yBase = rowIndex * rowHeightStep;
111 | 
112 |     const platformShape = new THREE.Shape();
113 |     platformShape.absarc(0, 0, innerRadius, 0, Math.PI, false);
114 |     platformShape.absarc(0, 0, outerRadius, Math.PI, 0, true);
115 |     platformShape.closePath();
116 | 
117 |     const extrudeSettings = { depth: tierThickness, bevelEnabled: false, steps: 1 };
118 |     const platformGeo = new THREE.ExtrudeGeometry(platformShape, extrudeSettings);
119 |     const platformMesh = new THREE.Mesh(platformGeo, seatingMaterial);
120 |     platformMesh.rotation.x = -Math.PI / 2;
121 |     platformMesh.position.y = yBase;
122 |     platformMesh.castShadow = true;
123 |     platformMesh.receiveShadow = true;
124 |     platformMesh.userData.isBlock = true;
125 |     rowGroup.add(platformMesh);
126 | 
127 |     platformMesh.userData.isSeatRow = true;
128 |     platformMesh.userData.seatRowData = {
129 |         innerRadius,
130 |         outerRadius,
131 |         height: tierThickness,
132 |         y: yBase
133 |     };
134 | 
135 |     const benchGeometry = new THREE.BoxGeometry(benchWidth, benchHeight, benchDepth);
136 |     for (let i = 0; i < seatCount; i++) {
137 |         const angle = Math.PI * ((i + 0.5) / seatCount);
138 |         const radiusForBench = innerRadius + tierDepth / 2;
139 |         const x = radiusForBench * Math.cos(angle);
140 |         const z = radiusForBench * Math.sin(angle);
141 |         const bench = new THREE.Mesh(benchGeometry, seatingMaterial);
142 |         bench.position.set(x, yBase + tierThickness + benchHeight / 2, z);
143 |         bench.rotation.y = -angle + Math.PI / 2;
144 |         bench.castShadow = true;
145 |         bench.receiveShadow = true;
146 |         bench.userData.isBlock = true;
147 |         rowGroup.add(bench);
148 |     }
149 | 
150 |     return rowGroup;
151 | }
152 | 
153 | /* =====================
154 |    BACKDROP WALL (unchanged)
155 |    ===================== */
156 | function createBackdropWall(position, videoSrc, listener) {
157 |     const wallGroup = new THREE.Group();
158 | 
159 |     const wallHeight = 15;
160 |     const backdropWidth = 40;
161 |     const wallThickness = 0.5;
162 | 
163 |     if (enableVideoBackdrop && videoSrc) {
164 |         const video = document.createElement('video');
165 |         video.src = videoSrc;
166 |         video.crossOrigin = 'anonymous';
167 |         video.loop = true;
168 |         video.playsInline = true;
169 | 
170 |         if (listener) {
171 |             video.muted = true;
172 |             const sound = new THREE.PositionalAudio(listener);
173 |             sound.setMediaElementSource(video);
174 |             sound.setRefDistance(20);
175 |             sound.setRolloffFactor(1);
176 |             sound.setVolume(0.5);
177 |             wallGroup.add(sound);
178 |         } else {
179 |             video.muted = true;
180 |         }
181 | 
182 |         const playPromise = video.play();
183 |         if (playPromise !== undefined) {
184 |             playPromise.catch(() => {
185 |                 document.body.addEventListener('click', () => { if (video.paused) video.play(); }, { once: true });
186 |             });
187 |         }
188 | 
189 |         const texture = new THREE.VideoTexture(video);
190 |         const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.FrontSide });
191 |         const geometry = new THREE.PlaneGeometry(backdropWidth, wallHeight);
192 |         const videoMesh = new THREE.Mesh(geometry, material);
193 |         videoMesh.position.set(0, 0, wallThickness / 2 + 0.01);
194 |         videoMesh.rotation.y = Math.PI;
195 |         wallGroup.add(videoMesh);
196 |     }
197 | 
198 |     const wallMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.7, metalness: 0.2 });
199 |     const wallGeometry = new THREE.BoxGeometry(backdropWidth, wallHeight, wallThickness);
200 |     const backingWall = new THREE.Mesh(wallGeometry, wallMaterial);
201 |     backingWall.castShadow = true;
202 |     backingWall.receiveShadow = true;
203 |     wallGroup.add(backingWall);
204 | 
205 |     wallGroup.position.copy(position);
206 |     return { wall: wallGroup };
207 | }
208 | 
209 | /* =====================
210 |    MAIN CONSTRUCTION API
211 |    ===================== */
212 | export function createAmphitheatre(scene, getHeight, listener) {
213 |     const amphitheatrePosition = new THREE.Vector3(49.5, 0, 16.5);
214 |     amphitheatrePosition.y = getHeight(amphitheatrePosition.x, amphitheatrePosition.z);
215 | 
216 |     const group = new THREE.Group();
217 |     group.name = 'amphitheatre';
218 |     group.position.copy(amphitheatrePosition);
219 |     scene.add(group);
220 | 
221 |     const stageDimensions = { width: 20, height: 1.5, depth: 15 };
222 |     const stage = createStage(stageDimensions);
223 |     stage.position.z = 10;
224 |     group.add(stage);
225 | 
226 |     const micStand = createMicrophoneStand();
227 |     micStand.position.set(0, stageDimensions.height, 2);
228 |     stage.add(micStand);
229 | 
230 |     const numRows = 12;
231 |     const startRadius = 25;
232 |     const rowSpacing = 3.5;
233 |     const rowHeightStep = 0.8;
234 | 
235 |     for (let i = 0; i < numRows; i++) {
236 |         const innerRadius = startRadius + i * rowSpacing;
237 |         const arcLength = Math.PI * innerRadius;
238 |         const seatCount = Math.max(6, Math.floor(arcLength / (benchWidth * 1.1)));
239 |         const seatRowGroup = createSeatRow(i, innerRadius, seatCount, rowHeightStep);
240 |         group.add(seatRowGroup);
241 |     }
242 | 
243 |     const videoSrc = 'https://cdn.pixabay.com/video/2023/07/25/174411-849537965_large.mp4';
244 |     const backdropZOffset = 30;
245 |     const wallHeight = 15;
246 |     const backdropPosition = new THREE.Vector3(0, stageDimensions.height + wallHeight / 2, backdropZOffset);
247 |     const backdropData = createBackdropWall(backdropPosition, videoSrc, listener);
248 |     group.add(backdropData.wall);
249 | 
250 |     const spotLight1 = new THREE.SpotLight(0xffffff, 200);
251 |     spotLight1.position.set(-20, 30, 40);
252 |     spotLight1.target = stage;
253 |     spotLight1.angle = Math.PI / 8;
254 |     spotLight1.penumbra = 0.3;
255 |     spotLight1.castShadow = true;
256 |     group.add(spotLight1);
257 | 
258 |     const spotLight2 = new THREE.SpotLight(0xffffff, 200);
259 |     spotLight2.position.set(20, 30, 40);
260 |     spotLight2.target = stage;
261 |     spotLight2.angle = Math.PI / 8;
262 |     spotLight2.penumbra = 0.3;
263 |     spotLight2.castShadow = true;
264 |     group.add(spotLight2);
265 | 
266 |     return group;
267 | }
268 | 


--------------------------------------------------------------------------------
/js/worldgen/barriers.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { MathRandom } from './random.js';
  3 | import {
  4 |   ZONES_PER_CHUNK_SIDE,
  5 |   CHUNKS_PER_CLUSTER_SIDE,
  6 |   CLUSTER_SIZE,
  7 |   BARRIERS_PER_ZONE,
  8 |   PILLARS_PER_ZONE,
  9 |   SPAWN_SAFE_RADIUS,
 10 |   AMPHITHEATRE_CLEARING_RADIUS
 11 | } from './constants.js';
 12 | import { createAmphitheatre } from './amphitheatre.js';
 13 | 
 14 | let amphitheatrePosition = null;
 15 | 
 16 | export function createBarriers(scene, getHeight) {
 17 |   // We get the position from the created amphitheater instance to avoid circular dependency issues
 18 |   // and ensure we're using the same position data.
 19 |   if (!amphitheatrePosition) {
 20 |     const amp = scene.children.find(c => c.name === 'amphitheatre');
 21 |     if (amp) {
 22 |       amphitheatrePosition = amp.position;
 23 |     }
 24 |   }
 25 | 
 26 |   const barrierSeed = 12345;
 27 |   let rng = new MathRandom(barrierSeed);
 28 |   const totalZones = ZONES_PER_CHUNK_SIDE * CHUNKS_PER_CLUSTER_SIDE * ZONES_PER_CHUNK_SIDE * CHUNKS_PER_CLUSTER_SIDE;
 29 |   const worldRadius = CLUSTER_SIZE / 2;
 30 | 
 31 |   const wallMaterial = new THREE.MeshStandardMaterial({
 32 |     color: 0x888888,
 33 |     roughness: 0.7,
 34 |     metalness: 0.2
 35 |   });
 36 | 
 37 |   for (let i = 0; i < totalZones * BARRIERS_PER_ZONE; i++) {
 38 |     const width = 1 + rng.random() * 3;
 39 |     const height = 1 + rng.random() * 3;
 40 |     const depth = 1 + rng.random() * 3;
 41 | 
 42 |     const wallGeometry = new THREE.BoxGeometry(width, height, depth);
 43 |     const wall = new THREE.Mesh(wallGeometry, wallMaterial);
 44 | 
 45 |     const angle = rng.random() * Math.PI * 2;
 46 |     const distance = SPAWN_SAFE_RADIUS + rng.random() * (worldRadius - SPAWN_SAFE_RADIUS);
 47 |     const x = Math.cos(angle) * distance;
 48 |     const z = Math.sin(angle) * distance;
 49 | 
 50 |     if (amphitheatrePosition) {
 51 |       const distToAmphitheatre = Math.sqrt(Math.pow(x - amphitheatrePosition.x, 2) + Math.pow(z - amphitheatrePosition.z, 2));
 52 |       if (distToAmphitheatre < AMPHITHEATRE_CLEARING_RADIUS) {
 53 |           continue;
 54 |       }
 55 |     }
 56 |     
 57 |     wall.position.x = x;
 58 |     wall.position.z = z;
 59 |     const terrainHeight = getHeight ? getHeight(wall.position.x, wall.position.z) : 0;
 60 |     wall.position.y = terrainHeight + height / 2;
 61 | 
 62 |     wall.castShadow = true;
 63 |     wall.receiveShadow = true;
 64 |     wall.userData.isBarrier = true;
 65 | 
 66 |     scene.add(wall);
 67 |   }
 68 | 
 69 |   const pillarCount = totalZones * PILLARS_PER_ZONE;
 70 |   for (let i = 0; i < pillarCount; i++) {
 71 |     const angle = rng.random() * Math.PI * 2;
 72 |     const distance = SPAWN_SAFE_RADIUS + rng.random() * (worldRadius - SPAWN_SAFE_RADIUS);
 73 |     const x = Math.cos(angle) * distance;
 74 |     const z = Math.sin(angle) * distance;
 75 | 
 76 |     if (amphitheatrePosition) {
 77 |       const distToAmphitheatre = Math.sqrt(Math.pow(x - amphitheatrePosition.x, 2) + Math.pow(z - amphitheatrePosition.z, 2));
 78 |       if (distToAmphitheatre < AMPHITHEATRE_CLEARING_RADIUS) {
 79 |           continue;
 80 |       }
 81 |     }
 82 | 
 83 |     const pillarHeight = 2 + rng.random() * 15;
 84 |     const pillarWidth = 0.8 + rng.random() * 0.6;
 85 |     const pillarGeo = new THREE.BoxGeometry(pillarWidth, pillarHeight, pillarWidth);
 86 | 
 87 |     const pillarMaterial = new THREE.MeshStandardMaterial({
 88 |       color: 0xaaaaaa,
 89 |       roughness: 0.6,
 90 |       metalness: 0.3
 91 |     });
 92 | 
 93 |     const pillar = new THREE.Mesh(pillarGeo, pillarMaterial);
 94 |     const terrainPillarHeight = getHeight ? getHeight(x, z) : 0;
 95 |     pillar.position.set(x, terrainPillarHeight + pillarHeight / 2, z);
 96 |     pillar.castShadow = true;
 97 |     pillar.receiveShadow = true;
 98 |     pillar.userData.isBarrier = true;
 99 | 
100 |     const capSize = pillarWidth * 1.5;
101 |     const capHeight = 0.5;
102 |     const capGeo = new THREE.BoxGeometry(capSize, capHeight, capSize);
103 |     const cap = new THREE.Mesh(capGeo, wallMaterial);
104 |     cap.position.y = pillarHeight / 2 + capHeight / 2;
105 |     pillar.add(cap);
106 | 
107 |     if (rng.random() < 0.25) {
108 |       const remoteGeo = new THREE.BoxGeometry(0.3, 0.1, 0.15);
109 |       const remoteMaterial = new THREE.MeshStandardMaterial({
110 |         color: 0xff0000,
111 |         roughness: 0.3,
112 |         metalness: 0.7,
113 |         emissive: 0xff0000,
114 |         emissiveIntensity: 0.3
115 |       });
116 | 
117 |       const remote = new THREE.Mesh(remoteGeo, remoteMaterial);
118 |       remote.position.y = pillarHeight / 2 + capHeight + 0.1;
119 |       remote.rotation.y = Math.PI * rng.random();
120 |       remote.castShadow = true;
121 |       remote.userData.isRemote = true;
122 |       remote.userData.remoteId = `remote_${i}`;
123 |       pillar.add(remote);
124 | 
125 |       const buttonGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.02, 8);
126 |       const buttonMaterial = new THREE.MeshStandardMaterial({ color: 0x000000 });
127 |       const button = new THREE.Mesh(buttonGeo, buttonMaterial);
128 |       button.position.set(0, 0.06, 0);
129 |       button.rotation.x = Math.PI / 2;
130 |       remote.add(button);
131 |     }
132 | 
133 |     scene.add(pillar);
134 |   }
135 | }


--------------------------------------------------------------------------------
/js/worldgen/clouds.js:
--------------------------------------------------------------------------------
 1 | import * as THREE from 'three';
 2 | import { MathRandom } from './random.js';
 3 | import { CLUSTER_SIZE, CLOUD_COUNT } from './constants.js';
 4 | 
 5 | /* @tweakable The lowest altitude for clouds. */
 6 | const MIN_CLOUD_ALTITUDE = 20;
 7 | /* @tweakable The range of altitudes for clouds (Min + Range). */
 8 | const CLOUD_ALTITUDE_RANGE = 15;
 9 | /* @tweakable The minimum number of puffs per cloud group. */
10 | const MIN_CLOUD_PUFFS = 3;
11 | /* @tweakable The additional random number of puffs per cloud group. */
12 | const RAND_CLOUD_PUFFS = 5;
13 | 
14 | export function createClouds(scene) {
15 |   const cloudSeed = 67890;
16 |   let rng = new MathRandom(cloudSeed);
17 |   const worldRadius = CLUSTER_SIZE / 2;
18 | 
19 |   const cloudMaterial = new THREE.MeshStandardMaterial({
20 |     color: 0xffffff,
21 |     opacity: 0.95,
22 |     transparent: true,
23 |     roughness: 0.9,
24 |     metalness: 0.0,
25 |     emissive: 0xcccccc,
26 |     emissiveIntensity: 0.2
27 |   });
28 | 
29 |   for (let i = 0; i < CLOUD_COUNT; i++) {
30 |     const cloudGroup = new THREE.Group();
31 |     const puffCount = MIN_CLOUD_PUFFS + Math.floor(rng.random() * RAND_CLOUD_PUFFS);
32 |     for (let j = 0; j < puffCount; j++) {
33 |       const puffSize = 2 + rng.random() * 3;
34 |       const puffGeometry = new THREE.SphereGeometry(puffSize, 7, 7);
35 |       const puff = new THREE.Mesh(puffGeometry, cloudMaterial);
36 |       puff.position.x = (rng.random() - 0.5) * 5;
37 |       puff.position.y = (rng.random() - 0.5) * 2;
38 |       puff.position.z = (rng.random() - 0.5) * 5;
39 |       cloudGroup.add(puff);
40 |     }
41 | 
42 |     const angle = rng.random() * Math.PI * 2;
43 |     const distance = rng.random() * worldRadius * 1.5;
44 |     cloudGroup.position.x = Math.cos(angle) * distance;
45 |     cloudGroup.position.z = Math.sin(angle) * distance;
46 |     cloudGroup.position.y = MIN_CLOUD_ALTITUDE + rng.random() * CLOUD_ALTITUDE_RANGE;
47 | 
48 |     cloudGroup.rotation.y = rng.random() * Math.PI * 2;
49 |     scene.add(cloudGroup);
50 |   }
51 | }


--------------------------------------------------------------------------------
/js/worldgen/constants.js:
--------------------------------------------------------------------------------
 1 | /* @tweakable The size of a single zone. Affects NPC spawning density. Reload required. */
 2 | export const ZONE_SIZE = 50;
 3 | /* @tweakable Number of zones along one side of a chunk. Reload required. */
 4 | export const ZONES_PER_CHUNK_SIDE = 5;
 5 | /* @tweakable Number of chunks along one side of a cluster. Affects total world size. Reload required. */
 6 | export const CHUNKS_PER_CLUSTER_SIDE = 2;
 7 | 
 8 | export const CHUNK_SIZE = ZONE_SIZE * ZONES_PER_CHUNK_SIDE;
 9 | export const CLUSTER_SIZE = CHUNK_SIZE * CHUNKS_PER_CLUSTER_SIDE;
10 | export const SPAWN_SAFE_RADIUS = 10;
11 | 
12 | export const TERRAIN_AMPLITUDE = 10;
13 | export const TERRAIN_SCALE = 80;
14 | export const TERRAIN_TEXTURE_REPEAT_PER_ZONE = 50;
15 | export const TERRAIN_SEGMENTS = 250;
16 | /* @tweakable The number of barriers generated per zone. Lower for better performance. Reload required. */
17 | export const BARRIERS_PER_ZONE = 0.3;
18 | export const PILLARS_PER_ZONE = 0.2;
19 | /* @tweakable The number of trees generated per zone. Lower for better performance. Reload required. */
20 | export const TREES_PER_ZONE = 0.5;
21 | /* @tweakable The total number of cloud groups to generate. Lower for better performance. Reload required. */
22 | export const CLOUD_COUNT = 100;
23 | 
24 | /* @tweakable The radius around the amphitheater to keep clear of trees and barriers. Reload required on change. */
25 | export const AMPHITHEATRE_CLEARING_RADIUS = 60;


--------------------------------------------------------------------------------
/js/worldgen/groundGrid.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
  3 | 
  4 | /**
  5 |  * Converts a number to a base-26 alphabetical representation (A, B, ..., Z, AA, AB, ...).
  6 |  * @param {number} num - The number to convert (0-indexed).
  7 |  * @returns {string} The alphabetical representation.
  8 |  */
  9 | function toBase26(num) {
 10 |     let result = '';
 11 |     do {
 12 |         result = String.fromCharCode(65 + (num % 26)) + result;
 13 |         num = Math.floor(num / 26) - 1;
 14 |     } while (num >= 0);
 15 |     return result;
 16 | }
 17 | 
 18 | /**
 19 |  * Creates a grid that conforms to the terrain's elevation, with labels.
 20 |  * @param {THREE.Mesh} terrain - The terrain mesh, with a `userData.getHeight` function.
 21 |  * @param {number} size - The total width and depth of the grid.
 22 |  * @param {number} divisions - The number of grid cells along each axis.
 23 |  * @param {THREE.Color | number | string} colorCenterLine - The color of the center grid lines.
 24 |  * @param {THREE.Color | number | string} colorGrid - The color of the other grid lines.
 25 |  * @returns {THREE.Group} A group containing the grid lines and labels.
 26 |  */
 27 | export function createGroundGrid(terrain, size, divisions, colorCenterLine, colorGrid) {
 28 |     const group = new THREE.Group();
 29 |     const vertices = [];
 30 |     const colors = [];
 31 | 
 32 |     const center = divisions / 2;
 33 |     const step = size / divisions;
 34 |     const halfSize = size / 2;
 35 |     /* @tweakable The vertical offset of the grid from the ground to prevent z-fighting. */
 36 |     const gridOffsetY = 0.05;
 37 |     /* @tweakable Number of subdivisions per grid line for better terrain conformity. Higher is more accurate but less performant. */
 38 |     const lineSubdivisions = 4;
 39 | 
 40 |     const colorCenter = new THREE.Color(colorCenterLine);
 41 |     const colorGridLines = new THREE.Color(colorGrid);
 42 |     
 43 |     const subStep = step / lineSubdivisions;
 44 | 
 45 |     for (let i = 0; i <= divisions; i++) {
 46 |         // lines in z direction (parallel to z-axis)
 47 |         for (let j = 0; j < divisions; j++) {
 48 |             const x = -halfSize + i * step;
 49 |             for (let k = 0; k < lineSubdivisions; k++) {
 50 |                 const z1 = -halfSize + j * step + k * subStep;
 51 |                 const z2 = -halfSize + j * step + (k + 1) * subStep;
 52 | 
 53 |                 const y1 = terrain.userData.getHeight(x, z1) + gridOffsetY;
 54 |                 const y2 = terrain.userData.getHeight(x, z2) + gridOffsetY;
 55 | 
 56 |                 vertices.push(x, y1, z1, x, y2, z2);
 57 | 
 58 |                 const color = i === center ? colorCenter : colorGridLines;
 59 |                 colors.push(color.r, color.g, color.b, color.r, color.g, color.b);
 60 |             }
 61 |         }
 62 | 
 63 |         // lines in x direction (parallel to x-axis)
 64 |         for (let j = 0; j < divisions; j++) {
 65 |             const z = -halfSize + i * step;
 66 |              for (let k = 0; k < lineSubdivisions; k++) {
 67 |                 const x1 = -halfSize + j * step + k * subStep;
 68 |                 const x2 = -halfSize + j * step + (k + 1) * subStep;
 69 |                 
 70 |                 const y1 = terrain.userData.getHeight(x1, z) + gridOffsetY;
 71 |                 const y2 = terrain.userData.getHeight(x2, z) + gridOffsetY;
 72 | 
 73 |                 vertices.push(x1, y1, z, x2, y2, z);
 74 | 
 75 |                 const color = i === center ? colorCenter : colorGridLines;
 76 |                 colors.push(color.r, color.g, color.b, color.r, color.g, color.b);
 77 |             }
 78 |         }
 79 |     }
 80 |     
 81 |     const geometry = new THREE.BufferGeometry();
 82 |     geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
 83 |     geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
 84 | 
 85 |     const material = new THREE.LineBasicMaterial({ vertexColors: true });
 86 |     
 87 |     const lines = new THREE.LineSegments(geometry, material);
 88 |     group.add(lines);
 89 | 
 90 |     /* @tweakable The vertical offset of grid labels from the ground. */
 91 |     const labelOffsetY = 0.2;
 92 | 
 93 |     const labelsGroup = new THREE.Group();
 94 |     labelsGroup.name = 'grid-labels-group'; // Add name for easy lookup
 95 |     group.add(labelsGroup);
 96 | 
 97 |     group.userData.isGridHelper = true;
 98 | 
 99 |     // Store data needed for dynamic label generation
100 |     group.userData.terrain = terrain;
101 |     group.userData.size = size;
102 |     group.userData.divisions = divisions;
103 |     group.userData.step = step;
104 |     group.userData.halfSize = halfSize;
105 |     group.userData.labelOffsetY = labelOffsetY;
106 |     group.userData.labelsGroup = labelsGroup;
107 |     group.userData.activeLabels = new Map();
108 | 
109 |     /**
110 |      * Dynamically update which grid labels are displayed based on the
111 |      * player's position. Labels are created only when needed and removed
112 |      * when out of range to avoid excessive DOM nodes.
113 |      *
114 |      * @param {THREE.Vector3} playerPosition - The current player position.
115 |      * @param {number} fullDist - Distance for full label density.
116 |      * @param {number} lodDist - Distance for level-of-detail label density.
117 |      * @param {number} lodStep - Step interval used when applying the LOD rule.
118 |      */
119 |     group.userData.updateLabels = function(playerPosition, fullDist, lodDist, lodStep) {
120 |         const step = this.step;
121 |         const halfSize = this.halfSize;
122 |         const divisions = this.divisions;
123 |         const labelOffsetY = this.labelOffsetY;
124 |         const terrain = this.terrain;
125 |         const cellRadius = Math.ceil(lodDist / step);
126 |         const centerI = Math.floor((playerPosition.x + halfSize) / step);
127 |         const centerJ = Math.floor((playerPosition.z + halfSize) / step);
128 |         const visibleKeys = new Set();
129 | 
130 |         for (let i = centerI - cellRadius; i <= centerI + cellRadius; i++) {
131 |             if (i < 0 || i >= divisions) continue;
132 |             for (let j = centerJ - cellRadius; j <= centerJ + cellRadius; j++) {
133 |                 if (j < 0 || j >= divisions) continue;
134 | 
135 |                 const x = -halfSize + (i + 0.5) * step;
136 |                 const z = -halfSize + (j + 0.5) * step;
137 |                 const y = terrain.userData.getHeight(x, z) + labelOffsetY;
138 | 
139 |                 const dx = x - playerPosition.x;
140 |                 const dy = y - playerPosition.y;
141 |                 const dz = z - playerPosition.z;
142 |                 const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
143 | 
144 |                 let visible = false;
145 |                 if (distance < fullDist) {
146 |                     visible = true;
147 |                 } else if (distance < lodDist) {
148 |                     visible = (i % lodStep === 0) && (j % lodStep === 0);
149 |                 }
150 | 
151 |                 if (visible) {
152 |                     const key = `${i},${j}`;
153 |                     visibleKeys.add(key);
154 |                     let label = this.activeLabels.get(key);
155 |                     if (!label) {
156 |                         const labelDiv = document.createElement('div');
157 |                         labelDiv.className = 'grid-label';
158 |                         labelDiv.textContent = `${toBase26(i)}${j + 1}`;
159 | 
160 |                         label = new CSS2DObject(labelDiv);
161 |                         label.userData.gridIndices = { i, j };
162 |                         this.labelsGroup.add(label);
163 |                         this.activeLabels.set(key, label);
164 |                     }
165 |                     label.position.set(x, y, z);
166 |                     label.visible = true;
167 |                 }
168 |             }
169 |         }
170 | 
171 |         // Remove labels that are no longer visible
172 |         for (const [key, label] of this.activeLabels.entries()) {
173 |             if (!visibleKeys.has(key)) {
174 |                 this.labelsGroup.remove(label);
175 |                 if (label.element && label.element.parentNode) {
176 |                     label.element.remove();
177 |                 }
178 |                 this.activeLabels.delete(key);
179 |             }
180 |         }
181 |     };
182 | 
183 |     /**
184 |      * Remove all active labels and DOM elements.
185 |      */
186 |     group.userData.clearLabels = function() {
187 |         for (const label of this.activeLabels.values()) {
188 |             this.labelsGroup.remove(label);
189 |             if (label.element && label.element.parentNode) {
190 |                 label.element.remove();
191 |             }
192 |         }
193 |         this.activeLabels.clear();
194 |     };
195 | 
196 |     return group;
197 | }


--------------------------------------------------------------------------------
/js/worldgen/random.js:
--------------------------------------------------------------------------------
 1 | export class MathRandom {
 2 |   constructor(seed) {
 3 |     this.seed = seed;
 4 |   }
 5 | 
 6 |   random() {
 7 |     const x = Math.sin(this.seed++) * 10000;
 8 |     return x - Math.floor(x);
 9 |   }
10 | }
11 | 


--------------------------------------------------------------------------------
/js/worldgen/shopkeeper.js:
--------------------------------------------------------------------------------
 1 | import * as THREE from 'three';
 2 | import { createPlayerModel } from '../playerModel.js';
 3 | import { NPC } from '../npc/NPC.js';
 4 | import { presetCharacters } from '../characters/presets.js';
 5 | 
 6 | /**
 7 |  * Creates a stationary shopkeeper NPC inside the house.
 8 |  * @param {THREE.Scene} scene The main scene.
 9 |  * @param {THREE.Mesh} terrain The terrain mesh.
10 |  * @param {NPCManager} npcManager The NPC manager to register the new NPC.
11 |  * @param {THREE.Vector3} housePosition The position of the house to place the shopkeeper in.
12 |  */
13 | export function createShopkeeper(scene, terrain, npcManager, housePosition) {
14 |     /* @tweakable The relative position of the shopkeeper inside the house. Fine-tune to place them correctly. */
15 |     const shopkeeperRelativePos = new THREE.Vector3(0, 0, -3);
16 |     const shopkeeperPosition = new THREE.Vector3().copy(housePosition).add(shopkeeperRelativePos);
17 | 
18 |     // Adjust Y position to be on top of the terrain/house floor
19 |     const groundY = terrain.userData.getHeight(shopkeeperPosition.x, shopkeeperPosition.z); 
20 |     shopkeeperPosition.y = groundY + 0.2;
21 | 
22 |     const preset = presetCharacters.find(p => p.id === 'alien');
23 |     if (!preset) {
24 |         console.error("Shopkeeper preset ('alien') not found.");
25 |         return;
26 |     }
27 | 
28 |     const model = createPlayerModel(THREE, "Shopkeeper", preset.spec);
29 |     model.position.copy(shopkeeperPosition);
30 |     model.userData.isNpc = true;
31 |     model.name = "Shopkeeper";
32 |     scene.add(model);
33 |     
34 |     // Make the shopkeeper face the door (positive Z direction)
35 |     model.rotation.y = Math.PI;
36 | 
37 |     // Create an NPC instance for interaction logic
38 |     const shopkeeperNpc = new NPC(model, preset.id, 'shopkeeper_zone', false, shopkeeperPosition.clone(), terrain);
39 | 
40 |     // Override the default NPC behavior to make them stationary
41 |     shopkeeperNpc.update = (delta, isVisible) => {
42 |         if (!isVisible) return;
43 |         // The base NPC update handles animation, we just need to prevent movement
44 |     };
45 |     
46 |     // Add the new NPC to the manager to make it interactive
47 |     npcManager.addNpc(shopkeeperNpc);
48 | }


--------------------------------------------------------------------------------
/js/worldgen/starterHouse.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | 
  3 | /* =========================================================================
  4 |  *  HouseBlocks.js ― a building-blocks kit for houses
  5 |  * ------------------------------------------------------------------------- */
  6 | const HouseBlocks = (() => {
  7 |   function createBox(
  8 |     w = 1, h = 1, d = 1,
  9 |     color = 0xffffff,
 10 |     matOpts = {},
 11 |   ) {
 12 |     const geo = new THREE.BoxGeometry(w, h, d);
 13 |     const mat = new THREE.MeshStandardMaterial({ color, ...matOpts });
 14 |     return new THREE.Mesh(geo, mat);
 15 |   }
 16 | 
 17 |   function createCylinder(
 18 |     rTop = 0.5, rBot = 0.5, height = 1,
 19 |     radialSeg = 12,
 20 |     color = 0xffffff,
 21 |     matOpts = {},
 22 |   ) {
 23 |     const geo = new THREE.CylinderGeometry(rTop, rBot, height, radialSeg);
 24 |     const mat = new THREE.MeshStandardMaterial({ color, ...matOpts });
 25 |     return new THREE.Mesh(geo, mat);
 26 |   }
 27 | 
 28 |   function createFoundationSlab(w = 4, d = 4, t = 0.2) {
 29 |     return createBox(w, t, d, 0x7a7a7a);
 30 |   }
 31 | 
 32 |   function createExteriorWall(width, height, thickness = 0.12) {
 33 |     return createBox(width, height, thickness, 0xbfa27b);
 34 |   }
 35 | 
 36 |   function createRoofGable(span = 4, pitch = 0.4, depth = 4, color = 0x883333) {
 37 |     const group = new THREE.Group();
 38 |     // A triangular prism shape is better for a gable roof section.
 39 |     const shape = new THREE.Shape();
 40 |     shape.moveTo(0, 0);
 41 |     shape.lineTo(span / 2, pitch);
 42 |     shape.lineTo(span, 0);
 43 |     shape.lineTo(0, 0);
 44 | 
 45 |     const extrudeSettings = {
 46 |       steps: 1,
 47 |       depth: depth,
 48 |       bevelEnabled: false,
 49 |     };
 50 | 
 51 |     const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
 52 |     const material = new THREE.MeshStandardMaterial({ color: color, side: THREE.DoubleSide });
 53 |     const roofMesh = new THREE.Mesh(geometry, material);
 54 |     
 55 |     // Adjust pivot to be at the center bottom
 56 |     geometry.center();
 57 |     roofMesh.position.y += pitch/2;
 58 | 
 59 |     group.add(roofMesh);
 60 |     return group;
 61 |   }
 62 |   
 63 |   return {
 64 |       createFoundationSlab,
 65 |       createExteriorWall,
 66 |       createRoofGable,
 67 |   };
 68 | })();
 69 | 
 70 | 
 71 | export function createStarterHouse(scene, getHeight) {
 72 |   /* @tweakable The position of the starter house. You may need to reload if you move it far. */
 73 |   const housePosition = new THREE.Vector3(-0.5, 0, 40.5);
 74 |   const houseY = getHeight(housePosition.x, housePosition.z);
 75 |   housePosition.y = houseY;
 76 | 
 77 |   /* @tweakable The width of the starter house. */
 78 |   const houseWidth = 10;
 79 |   /* @tweakable The depth of the starter house. */
 80 |   const houseDepth = 12;
 81 |   /* @tweakable The height of the walls in the starter house. */
 82 |   const wallHeight = 5;
 83 |   /* @tweakable The width of the door in the starter house. */
 84 |   const doorWidth = 1.7;
 85 |   /* @tweakable The height of the door in the starter house. */
 86 |   const doorHeight = 3.0;
 87 |   /* @tweakable The thickness of the walls in the starter house. */
 88 |   const wallThickness = 0.15;
 89 |   /* @tweakable The thickness of the foundation slab. */
 90 |   const foundationThickness = 0.2;
 91 | 
 92 |   const addPart = (mesh) => {
 93 |     mesh.position.add(housePosition);
 94 |     mesh.userData.isBarrier = true;
 95 |     mesh.castShadow = true;
 96 |     mesh.receiveShadow = true;
 97 |     scene.add(mesh);
 98 |   };
 99 | 
100 |   const houseGroup = new THREE.Group();
101 |   houseGroup.position.copy(housePosition);
102 |   scene.add(houseGroup);
103 | 
104 |   const foundation = HouseBlocks.createFoundationSlab(houseWidth, houseDepth, foundationThickness);
105 |   houseGroup.add(foundation);
106 |   foundation.userData.isBarrier = true;
107 |   foundation.castShadow = true;
108 |   foundation.receiveShadow = true;
109 | 
110 |   // The y-position for the center of the walls. They sit on top of the foundation.
111 |   const wallY = foundationThickness / 2 + wallHeight / 2;
112 | 
113 |   const backWall = HouseBlocks.createExteriorWall(houseWidth, wallHeight, wallThickness);
114 |   backWall.position.set(0, wallY, -houseDepth / 2 + wallThickness / 2);
115 |   houseGroup.add(backWall);
116 | 
117 |   const leftWall = HouseBlocks.createExteriorWall(houseDepth, wallHeight, wallThickness);
118 |   leftWall.rotation.y = Math.PI / 2;
119 |   leftWall.position.set(-houseWidth / 2 + wallThickness / 2, wallY, 0);
120 |   houseGroup.add(leftWall);
121 | 
122 |   const rightWall = HouseBlocks.createExteriorWall(houseDepth, wallHeight, wallThickness);
123 |   rightWall.rotation.y = Math.PI / 2;
124 |   rightWall.position.set(houseWidth / 2 - wallThickness / 2, wallY, 0);
125 |   houseGroup.add(rightWall);
126 | 
127 |   const sideWallWidth = (houseWidth - doorWidth) / 2;
128 | 
129 |   const frontWallLeft = HouseBlocks.createExteriorWall(sideWallWidth, wallHeight, wallThickness);
130 |   frontWallLeft.position.set(-doorWidth / 2 - sideWallWidth / 2, wallY, houseDepth / 2 - wallThickness / 2);
131 |   houseGroup.add(frontWallLeft);
132 | 
133 |   const frontWallRight = HouseBlocks.createExteriorWall(sideWallWidth, wallHeight, wallThickness);
134 |   frontWallRight.position.set(doorWidth / 2 + sideWallWidth / 2, wallY, houseDepth / 2 - wallThickness / 2);
135 |   houseGroup.add(frontWallRight);
136 | 
137 |   const lintelHeight = wallHeight - doorHeight;
138 |   const lintel = HouseBlocks.createExteriorWall(doorWidth, lintelHeight, wallThickness);
139 |   lintel.position.set(0, foundationThickness / 2 + doorHeight + lintelHeight / 2, houseDepth / 2 - wallThickness / 2);
140 |   houseGroup.add(lintel);
141 | 
142 |   const roofGroup = HouseBlocks.createRoofGable(houseWidth + 0.5, 1.2, houseDepth + 0.5);
143 |   roofGroup.position.y = wallHeight + foundationThickness / 2;
144 |   houseGroup.add(roofGroup);
145 | 
146 |   houseGroup.traverse((child) => {
147 |     if(child.isMesh) {
148 |         child.userData.isBarrier = true;
149 |         child.castShadow = true;
150 |         child.receiveShadow = true;
151 |     }
152 |   });
153 | 
154 |   return houseGroup;
155 | }


--------------------------------------------------------------------------------
/js/worldgen/terrain.js:
--------------------------------------------------------------------------------
 1 | import * as THREE from 'three';
 2 | import {
 3 |   CLUSTER_SIZE,
 4 |   ZONES_PER_CHUNK_SIDE,
 5 |   CHUNKS_PER_CLUSTER_SIDE,
 6 |   TERRAIN_SEGMENTS,
 7 |   TERRAIN_TEXTURE_REPEAT_PER_ZONE,
 8 |   TERRAIN_AMPLITUDE,
 9 |   TERRAIN_SCALE
10 | } from './constants.js';
11 | 
12 | function simpleNoise(x, z) {
13 |   let a = TERRAIN_AMPLITUDE;
14 |   let f = 1 / TERRAIN_SCALE;
15 |   let y = 0;
16 |   for (let i = 0; i < 4; i++) {
17 |     y += a * (Math.sin(f * x) * Math.cos(f * z));
18 |     a *= 0.5;
19 |     f *= 2.0;
20 |   }
21 |   return y;
22 | }
23 | 
24 | export function createTerrain(scene) {
25 |   const terrainSize = CLUSTER_SIZE;
26 |   const segments = TERRAIN_SEGMENTS;
27 | 
28 |   const geometry = new THREE.PlaneGeometry(terrainSize, terrainSize, segments, segments);
29 |   geometry.rotateX(-Math.PI / 2);
30 | 
31 |   const vertices = geometry.attributes.position.array;
32 |   for (let i = 0, j = 0; i < vertices.length; i++, j += 3) {
33 |     const x = vertices[j];
34 |     const z = vertices[j + 2];
35 |     vertices[j + 1] = simpleNoise(x, z);
36 |   }
37 |   geometry.computeVertexNormals();
38 | 
39 |   const textureLoader = new THREE.TextureLoader();
40 |   const groundTexture = textureLoader.load('ground_texture.png');
41 |   groundTexture.wrapS = THREE.RepeatWrapping;
42 |   groundTexture.wrapT = THREE.RepeatWrapping;
43 |   const totalZonesSide = ZONES_PER_CHUNK_SIDE * CHUNKS_PER_CLUSTER_SIDE;
44 |   groundTexture.repeat.set(
45 |     TERRAIN_TEXTURE_REPEAT_PER_ZONE * totalZonesSide,
46 |     TERRAIN_TEXTURE_REPEAT_PER_ZONE * totalZonesSide
47 |   );
48 | 
49 |   const material = new THREE.MeshStandardMaterial({
50 |     map: groundTexture,
51 |     roughness: 0.8,
52 |     metalness: 0.2
53 |   });
54 | 
55 |   const terrain = new THREE.Mesh(geometry, material);
56 |   terrain.receiveShadow = true;
57 |   terrain.userData.isTerrain = true;
58 |   scene.add(terrain);
59 | 
60 |   const getHeight = (x, z) => {
61 |     const clampedX = Math.max(-terrainSize / 2, Math.min(terrainSize / 2, x));
62 |     const clampedZ = Math.max(-terrainSize / 2, Math.min(terrainSize / 2, z));
63 |     return simpleNoise(clampedX, clampedZ);
64 |   };
65 | 
66 |   terrain.userData.getHeight = getHeight;
67 |   return terrain;
68 | }
69 | 


--------------------------------------------------------------------------------
/js/worldgen/trees.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { MathRandom } from './random.js';
  3 | import {
  4 |   ZONES_PER_CHUNK_SIDE,
  5 |   CHUNKS_PER_CLUSTER_SIDE,
  6 |   CLUSTER_SIZE,
  7 |   TREES_PER_ZONE,
  8 |   SPAWN_SAFE_RADIUS,
  9 |   AMPHITHEATRE_CLEARING_RADIUS
 10 | } from './constants.js';
 11 | 
 12 | let amphitheatrePosition = null;
 13 | 
 14 | export function createTrees(scene, getHeight) {
 15 |   // We get the position from the created amphitheater instance to avoid circular dependency issues
 16 |   // and ensure we're using the same position data.
 17 |   if (!amphitheatrePosition) {
 18 |     const amp = scene.children.find(c => c.name === 'amphitheatre');
 19 |     if (amp) {
 20 |       amphitheatrePosition = amp.position;
 21 |     }
 22 |   }
 23 | 
 24 |   const treeSeed = 54321;
 25 |   let rng = new MathRandom(treeSeed);
 26 |   const totalZones = ZONES_PER_CHUNK_SIDE * CHUNKS_PER_CLUSTER_SIDE * ZONES_PER_CHUNK_SIDE * CHUNKS_PER_CLUSTER_SIDE;
 27 |   const worldRadius = CLUSTER_SIZE / 2;
 28 | 
 29 |   const trunkMaterials = [
 30 |     new THREE.MeshStandardMaterial({ color: 0x8b4513, roughness: 0.9, metalness: 0.1 }),
 31 |     new THREE.MeshStandardMaterial({ color: 0x6b4423, roughness: 0.9, metalness: 0.1 }),
 32 |     new THREE.MeshStandardMaterial({ color: 0x5d4037, roughness: 0.8, metalness: 0.1 })
 33 |   ];
 34 | 
 35 |   const leavesMaterials = [
 36 |     new THREE.MeshStandardMaterial({ color: 0x2e8b57, roughness: 0.8, metalness: 0.0 }),
 37 |     new THREE.MeshStandardMaterial({ color: 0x228b22, roughness: 0.8, metalness: 0.0 }),
 38 |     new THREE.MeshStandardMaterial({ color: 0x006400, roughness: 0.7, metalness: 0.0 })
 39 |   ];
 40 | 
 41 |   const MIN_TRUNK_HEIGHT = 5;
 42 |   const RAND_TRUNK_HEIGHT = 7;
 43 |   const BASE_TRUNK_RADIUS = 0.3;
 44 |   const RAND_TRUNK_RADIUS = 0.3;
 45 |   const TRUNK_SEGMENTS = 12;
 46 |   const TRUNK_TAPER = 0.8;
 47 |   const MIN_BRANCHES = 3;
 48 |   const RAND_BRANCHES = 4;
 49 |   const LEAF_CLUSTER_RADIUS = 1.8;
 50 |   const LEAF_CLUSTER_SEGMENTS = 5;
 51 |   const MAX_BRANCH_DEPTH = 3;
 52 |   const BRANCH_SHRINK_FACTOR = 0.7;
 53 |   const BRANCH_ANGLE_Y = Math.PI / 3;
 54 |   const BRANCH_ANGLE_XZ = Math.PI * 2;
 55 | 
 56 |   for (let i = 0; i < totalZones * TREES_PER_ZONE; i++) {
 57 |     const tree = new THREE.Group();
 58 |     const trunkMaterial = trunkMaterials[Math.floor(rng.random() * trunkMaterials.length)];
 59 |     const leavesMaterial = leavesMaterials[Math.floor(rng.random() * leavesMaterials.length)];
 60 | 
 61 |     const trunkHeight = MIN_TRUNK_HEIGHT + rng.random() * RAND_TRUNK_HEIGHT;
 62 |     const trunkRadius = BASE_TRUNK_RADIUS + rng.random() * RAND_TRUNK_RADIUS;
 63 | 
 64 |     const trunkGeometry = new THREE.CylinderGeometry(trunkRadius * TRUNK_TAPER, trunkRadius, trunkHeight, TRUNK_SEGMENTS);
 65 |     trunkGeometry.translate(0, trunkHeight / 2, 0);
 66 | 
 67 |     for (let j = 0; j < trunkGeometry.attributes.position.count; j++) {
 68 |       const y = trunkGeometry.attributes.position.getY(j);
 69 |       const bendFactor = y / trunkHeight;
 70 |       const bendAmount = Math.sin(bendFactor * Math.PI) * trunkRadius * 0.5;
 71 |       trunkGeometry.attributes.position.setX(j, trunkGeometry.attributes.position.getX(j) + bendAmount);
 72 |     }
 73 | 
 74 |     const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
 75 |     trunk.castShadow = true;
 76 |     trunk.receiveShadow = true;
 77 |     tree.add(trunk);
 78 | 
 79 |     const numBranches = MIN_BRANCHES + Math.floor(rng.random() * RAND_BRANCHES);
 80 |     for (let j = 0; j < numBranches; j++) {
 81 |       const startHeight = trunkHeight * 0.4 + rng.random() * (trunkHeight * 0.6);
 82 |       createBranch(tree, new THREE.Vector3(0, startHeight, 0), trunkRadius * 0.8, trunkHeight * 0.4, 0, trunkMaterial, leavesMaterial);
 83 |     }
 84 | 
 85 |     function createBranch(parent, position, radius, length, depth, trunkMat, leafMat) {
 86 |       if (depth > MAX_BRANCH_DEPTH) return;
 87 | 
 88 |       const branchGeometry = new THREE.CylinderGeometry(radius * TRUNK_TAPER, radius, length, Math.max(4, TRUNK_SEGMENTS - depth * 2));
 89 |       branchGeometry.translate(0, length / 2, 0);
 90 |       const branch = new THREE.Mesh(branchGeometry, trunkMat);
 91 |       branch.position.copy(position);
 92 | 
 93 |       const randomYAngle = (rng.random() - 0.2) * BRANCH_ANGLE_Y;
 94 |       const randomXZAngle = rng.random() * BRANCH_ANGLE_XZ;
 95 |       branch.rotation.set(Math.cos(randomXZAngle) * randomYAngle, rng.random() * Math.PI, Math.sin(randomXZAngle) * randomYAngle);
 96 | 
 97 |       parent.add(branch);
 98 | 
 99 |       const endPosition = new THREE.Vector3(0, length, 0);
100 |       endPosition.applyQuaternion(branch.quaternion).add(branch.position);
101 | 
102 |       if (depth === MAX_BRANCH_DEPTH || rng.random() < 0.3) {
103 |         const leafClusterGeometry = new THREE.IcosahedronGeometry(LEAF_CLUSTER_RADIUS, LEAF_CLUSTER_SEGMENTS - depth);
104 |         const leafCluster = new THREE.Mesh(leafClusterGeometry, leafMat);
105 |         leafCluster.position.copy(endPosition);
106 |         leafCluster.castShadow = true;
107 |         parent.add(leafCluster);
108 |       } else {
109 |         const subBranches = 1 + Math.floor(rng.random() * 2);
110 |         for (let k = 0; k < subBranches; k++) {
111 |           createBranch(parent, endPosition, radius * BRANCH_SHRINK_FACTOR, length * BRANCH_SHRINK_FACTOR, depth + 1, trunkMat, leafMat);
112 |         }
113 |       }
114 |     }
115 | 
116 |     const angle = rng.random() * Math.PI * 2;
117 |     const distance = SPAWN_SAFE_RADIUS + rng.random() * (worldRadius - SPAWN_SAFE_RADIUS);
118 |     const x = Math.cos(angle) * distance;
119 |     const z = Math.sin(angle) * distance;
120 | 
121 |     if (amphitheatrePosition) {
122 |       const distToAmphitheatre = Math.sqrt(Math.pow(x - amphitheatrePosition.x, 2) + Math.pow(z - amphitheatrePosition.z, 2));
123 |       if (distToAmphitheatre < AMPHITHEATRE_CLEARING_RADIUS) {
124 |           continue;
125 |       }
126 |     }
127 | 
128 |     tree.position.x = x;
129 |     tree.position.z = z;
130 |     tree.position.y = getHeight ? getHeight(tree.position.x, tree.position.z) : 0;
131 | 
132 |     tree.rotation.y = rng.random() * Math.PI * 2;
133 |     const treeScale = 0.8 + rng.random() * 0.5;
134 |     tree.scale.set(treeScale, treeScale, treeScale);
135 | 
136 |     tree.userData.isTree = true;
137 |     tree.userData.isBarrier = true;
138 | 
139 |     scene.add(tree);
140 |   }
141 | }


--------------------------------------------------------------------------------
/loading.css:
--------------------------------------------------------------------------------
 1 | #loading-screen {
 2 |     position: fixed;
 3 |     top: 0;
 4 |     left: 0;
 5 |     width: 100%;
 6 |     height: 100%;
 7 |     background-color: #1a1a1a;
 8 |     color: #ffffff;
 9 |     display: flex;
10 |     justify-content: center;
11 |     align-items: center;
12 |     z-index: 10000;
13 |     font-family: Arial, sans-serif;
14 | }
15 | 
16 | #loading-container {
17 |     text-align: center;
18 | }
19 | 
20 | #loading-container h1 {
21 |     font-size: 2.5em;
22 |     margin-bottom: 20px;
23 | }
24 | 
25 | #loading-status {
26 |     font-size: 1.2em;
27 |     margin-bottom: 20px;
28 |     color: #cccccc;
29 | }
30 | 
31 | #progress-bar-container {
32 |     width: 300px;
33 |     height: 20px;
34 |     background-color: #333333;
35 |     border-radius: 10px;
36 |     overflow: hidden;
37 |     margin: 0 auto 20px;
38 | }
39 | 
40 | #progress-bar {
41 |     width: 0%;
42 |     height: 100%;
43 |     background-color: #4caf50;
44 |     transition: width 0.2s ease-in-out;
45 | }
46 | 
47 | #start-button {
48 |     padding: 12px 25px;
49 |     font-size: 1.2em;
50 |     font-weight: bold;
51 |     color: #ffffff;
52 |     background-color: #2196F3;
53 |     border: none;
54 |     border-radius: 5px;
55 |     cursor: pointer;
56 |     transition: background-color 0.3s;
57 | }
58 | 
59 | #start-button:hover {
60 |     background-color: #1976D2;
61 | }
62 | 
63 | 


--------------------------------------------------------------------------------
/map_icon.png:
--------------------------------------------------------------------------------
https://raw.githubusercontent.com/Tsarcasm831/Testing/9013d8c6561ab48e051ddb026d6286fe57b22282/map_icon.png


--------------------------------------------------------------------------------
/package.json:
--------------------------------------------------------------------------------
 1 | {
 2 |   "name": "mp",
 3 |   "version": "1.0.0",
 4 |   "description": "Minimalist 3D multiplayer prototype",
 5 |   "engines": {
 6 |     "node": ">=18"
 7 |   },
 8 |   "scripts": {
 9 |     "test": "echo \"No tests specified\" && exit 0"
10 |   }
11 | }
12 | 


--------------------------------------------------------------------------------
/python/glbanalyzer.py:
--------------------------------------------------------------------------------
 1 | #!/usr/bin/env python3
 2 | """Simple GLB analyzer for rigging and skeleton information."""
 3 | 
 4 | import struct
 5 | import json
 6 | import sys
 7 | from typing import Tuple, Dict, Any
 8 | 
 9 | 
10 | def load_glb(path: str) -> Tuple[Dict[str, Any], bytes]:
11 |     """Return the glTF JSON and binary chunk from a GLB file."""
12 |     with open(path, 'rb') as f:
13 |         header = f.read(12)
14 |         if len(header) != 12:
15 |             raise ValueError('File too short')
16 |         magic, version, length = struct.unpack('<4sII', header)
17 |         if magic != b'glTF':
18 |             raise ValueError('Not a GLB file')
19 |         data = f.read()
20 | 
21 |     offset = 0
22 |     json_chunk = None
23 |     bin_chunk = b''
24 |     while offset < len(data):
25 |         if offset + 8 > len(data):
26 |             break
27 |         chunk_length, chunk_type = struct.unpack('<II', data[offset:offset+8])
28 |         offset += 8
29 |         chunk_data = data[offset:offset+chunk_length]
30 |         offset += chunk_length
31 |         if chunk_type == 0x4E4F534A:  # JSON
32 |             json_chunk = json.loads(chunk_data.decode('utf-8'))
33 |         elif chunk_type == 0x004E4942:  # BIN
34 |             bin_chunk = chunk_data
35 | 
36 |     if json_chunk is None:
37 |         raise ValueError('No JSON chunk found in GLB')
38 |     return json_chunk, bin_chunk
39 | 
40 | 
41 | def analyze(path: str) -> Dict[str, Any]:
42 |     gltf, _ = load_glb(path)
43 |     details = {
44 |         'num_nodes': len(gltf.get('nodes', [])),
45 |         'num_meshes': len(gltf.get('meshes', [])),
46 |         'num_skins': len(gltf.get('skins', [])),
47 |         'num_animations': len(gltf.get('animations', [])),
48 |         'skins': []
49 |     }
50 |     for skin in gltf.get('skins', []):
51 |         details['skins'].append({
52 |             'joints': len(skin.get('joints', [])),
53 |             'skeleton_root': skin.get('skeleton')
54 |         })
55 |     return details
56 | 
57 | 
58 | def main(argv=None):
59 |     argv = argv or sys.argv[1:]
60 |     if not argv:
61 |         print('Usage: glbanalyzer.py model.glb')
62 |         return 1
63 |     details = analyze(argv[0])
64 |     print(json.dumps(details, indent=2))
65 |     return 0
66 | 
67 | 
68 | if __name__ == '__main__':
69 |     raise SystemExit(main())
70 | 


--------------------------------------------------------------------------------
/python/skeleton_rigger.py:
--------------------------------------------------------------------------------
 1 | #!/usr/bin/env python3
 2 | """Command line tool that prints skeleton hierarchy using glbanalyzer."""
 3 | 
 4 | import sys
 5 | import json
 6 | from glbanalyzer import load_glb
 7 | 
 8 | 
 9 | def print_skeleton(gltf):
10 |     nodes = gltf.get('nodes', [])
11 |     skins = gltf.get('skins', [])
12 |     for idx, skin in enumerate(skins):
13 |         print(f'Skeleton {idx}:')
14 |         joints = skin.get('joints', [])
15 |         for j in joints:
16 |             node = nodes[j]
17 |             name = node.get('name', f'node{j}')
18 |             print(f'  - {name}')
19 | 
20 | 
21 | def main(argv=None):
22 |     argv = argv or sys.argv[1:]
23 |     if not argv:
24 |         print('Usage: skeleton_rigger.py model.glb')
25 |         return 1
26 |     gltf, _ = load_glb(argv[0])
27 |     print_skeleton(gltf)
28 |     return 0
29 | 
30 | 
31 | if __name__ == '__main__':
32 |     raise SystemExit(main())
33 | 


--------------------------------------------------------------------------------
/styles/ads.css:
--------------------------------------------------------------------------------
 1 | #ad-modal {
 2 |   position: fixed;
 3 |   top: 0;
 4 |   left: 0;
 5 |   width: 100%;
 6 |   height: 100%;
 7 |   background-color: var(--black-80);
 8 |   z-index: 3000;
 9 |   display: none;
10 |   justify-content: center;
11 |   align-items: center;
12 |   flex-direction: column;
13 | }
14 | 
15 | #ad-close-button {
16 |   padding: 10px 20px;
17 |   font-size: 16px;
18 |   background-color: #f44336;
19 |   color: white;
20 |   border: none;
21 |   border-radius: 5px;
22 |   cursor: not-allowed;
23 |   margin-top: 20px;
24 | }
25 | 
26 | #ad-close-button:not([disabled]) {
27 |   cursor: pointer;
28 | }
29 | 
30 | 


--------------------------------------------------------------------------------
/styles/base.css:
--------------------------------------------------------------------------------
  1 | body {
  2 |   margin: 0;
  3 |   padding: 0;
  4 |   width: 100vw;
  5 |   height: 100vh;
  6 |   overflow: hidden;
  7 |   font-family: Arial, sans-serif;
  8 |   user-select: none;
  9 |   -webkit-user-select: none; /* Safari */
 10 |   -moz-user-select: none; /* Firefox */
 11 |   -ms-user-select: none; /* IE/Edge */
 12 |   touch-action: manipulation;
 13 |   -webkit-touch-callout: none; /* iOS Safari */
 14 | }
 15 | 
 16 | #game-container, #label-container, #css3d-container {
 17 |   position: absolute;
 18 |   top: 0;
 19 |   left: 0;
 20 |   width: 100%;
 21 |   height: 100%;
 22 | }
 23 | 
 24 | #game-container {
 25 |   z-index: 1;
 26 | }
 27 | 
 28 | #label-container {
 29 |   pointer-events: none;
 30 |   z-index: 2;
 31 | }
 32 | 
 33 | #css3d-container {
 34 |   pointer-events: none;
 35 |   z-index: 3;
 36 | }
 37 | 
 38 | #css3d-container iframe {
 39 |     pointer-events: auto;
 40 | }
 41 | 
 42 | #ui-container {
 43 |     position: absolute;
 44 |     top: 0;
 45 |     left: 0;
 46 |     width: 100%;
 47 |     height: 100%;
 48 |     pointer-events: none;
 49 |     /* @tweakable The z-index for the main UI container, ensuring it's on top of other game layers. */
 50 |     z-index: 100;
 51 | }
 52 | 
 53 | .instructions {
 54 |   position: fixed;
 55 |   top: 50%;
 56 |   left: 50%;
 57 |   transform: translate(-50%, -50%);
 58 |   background-color: var(--black-70);
 59 |   padding: 20px;
 60 |   border-radius: 8px;
 61 |   font-size: 18px;
 62 |   color: #fff;
 63 |   z-index: 100;
 64 |   max-width: 400px;
 65 |   text-align: center;
 66 | }
 67 | 
 68 | #dev-toggle-button {
 69 |   position: fixed;
 70 |   /* @tweakable Position of the dev-mode toggle button. */
 71 |   top: 80px;
 72 |   left: 20px;
 73 |   background-color: var(--black-70);
 74 |   color: white;
 75 |   padding: 10px 15px;
 76 |   border-radius: 8px;
 77 |   cursor: pointer;
 78 |   z-index: 1000;
 79 |   font-weight: bold;
 80 |   border: 2px solid var(--white-30);
 81 | }
 82 | 
 83 | .crosshair {
 84 |   position: fixed;
 85 |   top: 50%;
 86 |   left: 50%;
 87 |   width: 20px;
 88 |   height: 20px;
 89 |   transform: translate(-50%, -50%);
 90 |   pointer-events: none;
 91 |   z-index: 1000;
 92 |   display: none; /* Hide crosshair for third-person view */
 93 | }
 94 | 
 95 | .crosshair::before,
 96 | .crosshair::after {
 97 |   content: "";
 98 |   position: absolute;
 99 |   background-color: white;
100 | }
101 | 
102 | .crosshair::before {
103 |   top: 9px;
104 |   left: 0;
105 |   width: 20px;
106 |   height: 2px;
107 | }
108 | 
109 | .crosshair::after {
110 |   top: 0;
111 |   left: 9px;
112 |   width: 2px;
113 |   height: 20px;
114 | }
115 | 
116 | #mobile-toggle-button {
117 |   display: none;
118 | }
119 | 
120 | button {
121 |   padding: 6px 12px;
122 |   border: none;
123 |   border-radius: 4px;
124 |   background-color: #e0e0e0;
125 |   color: #333;
126 |   font-size: 14px;
127 |   cursor: pointer;
128 |   transition: background-color 0.2s;
129 | }
130 | 
131 | button:hover {
132 |   background-color: #f5f5f5;
133 | }
134 | 
135 | button:active {
136 |   background-color: #d5d5d5;
137 | }
138 | 
139 | /* @tweakable size of the main floating action buttons */
140 | .circle-button {
141 |   width: 50px;
142 |   height: 50px;
143 |   border-radius: 50%;
144 |   display: flex;
145 |   justify-content: center;
146 |   align-items: center;
147 |   font-weight: bold;
148 |   white-space: nowrap;
149 |   overflow: hidden;
150 |   box-sizing: border-box;
151 |   font-size: 11px;
152 |   padding: 12px;
153 |   background-color: var(--black-70) !important;
154 |   color: white !important;
155 |   border: 1px solid var(--white-30);
156 |   transition: background-color 0.2s, transform 0.2s;
157 |   pointer-events: auto; /* Allow clicks on buttons inside a pointer-events:none container */
158 | }
159 | 
160 | .circle-button:hover {
161 |     background-color: var(--black-85) !important;
162 |     transform: scale(1.05);
163 | }
164 | 
165 | .circle-button svg {
166 |     width: 100%;
167 |     height: 100%;
168 | }
169 | 
170 | .joystick-container {
171 |     display: none;
172 | }
173 | 
174 | /* @tweakable The text color for grid labels. */
175 | :root {
176 |   --grid-label-color: rgba(255, 255, 255, 0.7);
177 |   /* @tweakable The font size for grid labels. */
178 |   --grid-label-font-size: 12px;
179 | }
180 | 
181 | #label-container {
182 |   position: absolute;
183 |   top: 0;
184 |   left: 0;
185 |   width: 100%;
186 |   height: 100%;
187 |   pointer-events: none;
188 |   z-index: 10;
189 | }
190 | 
191 | .grid-label {
192 |   color: var(--grid-label-color);
193 |   font-family: Arial, sans-serif;
194 |   font-size: var(--grid-label-font-size);
195 |   font-weight: bold;
196 |   text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
197 |   pointer-events: none;
198 | }


--------------------------------------------------------------------------------
/styles/build.css:
--------------------------------------------------------------------------------
  1 | #build-button {
  2 |   position: fixed;
  3 |   /* @tweakable Position of the build button on desktop. */
  4 |   top: 20px;
  5 |   right: 20px;
  6 |   z-index: 1000;
  7 | }
  8 | 
  9 | #build-button.active {
 10 |   background-color: rgba(33, 150, 243, 0.7) !important;
 11 |   border-color: var(--white-80) !important;
 12 | }
 13 | 
 14 | #build-controls {
 15 |   position: fixed;
 16 |   bottom: 20px;
 17 |   left: 50%;
 18 |   transform: translateX(-50%);
 19 |   background-color: var(--black-70);
 20 |   border-radius: 8px;
 21 |   padding: 10px;
 22 |   display: flex;
 23 |   gap: 10px;
 24 |   z-index: 2000;
 25 | }
 26 | 
 27 | #build-controls button {
 28 |   padding: 8px 12px;
 29 |   border-radius: 4px;
 30 |   border: none;
 31 |   background-color: var(--white-20);
 32 |   color: white;
 33 |   cursor: pointer;
 34 |   font-weight: bold;
 35 |   transition: background-color 0.2s;
 36 | }
 37 | 
 38 | #build-controls button:hover {
 39 |   background-color: var(--white-30);
 40 | }
 41 | 
 42 | #shape-button, #material-button, #size-button {
 43 |   min-width: 40px;
 44 | }
 45 | 
 46 | #exit-build-button {
 47 |   background-color: rgba(244, 67, 54, 0.7);
 48 | }
 49 | 
 50 | #exit-build-button:hover {
 51 |   background-color: rgba(244, 67, 54, 0.9);
 52 | }
 53 | 
 54 | #height-indicator {
 55 |   position: fixed;
 56 |   bottom: 20px;
 57 |   right: 20px;
 58 |   background-color: var(--black-70);
 59 |   color: white;
 60 |   padding: 5px 10px;
 61 |   border-radius: 5px;
 62 |   z-index: 1000;
 63 |   font-size: 14px;
 64 |   display: none;
 65 | }
 66 | 
 67 | #height-slider-container {
 68 |   display: none;
 69 | }
 70 | 
 71 | #height-slider {
 72 |   width: 200px;
 73 |   height: 20px;
 74 |   -webkit-appearance: none;
 75 |   appearance: none;
 76 |   background: var(--white-20);
 77 |   border-radius: 10px;
 78 |   outline: none;
 79 | }
 80 | 
 81 | #height-slider::-webkit-slider-thumb {
 82 |   -webkit-appearance: none;
 83 |   appearance: none;
 84 |   width: 20px;
 85 |   height: 20px;
 86 |   border-radius: 50%;
 87 |   background: #2196F3;
 88 |   cursor: pointer;
 89 | }
 90 | 
 91 | #height-slider::-moz-range-thumb {
 92 |   width: 20px;
 93 |   height: 20px;
 94 |   border-radius: 50%;
 95 |   background: #2196F3;
 96 |   cursor: pointer;
 97 | }
 98 | 
 99 | #height-value {
100 |   font-weight: bold;
101 |   min-width: 30px;
102 |   text-align: center;
103 | }
104 | 
105 | #ai-building-indicator {
106 |   position: fixed;
107 |   top: 0;
108 |   left: 0;
109 |   width: 100%;
110 |   height: 100%;
111 |   display: flex;
112 |   justify-content: center;
113 |   align-items: center;
114 |   z-index: 2000;
115 |   pointer-events: none;
116 | }
117 | 
118 | .ai-building-message {
119 |   background-color: var(--black-80);
120 |   color: white;
121 |   padding: 15px 30px;
122 |   border-radius: 10px;
123 |   font-size: 18px;
124 |   display: flex;
125 |   align-items: center;
126 |   gap: 15px;
127 |   box-shadow: 0 5px 15px var(--black-30);
128 | }
129 | 
130 | .ai-building-text {
131 |   display: flex;
132 |   flex-direction: column;
133 | }
134 | 
135 | .ai-progress {
136 |   width: 100%;
137 |   height: 6px;
138 |   background-color: var(--white-30);
139 |   border-radius: 3px;
140 |   overflow: hidden;
141 |   margin-top: 8px;
142 | }
143 | 
144 | .ai-progress-bar {
145 |   height: 100%;
146 |   width: 0;
147 |   background-color: #4caf50;
148 |   transition: width 0.1s linear;
149 | }
150 | 
151 | .ai-loading-spinner {
152 |   width: 20px;
153 |   height: 20px;
154 |   border-radius: 50%;
155 |   border: 3px solid var(--white-30);
156 |   border-top-color: white;
157 |   animation: ai-spin 1s linear infinite;
158 | }
159 | 
160 | @keyframes ai-spin {
161 |   to { transform: rotate(360deg); }
162 | }
163 | 
164 | #ai-build-button {
165 |   background-color: rgba(0, 140, 255, 0.7);
166 |   border-color: var(--white-50);
167 | }
168 | 
169 | #ai-build-modal {
170 |   position: fixed;
171 |   top: 50%;
172 |   left: 50%;
173 |   transform: translate(-50%, -50%);
174 |   background-color: var(--black-90);
175 |   color: white;
176 |   padding: 20px;
177 |   border-radius: 10px;
178 |   /* @tweakable The z-index for the AI build modal. */
179 |   z-index: 2001;
180 |   width: 90%;
181 |   max-width: 400px;
182 |   display: none;
183 |   pointer-events: auto;
184 | }
185 | 
186 | #ai-build-modal h3 {
187 |   margin-top: 0;
188 |   text-align: center;
189 | }
190 | 
191 | #ai-build-prompt {
192 |   width: 100%;
193 |   height: 100px;
194 |   margin: 10px 0;
195 |   padding: 10px;
196 |   border-radius: 5px;
197 |   resize: none;
198 |   font-family: inherit;
199 | }
200 | 
201 | #ai-build-modal .buttons {
202 |   display: flex;
203 |   justify-content: space-between;
204 |   gap: 10px;
205 | }
206 | 
207 | #ai-build-modal button {
208 |   padding: 8px 15px;
209 |   border-radius: 5px;
210 |   border: none;
211 |   cursor: pointer;
212 |   font-weight: bold;
213 |   flex: 1;
214 | }
215 | 
216 | #ai-build-modal button.generate {
217 |   background-color: #4CAF50;
218 |   color: white;
219 | }
220 | 
221 | #ai-build-modal button.cancel {
222 |   background-color: #f44336;
223 |   color: white;
224 | }
225 | 
226 | #ai-build-examples {
227 |   margin-top: 15px;
228 |   font-size: 14px;
229 | }
230 | 
231 | .ai-example {
232 |   background-color: var(--white-10);
233 |   padding: 8px;
234 |   margin: 5px 0;
235 |   border-radius: 4px;
236 |   cursor: pointer;
237 | }
238 | 
239 | .ai-example:hover {
240 |   background-color: var(--white-20);
241 | }
242 | 
243 | #useless-button {
244 |   position: fixed;
245 |   top: 60px;
246 |   right: 20px;
247 |   background-color: rgba(255, 0, 0, 0.7);
248 |   color: white;
249 |   padding: 10px 15px;
250 |   border-radius: 8px;
251 |   cursor: pointer;
252 |   z-index: 1000;
253 |   font-weight: bold;
254 |   border: 2px solid var(--white-30);
255 |   user-select: none;
256 |   animation: pulse 2s infinite;
257 | }
258 | 
259 | @keyframes pulse {
260 |   0% { transform: scale(1); }
261 |   50% { transform: scale(1.05); }
262 |   100% { transform: scale(1); }
263 | }
264 | 
265 | #advanced-build-controls {
266 |   position: fixed;
267 |   bottom: 20px;
268 |   left: 50%;
269 |   transform: translateX(-50%);
270 |   background-color: var(--black-70);
271 |   border-radius: 8px;
272 |   padding: 10px;
273 |   display: none;
274 |   gap: 10px;
275 |   z-index: 2000;
276 | }
277 | 
278 | #advanced-build-controls button {
279 |   padding: 8px 12px;
280 |   border-radius: 4px;
281 |   border: none;
282 |   background-color: var(--white-20);
283 |   color: white;
284 |   cursor: pointer;
285 |   font-weight: bold;
286 |   transition: background-color 0.2s;
287 | }
288 | 
289 | #advanced-build-controls button:hover {
290 |   background-color: var(--white-30);
291 | }
292 | 
293 | .transform-button.active {
294 |   background-color: rgba(33, 150, 243, 0.6) !important;
295 | }
296 | 
297 | #delete-button {
298 |   background-color: rgba(244, 67, 54, 0.7) !important;
299 | }
300 | 
301 | #delete-button:hover {
302 |   background-color: rgba(244, 67, 54, 0.9) !important;
303 | }
304 | 
305 | #object-library {
306 |   position: fixed;
307 |   top: 80px;
308 |   left: 20px;
309 |   background-color: var(--black-70);
310 |   border-radius: 8px;
311 |   padding: 10px;
312 |   display: none;
313 |   flex-direction: column;
314 |   width: 180px;
315 |   z-index: 2000;
316 | }
317 | 
318 | #object-library h3 {
319 |   margin: 0 0 10px 0;
320 |   text-align: center;
321 |   color: white;
322 |   font-size: 16px;
323 | }
324 | 
325 | .object-grid {
326 |   display: grid;
327 |   grid-template-columns: repeat(2, 1fr);
328 |   gap: 8px;
329 | }
330 | 
331 | .object-item {
332 |   background-color: var(--white-20);
333 |   padding: 8px;
334 |   border-radius: 4px;
335 |   color: white;
336 |   text-align: center;
337 |   cursor: pointer;
338 |   transition: background-color 0.2s;
339 | }
340 | 
341 | .object-item:hover {
342 |   background-color: var(--white-30);
343 | }
344 | 
345 | #selection-controls {
346 |   position: fixed;
347 |   top: 20px;
348 |   left: 50%;
349 |   transform: translateX(-50%);
350 |   background-color: rgba(33, 150, 243, 0.7);
351 |   border-radius: 8px;
352 |   padding: 10px;
353 |   display: none;
354 |   align-items: center;
355 |   justify-content: center;
356 |   z-index: 2000;
357 | }
358 | 
359 | .selection-info {
360 |   color: white;
361 |   font-weight: bold;
362 | }
363 | 
364 | #advanced-mode-button {
365 |   background-color: rgba(103, 58, 183, 0.7);
366 |   border-color: var(--white-50);
367 | }
368 | 
369 | #advanced-mode-button.active {
370 |   background-color: rgba(103, 58, 183, 0.9);
371 |   border-color: var(--white-80);
372 | }
373 | 
374 | #color-picker {
375 |   position: fixed;
376 |   top: 50%;
377 |   left: 50%;
378 |   transform: translate(-50%, -50%);
379 |   background-color: var(--black-80);
380 |   color: white;
381 |   padding: 15px;
382 |   border-radius: 8px;
383 |   z-index: 2001;
384 |   width: 250px;
385 | }
386 | 
387 | #color-picker h3 {
388 |   margin-top: 0;
389 |   text-align: center;
390 |   font-size: 16px;
391 | }
392 | 
393 | .color-controls {
394 |   display: flex;
395 |   margin: 15px 0;
396 |   align-items: center;
397 | }
398 | 
399 | #color-preview {
400 |   width: 60px;
401 |   height: 60px;
402 |   border-radius: 4px;
403 |   background-color: rgb(255, 0, 0);
404 |   margin-right: 15px;
405 |   border: 2px solid var(--white-30);
406 | }
407 | 
408 | .color-inputs {
409 |   flex: 1;
410 | }
411 | 
412 | .color-input {
413 |   display: flex;
414 |   align-items: center;
415 |   margin-bottom: 5px;
416 | }
417 | 
418 | .color-input label {
419 |   width: 20px;
420 |   font-weight: bold;
421 | }
422 | 
423 | .color-input input {
424 |   flex: 1;
425 |   padding: 4px;
426 |   border-radius: 4px;
427 |   border: none;
428 | }
429 | 
430 | #apply-color-button, #close-color-picker {
431 |   padding: 8px;
432 |   border-radius: 4px;
433 |   border: none;
434 |   margin-top: 5px;
435 |   cursor: pointer;
436 |   width: 100%;
437 | }
438 | 
439 | #apply-color-button {
440 |   background-color: #4CAF50;
441 |   color: white;
442 |   margin-bottom: 8px;
443 | }
444 | 
445 | #close-color-picker {
446 |   background-color: #f44336;
447 |   color: white;
448 | }
449 | 
450 | #color-pick-button.active {
451 |   background-color: rgba(255, 166, 0, 0.7) !important;
452 | }
453 | 
454 | #lifespan-extender-button {
455 |   background-color: rgba(0, 128, 0, 0.7);
456 |   border-color: var(--white-50);
457 | }
458 | 
459 | #lifespan-extender-button.active {
460 |   background-color: rgba(0, 200, 0, 0.9);
461 |   border-color: var(--white-80);
462 | }
463 | 
464 | #lifespan-notification {
465 |   position: fixed;
466 |   top: 50%;
467 |   left: 50%;
468 |   transform: translate(-50%, -50%);
469 |   background-color: var(--black-80);
470 |   color: white;
471 |   padding: 15px 30px;
472 |   border-radius: 10px;
473 |   font-size: 18px;
474 |   z-index: 2000;
475 |   box-shadow: 0 5px 15px var(--black-30);
476 |   display: none;
477 | }


--------------------------------------------------------------------------------
/styles/changelog.css:
--------------------------------------------------------------------------------
 1 | #changelog-modal {
 2 |   position: fixed;
 3 |   top: 50%;
 4 |   left: 50%;
 5 |   transform: translate(-50%, -50%);
 6 |   background-color: var(--black-90);
 7 |   color: white;
 8 |   padding: 20px;
 9 |   border-radius: 10px;
10 |   /* @tweakable The z-index for the changelog modal. */
11 |   z-index: 2100;
12 |   width: 90%;
13 |   max-width: 600px;
14 |   max-height: 80%;
15 |   overflow-y: auto;
16 |   display: none;
17 |   box-shadow: 0 0 20px var(--black-50);
18 |   pointer-events: auto;
19 | }
20 | 
21 | #close-changelog {
22 |   position: absolute;
23 |   top: 10px;
24 |   right: 10px;
25 |   width: 20px;
26 |   height: 20px;
27 |   background-color: var(--white-70);
28 |   border-radius: 50%;
29 |   text-align: center;
30 |   line-height: 20px;
31 |   font-weight: bold;
32 |   color: #333;
33 |   cursor: pointer;
34 | }
35 | 
36 | #changelog-content {
37 |   white-space: pre-wrap;
38 | }


--------------------------------------------------------------------------------
/styles/character-creator.css:
--------------------------------------------------------------------------------
  1 | #character-creator-button {
  2 |   position: fixed;
  3 |   /* @tweakable Position of the character creator button on desktop. */
  4 |   top: 20px;
  5 |   left: 20px;
  6 |   background-color: var(--black-70);
  7 |   color: white;
  8 |   padding: 10px 15px;
  9 |   border-radius: 8px;
 10 |   cursor: pointer;
 11 |   z-index: 1000;
 12 |   font-weight: bold;
 13 |   border: 2px solid var(--white-30);
 14 | }
 15 | 
 16 | #character-creator-modal {
 17 |   position: fixed;
 18 |   top: 50%;
 19 |   left: 50%;
 20 |   transform: translate(-50%, -50%);
 21 |   background-color: var(--black-90);
 22 |   color: white;
 23 |   padding: 20px;
 24 |   border-radius: 10px;
 25 |   /* @tweakable The z-index for the character creator modal. */
 26 |   z-index: 2000;
 27 |   display: none;
 28 |   width: 90%;
 29 |   max-width: 700px;
 30 |   box-shadow: 0 0 20px var(--black-50);
 31 |   pointer-events: auto;
 32 | }
 33 | 
 34 | #character-creator-modal h2 {
 35 |   margin-top: 0;
 36 |   text-align: center;
 37 |   color: #fff;
 38 |   margin-bottom: 20px;
 39 | }
 40 | 
 41 | #character-creator-modal .creator-body {
 42 |   display: flex;
 43 |   flex-wrap: wrap;
 44 |   gap: 20px;
 45 | }
 46 | 
 47 | #character-creator-modal .creator-inputs,
 48 | #character-creator-modal .creator-preview {
 49 |   flex: 1 1 240px;
 50 | }
 51 | 
 52 | #character-creator-modal .creator-preview {
 53 |   display: flex;
 54 |   flex-direction: column;
 55 |   align-items: center;
 56 | }
 57 | 
 58 | #character-creator-modal textarea {
 59 |   width: 100%;
 60 |   height: 100px;
 61 |   margin-bottom: 20px;
 62 |   padding: 10px;
 63 |   border-radius: 5px;
 64 |   background-color: var(--white-90);
 65 |   color: #333;
 66 |   font-size: 16px;
 67 |   resize: none;
 68 | }
 69 | 
 70 | #character-creator-modal .creator-actions {
 71 |   display: flex;
 72 |   justify-content: space-between;
 73 |   gap: 10px;
 74 |   margin-top: 10px;
 75 | }
 76 | 
 77 | #character-creator-modal button {
 78 |   padding: 10px 15px;
 79 |   border-radius: 5px;
 80 |   border: none;
 81 |   cursor: pointer;
 82 |   font-weight: bold;
 83 |   flex: 1;
 84 | }
 85 | 
 86 | #generate-character-button {
 87 |   background-color: #4CAF50;
 88 |   color: white;
 89 |   width: 100%;
 90 | }
 91 | 
 92 | #apply-character-button {
 93 |   background-color: #2196F3;
 94 |   color: white;
 95 |   display: none;
 96 | }
 97 | 
 98 | #cancel-character-button {
 99 |   background-color: #f44336;
100 |   color: white;
101 | }
102 | 
103 | #character-preview {
104 |   margin: 15px 0;
105 |   text-align: center;
106 |   min-height: 150px; 
107 |   padding: 10px;
108 |   border-radius: 5px;
109 |   background-color: var(--white-10);
110 |   position: relative; 
111 | }
112 | 
113 | #character-status {
114 |   text-align: center;
115 |   font-style: italic;
116 |   margin: 10px 0;
117 |   min-height: 20px;
118 | }
119 | 
120 | .character-gallery {
121 |   display: grid;
122 |   grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
123 |   gap: 10px;
124 |   margin-top: 15px;
125 |   max-height: 200px;
126 |   overflow-y: auto;
127 |   padding: 5px;
128 |   background-color: var(--white-05);
129 |   border-radius: 5px;
130 | }
131 | 
132 | .character-option {
133 |   background-color: var(--white-20);
134 |   padding: 8px;
135 |   border-radius: 5px;
136 |   cursor: pointer;
137 |   text-align: center;
138 |   font-size: 14px;
139 |   transition: background-color 0.2s;
140 | }
141 | 
142 | .character-option:hover {
143 |   background-color: var(--white-30);
144 | }
145 | 
146 | .character-option.selected {
147 |   background-color: rgba(33, 150, 243, 0.4);
148 |   border: 2px solid #2196F3;
149 | }
150 | 
151 | #preset-gallery {
152 |   max-height: 140px;
153 |   margin-bottom: 20px;
154 |   background-color: rgba(70, 130, 180, 0.1);
155 | }
156 | 
157 | #reference-image-container {
158 |   margin-bottom: 15px;
159 |   background-color: var(--white-05);
160 |   padding: 10px;
161 |   border-radius: 5px;
162 | }
163 | 
164 | .reference-upload-label {
165 |   display: block;
166 |   margin-bottom: 8px;
167 |   font-weight: bold;
168 | }
169 | 
170 | #reference-image {
171 |   width: 100%;
172 |   background-color: var(--white-10);
173 |   color: white;
174 |   padding: 5px;
175 |   border-radius: 5px;
176 |   border: 1px solid var(--white-20);
177 | }
178 | 
179 | #reference-preview {
180 |   margin-top: 10px;
181 |   max-height: 150px;
182 |   overflow: hidden;
183 |   display: flex;
184 |   flex-direction: column;
185 |   align-items: center;
186 | }
187 | 
188 | #reference-image-preview {
189 |   max-width: 100%;
190 |   max-height: 120px;
191 |   border-radius: 5px;
192 |   object-fit: contain;
193 | }
194 | 
195 | #remove-reference-image {
196 |   margin-top: 5px;
197 |   background-color: #f44336;
198 |   color: white;
199 |   border: none;
200 |   border-radius: 4px;
201 |   padding: 4px 8px;
202 |   font-size: 12px;
203 |   cursor: pointer;
204 | }
205 | 
206 | .character-thumbnail {
207 |   height: 60px;
208 |   overflow: hidden;
209 |   border-radius: 4px;
210 |   margin-bottom: 5px;
211 | }
212 | 
213 | .character-thumbnail img {
214 |   width: 100%;
215 |   height: 100%;
216 |   object-fit: cover;
217 | }
218 | 
219 | .character-name {
220 |   font-size: 12px;
221 |   overflow: hidden;
222 |   text-overflow: ellipsis;
223 |   white-space: nowrap;
224 | }


--------------------------------------------------------------------------------
/styles/chat.css:
--------------------------------------------------------------------------------
  1 | #chat-input-container {
  2 |   position: fixed;
  3 |   bottom: 10px;
  4 |   left: 50%;
  5 |   transform: translateX(-50%);
  6 |   width: 80%;
  7 |   max-width: 500px;
  8 |   background-color: var(--black-70);
  9 |   border-radius: 8px;
 10 |   padding: 10px;
 11 |   display: none;
 12 |   z-index: 2000;
 13 |   display: flex;
 14 |   padding-top: 5px;
 15 |   border-top: 1px solid var(--white-20);
 16 | }
 17 | 
 18 | #chat-input {
 19 |   width: 100%;
 20 |   padding: 8px;
 21 |   border-radius: 4px;
 22 |   border: none;
 23 |   background-color: var(--white-20);
 24 |   color: #fff;
 25 |   font-size: 14px;
 26 |   flex-grow: 1;
 27 | }
 28 | 
 29 | #chat-input:focus {
 30 |   outline: 1px solid var(--white-50);
 31 | }
 32 | 
 33 | /* @tweakable Position of the chat button on the screen. */
 34 | #chat-button {
 35 |   position: fixed;
 36 |   bottom: 80px;
 37 |   right: 20px;
 38 |   z-index: 1000;
 39 |   touch-action: none;
 40 |   cursor: pointer;
 41 | }
 42 | 
 43 | /* @tweakable Position of the changelog button on the screen. */
 44 | #changelog-button {
 45 |   position: fixed;
 46 |   bottom: 150px;
 47 |   right: 20px;
 48 |   z-index: 1000;
 49 |   touch-action: none;
 50 |   cursor: pointer;
 51 | }
 52 | 
 53 | #close-chat {
 54 |   position: absolute;
 55 |   top: 10px;
 56 |   right: 10px;
 57 |   width: 20px;
 58 |   height: 20px;
 59 |   background-color: var(--white-70);
 60 |   border-radius: 50%;
 61 |   text-align: center;
 62 |   line-height: 20px;
 63 |   font-weight: bold;
 64 |   color: #333;
 65 |   cursor: pointer;
 66 | }
 67 | 
 68 | #chat-log {
 69 |   max-height: 150px;
 70 |   overflow-y: auto;
 71 |   margin-bottom: 8px;
 72 |   color: #fff;
 73 |   font-size: 14px;
 74 |   flex-grow: 1;
 75 |   overflow-y: auto;
 76 |   padding: 10px;
 77 |   color: #fff;
 78 |   font-size: 14px;
 79 |   display: flex;
 80 |   flex-direction: column;
 81 | }
 82 | 
 83 | #chat-log::-webkit-scrollbar {
 84 |   width: 6px;
 85 | }
 86 | #chat-log::-webkit-scrollbar-thumb {
 87 |   background-color: var(--white-30);
 88 |   border-radius: 3px;
 89 | }
 90 | #chat-log::-webkit-scrollbar-track {
 91 |   background-color: transparent;
 92 | }
 93 | 
 94 | #chat-ui-container {
 95 |     /* @tweakable Position of the chat window on the screen. */
 96 |     position: fixed;
 97 |     bottom: 20px;
 98 |     left: 20px;
 99 |     /* @tweakable Size of the chat window. */
100 |     width: 350px;
101 |     height: 200px;
102 |     /* @tweakable Background color of the chat window. */
103 |     background-color: var(--black-70);
104 |     border-radius: 8px;
105 |     display: flex;
106 |     flex-direction: column;
107 |     z-index: 1500;
108 |     padding: 5px;
109 |     box-shadow: 0 2px 10px var(--black-50);
110 |     opacity: 0;
111 |     visibility: hidden;
112 |     transition: opacity 0.3s, visibility 0.3s;
113 |     pointer-events: none;
114 | }
115 | 
116 | #chat-ui-container.visible {
117 |     opacity: 1;
118 |     visibility: visible;
119 |     pointer-events: auto;
120 | }
121 | 
122 | .chat-log-entry {
123 |     padding: 2px 4px;
124 |     border-radius: 3px;
125 |     margin-bottom: 4px;
126 |     line-height: 1.4;
127 |     max-width: 95%;
128 |     word-wrap: break-word;
129 | }
130 | 
131 | .chat-log-entry .username {
132 |     font-weight: bold;
133 | }
134 | 
135 | .chat-log-entry.local-user {
136 |     /* @tweakable Background color for the local user's chat messages. */
137 |     background-color: rgba(68, 170, 255, 0.2);
138 | }
139 | 
140 | .chat-log-entry.other-user {
141 |     /* @tweakable Background color for other users' chat messages. */
142 |     background-color: rgba(255, 255, 255, 0.1);
143 | }


--------------------------------------------------------------------------------
/styles/compass.css:
--------------------------------------------------------------------------------
  1 | #compass-container {
  2 |     position: fixed;
  3 |     /* @tweakable Top offset of the compass from the top of the screen. */
  4 |     top: 20px;
  5 |     left: 50%;
  6 |     transform: translateX(-50%);
  7 |     width: 80px;
  8 |     height: 80px;
  9 |     background-color: rgba(0,0,0,0.5);
 10 |     border-radius: 50%;
 11 |     border: 2px solid rgba(255,255,255,0.2);
 12 |     z-index: 1000;
 13 |     color: white;
 14 |     pointer-events: none;
 15 |     user-select: none;
 16 | }
 17 | 
 18 | #compass-dial {
 19 |     width: 100%;
 20 |     height: 100%;
 21 |     position: relative;
 22 |     transition: transform 0.1s linear;
 23 | }
 24 | 
 25 | #compass-dial .direction {
 26 |     position: absolute;
 27 |     width: 20px;
 28 |     height: 20px;
 29 |     text-align: center;
 30 |     line-height: 20px;
 31 |     font-weight: bold;
 32 |     font-size: 16px;
 33 |     left: 50%;
 34 |     top: 50%;
 35 |     transform-origin: 0 0;
 36 | }
 37 | 
 38 | #compass-dial .north {
 39 |     color: #ff4444; /* @tweakable Color of the 'North' indicator. */
 40 |     transform: translate(-50%, -50%) translateY(-30px);
 41 | }
 42 | #compass-dial .east {
 43 |     transform: translate(-50%, -50%) translateX(30px) rotate(90deg);
 44 | }
 45 | #compass-dial .south {
 46 |     transform: translate(-50%, -50%) translateY(30px) rotate(180deg);
 47 | }
 48 | #compass-dial .west {
 49 |     transform: translate(-50%, -50%) translateX(-30px) rotate(270deg);
 50 | }
 51 | 
 52 | #compass-dial .tick {
 53 |     position: absolute;
 54 |     background-color: white;
 55 |     width: 1px;
 56 |     height: 8px;
 57 |     left: 50%;
 58 |     top: 0;
 59 |     transform-origin: 0 40px;
 60 | }
 61 | #compass-dial .tick.major {
 62 |     height: 12px;
 63 | }
 64 | 
 65 | 
 66 | #compass-needle {
 67 |     position: absolute;
 68 |     top: 0;
 69 |     left: 50%;
 70 |     transform: translateX(-50%);
 71 |     width: 0;
 72 |     height: 0;
 73 |     border-left: 6px solid transparent;
 74 |     border-right: 6px solid transparent;
 75 |     /* @tweakable Color of the compass needle. */
 76 |     border-bottom: 10px solid white;
 77 | }
 78 | 
 79 | #compass-coords {
 80 |     position: fixed;
 81 |     /* @tweakable Top offset of the coordinates display. */
 82 |     top: 100px;
 83 |     left: 50%;
 84 |     transform: translateX(-50%);
 85 |     background-color: var(--black-50);
 86 |     color: white;
 87 |     padding: 3px 8px;
 88 |     border-radius: 5px;
 89 |     font-size: 12px;
 90 |     z-index: 1000;
 91 |     pointer-events: none;
 92 | }
 93 | 
 94 | /* @tweakable Width of the heading bar. */
 95 | #heading-bar-container {
 96 |     position: fixed;
 97 |     top: 20px;
 98 |     left: 50%;
 99 |     transform: translateX(-50%);
100 |     width: 300px;
101 |     height: 30px;
102 |     background-color: var(--black-50);
103 |     border-radius: 5px;
104 |     border: 1px solid var(--white-20);
105 |     z-index: 1000;
106 |     color: white;
107 |     pointer-events: none;
108 |     user-select: none;
109 |     overflow: hidden;
110 |     box-sizing: border-box;
111 | }
112 | 
113 | #heading-bar {
114 |     position: absolute;
115 |     height: 100%;
116 |     display: flex;
117 |     will-change: transform;
118 |     /* @tweakable The transition effect for the heading bar scrolling. 'none' for instant updates. */
119 |     transition: transform 0.1s linear;
120 | }
121 | 
122 | .heading-tick-container {
123 |     position: absolute;
124 |     height: 100%;
125 |     width: 1px;
126 |     display: flex;
127 |     flex-direction: column;
128 |     align-items: center;
129 | }
130 | 
131 | .heading-tick {
132 |     position: absolute;
133 |     background-color: white;
134 |     bottom: 0;
135 |     width: 1px;
136 | }
137 | 
138 | .heading-tick.major {
139 |     /* @tweakable Height of the major ticks (N, E, S, W, etc.). */
140 |     height: 15px;
141 | }
142 | 
143 | .heading-tick.minor {
144 |     /* @tweakable Height of the minor ticks (every 10 degrees). */
145 |     height: 8px;
146 | }
147 | 
148 | .heading-label {
149 |     position: absolute;
150 |     bottom: 18px; /* @tweakable Vertical position of the compass labels. */
151 |     left: 50%;
152 |     transform: translateX(-50%);
153 |     font-weight: bold;
154 | }
155 | 
156 | .heading-label.direction {
157 |     font-size: 16px; /* @tweakable Font size for direction labels (N, S, E, W). */
158 | }
159 | 
160 | .heading-label.number {
161 |     font-size: 12px; /* @tweakable Font size for degree number labels. */
162 | }
163 | 
164 | /* @tweakable Color of the 'North' indicator label. */
165 | .heading-label.north {
166 |     color: #ff4444;
167 | }
168 | 
169 | #heading-center-marker {
170 |     position: absolute;
171 |     top: 0;
172 |     left: 50%;
173 |     transform: translateX(-50%);
174 |     width: 2px;
175 |     height: 100%;
176 |     /* @tweakable Color of the center marker on the heading bar. */
177 |     background-color: white;
178 |     opacity: 0.8;
179 | }


--------------------------------------------------------------------------------
/styles/interaction.css:
--------------------------------------------------------------------------------
 1 | #interaction-prompt {
 2 |     position: absolute;
 3 |     background-color: var(--black-80);
 4 |     color: white;
 5 |     padding: 8px 12px;
 6 |     border-radius: 6px;
 7 |     pointer-events: none;
 8 |     z-index: 1500;
 9 |     box-shadow: 0 2px 5px var(--black-50);
10 |     display: flex;
11 |     flex-direction: column;
12 |     align-items: center;
13 |     text-align: center;
14 | }
15 | 
16 | .interaction-npc-name {
17 |     font-weight: bold;
18 |     margin-bottom: 4px;
19 | }
20 | 
21 | .interaction-instruction {
22 |     color: rgba(255, 255, 255, 0.8);
23 | }
24 | 
25 | #npc-conversation-modal {
26 |     position: fixed;
27 |     top: 50%;
28 |     left: 50%;
29 |     transform: translate(-50%, -50%);
30 |     width: 90%;
31 |     max-width: 500px;
32 |     background-color: var(--black-90);
33 |     color: white;
34 |     border: 2px solid var(--white-30);
35 |     border-radius: 10px;
36 |     z-index: 2500;
37 |     display: none;
38 |     flex-direction: column;
39 |     align-items: center;
40 |     padding: 20px;
41 |     box-shadow: 0 4px 20px var(--black-60);
42 |     pointer-events: auto;
43 | }
44 | 
45 | #npc-conversation-content {
46 |     width: 100%;
47 | }
48 | 
49 | #npc-conversation-content h3 {
50 |     margin-top: 0;
51 |     margin-bottom: 15px;
52 |     text-align: center;
53 |     color: #4CAF50;
54 |     font-size: 20px;
55 | }
56 | 
57 | #npc-conversation-content p {
58 |     margin: 0 0 20px 0;
59 |     line-height: 1.5;
60 |     min-height: 50px;
61 | }
62 | 
63 | #close-conversation {
64 |     width: 100%;
65 |     padding: 10px;
66 |     background-color: #f44336;
67 |     color: white;
68 |     border: none;
69 |     border-radius: 5px;
70 |     font-weight: bold;
71 |     cursor: pointer;
72 |     transition: background-color 0.2s;
73 | }
74 | 
75 | #close-conversation:hover {
76 |     background-color: #d32f2f;
77 | }


--------------------------------------------------------------------------------
/styles/inventory.css:
--------------------------------------------------------------------------------
 1 | #inventory-panel {
 2 |   position: fixed;
 3 |   top: 50%;
 4 |   left: 50%;
 5 |   transform: translate(-50%, -50%);
 6 |   background-color: var(--black-90);
 7 |   color: white;
 8 |   padding: 20px;
 9 |   border-radius: 10px;
10 |   /* @tweakable The z-index for the inventory panel. */
11 |   z-index: 2000;
12 |   display: none;
13 |   width: 90%;
14 |   max-width: 500px;
15 |   box-shadow: 0 0 20px var(--black-50);
16 |   pointer-events: auto;
17 | }
18 | 
19 | /* @tweakable Position of the inventory button on the screen. */
20 | #inventory-button {
21 |   position: fixed;
22 |   bottom: 220px;
23 |   right: 20px;
24 |   z-index: 1000;
25 |   touch-action: none;
26 |   cursor: pointer;
27 | }
28 | 
29 | #inventory-panel h2 {
30 |   margin-top: 0;
31 |   text-align: center;
32 | }
33 | 
34 | .inventory-grid {
35 |   display: grid;
36 |   grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
37 |   gap: 10px;
38 |   margin: 20px 0;
39 |   max-height: 300px;
40 |   overflow-y: auto;
41 |   padding: 10px;
42 |   background-color: var(--white-05);
43 |   border-radius: 5px;
44 | }
45 | 
46 | .inventory-item {
47 |   background-color: var(--white-20);
48 |   padding: 15px;
49 |   border-radius: 5px;
50 |   cursor: pointer;
51 |   text-align: center;
52 |   font-size: 14px;
53 |   transition: background-color 0.2s;
54 |   display: flex;
55 |   align-items: center;
56 |   justify-content: center;
57 |   height: 50px;
58 | }
59 | 
60 | .inventory-item:hover {
61 |   background-color: var(--white-30);
62 | }
63 | 
64 | #close-inventory-button {
65 |   padding: 10px 15px;
66 |   border-radius: 5px;
67 |   border: none;
68 |   cursor: pointer;
69 |   font-weight: bold;
70 |   background-color: #f44336;
71 |   color: white;
72 |   width: 100%;
73 |   margin-top: 10px;
74 | }


--------------------------------------------------------------------------------
/styles/map.css:
--------------------------------------------------------------------------------
 1 | #map-container {
 2 |     position: fixed;
 3 |     top: 50%;
 4 |     left: 50%;
 5 |     transform: translate(-50%, -50%);
 6 |     background-color: var(--black-85);
 7 |     color: white;
 8 |     padding: 20px;
 9 |     border-radius: 10px;
10 |     /* @tweakable The z-index for the map container. */
11 |     z-index: 2100; /* Above build controls etc. */
12 |     display: none;
13 |     flex-direction: column;
14 |     align-items: center;
15 |     box-shadow: 0 0 20px var(--black-50);
16 |     border: 2px solid var(--white-20);
17 |     pointer-events: auto;
18 | }
19 | 
20 | #map-header {
21 |     width: 100%;
22 |     display: flex;
23 |     justify-content: space-between;
24 |     align-items: center;
25 |     margin-bottom: 15px;
26 | }
27 | 
28 | #map-header h2 {
29 |     margin: 0;
30 |     text-align: left;
31 |     flex-grow: 1;
32 | }
33 | 
34 | #map-zoom-controls {
35 |     display: flex;
36 |     align-items: center;
37 |     gap: 8px;
38 | }
39 | 
40 | #map-zoom-controls button {
41 |     background-color: var(--white-20);
42 |     border: none;
43 |     color: white;
44 |     width: 30px;
45 |     height: 30px;
46 |     border-radius: 50%;
47 |     font-size: 18px;
48 |     font-weight: bold;
49 |     cursor: pointer;
50 |     transition: background-color 0.2s;
51 | }
52 | 
53 | #map-zoom-controls button:hover {
54 |     background-color: var(--white-30);
55 | }
56 | 
57 | #zoom-level-label {
58 |     font-weight: bold;
59 |     min-width: 60px;
60 |     text-align: center;
61 | }
62 | 
63 | #map-canvas {
64 |     border: 1px solid var(--white-30);
65 |     border-radius: 5px;
66 |     background-color: #1a2a40; /* Same as TERRAIN_LOW_COLOR */
67 | }
68 | 
69 | /* @tweakable Position of the map button on the screen. */
70 | #map-button {
71 |     position: fixed;
72 |     bottom: 290px;
73 |     right: 20px;
74 |     z-index: 1000;
75 |     touch-action: none;
76 |     cursor: pointer;
77 | }
78 | 
79 | #close-map {
80 |     position: absolute;
81 |     top: 10px;
82 |     right: 10px;
83 |     width: 20px;
84 |     height: 20px;
85 |     background-color: var(--white-70);
86 |     border-radius: 50%;
87 |     text-align: center;
88 |     line-height: 20px;
89 |     font-weight: bold;
90 |     color: #333;
91 |     cursor: pointer;
92 | }


--------------------------------------------------------------------------------
/styles/mobile.css:
--------------------------------------------------------------------------------
 1 | /* @tweakable Position and size of the movement joystick on mobile. */
 2 | #joystick-container {
 3 |   position: fixed;
 4 |   bottom: 20px;
 5 |   left: 20px;
 6 |   right: auto;
 7 |   width: 150px;
 8 |   height: 150px;
 9 |   z-index: 1000;
10 |   touch-action: none;
11 |   /* @tweakable The background color of the joystick area. */
12 |   background-color: rgba(255, 255, 255, 0.15);
13 |   border-radius: 50%;
14 |   display: none;
15 | }
16 | 
17 | #right-side-touch-area {
18 |   position: fixed;
19 |   top: 0;
20 |   right: 0;
21 |   width: 50%;
22 |   height: 100%;
23 |   z-index: 999;
24 |   touch-action: none;
25 |   display: none;
26 | }
27 | 
28 | /* @tweakable Position and size of the camera joystick on mobile. */
29 | #camera-joystick-container {
30 |     position: fixed;
31 |     bottom: 20px;
32 |     right: 20px;
33 |     width: 150px;
34 |     height: 150px;
35 |     z-index: 1000;
36 |     touch-action: none;
37 |     /* @tweakable The background color of the camera joystick area. */
38 |     background-color: var(--white-20);
39 |     border-radius: 50%;
40 | }
41 | 
42 | /* @tweakable Position and size of the jump button on mobile. */
43 | #jump-button {
44 |   position: fixed;
45 |   bottom: 30px;
46 |   right: 180px;
47 |   width: 80px;
48 |   height: 80px;
49 |   background-color: var(--white-50);
50 |   border-radius: 50%;
51 |   display: none;
52 |   z-index: 1000;
53 |   touch-action: none;
54 |   text-align: center;
55 |   line-height: 80px;
56 |   font-weight: bold;
57 |   color: #333;
58 |   user-select: none;
59 | }


--------------------------------------------------------------------------------
/styles/options.css:
--------------------------------------------------------------------------------
  1 | #options-button {
  2 |   position: fixed;
  3 |   top: 80px;
  4 |   right: 20px;
  5 |   background-color: var(--white-70);
  6 |   width: 60px;
  7 |   height: 60px;
  8 |   border-radius: 50%;
  9 |   z-index: 1000;
 10 |   touch-action: none;
 11 |   cursor: pointer;
 12 |   box-shadow: 0 2px 6px var(--black-30);
 13 |   transition: background-color 0.3s, transform 0.2s;
 14 |   display: flex;
 15 |   justify-content: center;
 16 |   align-items: center;
 17 |   color: #333;
 18 | }
 19 | 
 20 | #options-button:hover {
 21 |   background-color: #fff;
 22 |   transform: scale(1.05);
 23 | }
 24 | 
 25 | #options-modal {
 26 |   position: fixed;
 27 |   top: 50%;
 28 |   left: 50%;
 29 |   transform: translate(-50%, -50%);
 30 |   background-color: var(--black-95);
 31 |   color: #fff;
 32 |   padding: 0;
 33 |   border-radius: 10px;
 34 |   /* @tweakable The z-index for the options modal. */
 35 |   z-index: 2100;
 36 |   width: 90%;
 37 |   max-width: 450px;
 38 |   display: none;
 39 |   box-shadow: 0 0 20px var(--black-50);
 40 |   font-size: 16px;
 41 |   border: 1px solid var(--white-20);
 42 |   pointer-events: auto;
 43 | }
 44 | 
 45 | #options-header {
 46 |     display: flex;
 47 |     justify-content: space-between;
 48 |     align-items: center;
 49 |     padding: 15px 20px;
 50 |     border-bottom: 1px solid var(--white-20);
 51 | }
 52 | 
 53 | #options-header h2 {
 54 |     margin: 0;
 55 |     font-size: 22px;
 56 | }
 57 | 
 58 | #close-options {
 59 |   width: 24px;
 60 |   height: 24px;
 61 |   background-color: var(--white-20);
 62 |   border-radius: 50%;
 63 |   text-align: center;
 64 |   line-height: 24px;
 65 |   font-weight: bold;
 66 |   color: #fff;
 67 |   cursor: pointer;
 68 |   transition: background-color 0.3s;
 69 | }
 70 | 
 71 | #close-options:hover {
 72 |   background-color: var(--white-30);
 73 | }
 74 | 
 75 | #download-status {
 76 |   margin-top: 10px;
 77 |   text-align: center;
 78 |   min-height: 20px;
 79 | }
 80 | 
 81 | #replace-player-button {
 82 |   display: none;
 83 |   margin-top: 10px;
 84 | }
 85 | 
 86 | #options-tabs {
 87 |     display: flex;
 88 |     padding: 0 10px;
 89 |     border-bottom: 1px solid var(--white-20);
 90 | }
 91 | 
 92 | .options-tab {
 93 |     flex: 1;
 94 |     padding: 12px 10px;
 95 |     background-color: transparent;
 96 |     border: none;
 97 |     color: var(--white-70);
 98 |     cursor: pointer;
 99 |     font-size: 16px;
100 |     border-bottom: 2px solid transparent;
101 |     transition: color 0.2s, border-color 0.2s;
102 | }
103 | 
104 | .options-tab:hover {
105 |     color: var(--white-full);
106 | }
107 | 
108 | .options-tab.active {
109 |     color: var(--white-full);
110 |     border-bottom: 2px solid #2196F3;
111 |     font-weight: bold;
112 | }
113 | 
114 | #options-content {
115 |     padding: 20px;
116 |     min-height: 250px;
117 | }
118 | 
119 | .options-tab-content {
120 |     display: none;
121 | }
122 | 
123 | .options-tab-content.active {
124 |     display: block;
125 | }
126 | 
127 | .options-tab-content h3 {
128 |     margin-top: 0;
129 |     color: #4CAF50;
130 |     border-bottom: 1px solid var(--white-20);
131 |     padding-bottom: 8px;
132 |     margin-bottom: 15px;
133 | }
134 | 
135 | .option-item {
136 |     display: flex;
137 |     justify-content: space-between;
138 |     align-items: center;
139 |     margin-bottom: 15px;
140 | }
141 | 
142 | .option-item label {
143 |     font-weight: bold;
144 | }
145 | 
146 | .option-item select, .option-item input[type="range"] {
147 |     background-color: var(--white-20);
148 |     color: white;
149 |     border: 1px solid var(--white-30);
150 |     padding: 5px;
151 |     border-radius: 4px;
152 | }
153 | 
154 | .option-item input[type="range"] {
155 |     flex-grow: 1;
156 |     margin: 0 10px;
157 | }
158 | 
159 | .option-button {
160 |     display: block;
161 |     width: 100%;
162 |     padding: 10px;
163 |     margin-top: 10px;
164 |     border: none;
165 |     border-radius: 5px;
166 |     font-weight: bold;
167 |     cursor: pointer;
168 |     text-align: center;
169 |     background-color: var(--white-20);
170 |     color: white;
171 |     transition: background-color 0.2s;
172 | }
173 | .option-button:hover {
174 |     background-color: var(--white-30);
175 | }
176 | 
177 | #download-assets {
178 |     background-color: #2196F3;
179 | }
180 | #respawn-button {
181 |     background-color: #f44336;
182 | }
183 | 
184 | #asset-replacement-buttons {
185 |     display: none;
186 |     grid-template-columns: 1fr 1fr;
187 |     gap: 10px;
188 |     margin-top: 15px;
189 | }
190 | 
191 | #options-tab-about p {
192 |     margin: 5px 0;
193 |     line-height: 1.4;
194 |     color: var(--white-80);
195 | }


--------------------------------------------------------------------------------
/styles/overlays.css:
--------------------------------------------------------------------------------
 1 | .player-name {
 2 |   position: absolute;
 3 |   font-size: 14px;
 4 |   color: white;
 5 |   background-color: var(--black-50);
 6 |   padding: 2px 6px;
 7 |   border-radius: 8px;
 8 |   pointer-events: none;
 9 |   white-space: nowrap;
10 |   transform: translate(-50%, -100%);
11 |   text-shadow: 1px 1px 2px var(--black-50);
12 | }
13 | 
14 | .chat-message {
15 |   position: absolute;
16 |   font-size: 14px;
17 |   color: white;
18 |   /* @tweakable Background color of the chat bubbles above player heads. */
19 |   background-color: var(--black-60);
20 |   padding: 4px 8px;
21 |   border-radius: 8px;
22 |   pointer-events: none;
23 |   white-space: nowrap;
24 |   max-width: 200px;
25 |   overflow: hidden;
26 |   text-overflow: ellipsis;
27 |   transform: translate(-50%, -100%);
28 |   margin-top: -25px;
29 |   text-shadow: 1px 1px 2px var(--black-80);
30 |   opacity: 1;
31 |   /* @tweakable Fade out duration for chat bubbles above player heads. */
32 |   transition: opacity 0.5s;
33 | }
34 | 
35 | .chat-message.fade-out {
36 |   opacity: 0;
37 | }
38 | 
39 | .tooltip {
40 |   position: fixed;
41 |   padding: var(--tooltip-padding);
42 |   border-radius: var(--tooltip-border-radius);
43 |   background-color: var(--tooltip-bg);
44 |   color: var(--tooltip-color);
45 |   font-size: var(--tooltip-font-size);
46 |   pointer-events: none;
47 |   white-space: nowrap;
48 |   z-index: 5000;
49 |   opacity: 0;
50 |   transition: opacity 0.2s;
51 |   text-shadow: 1px 1px 2px var(--black-50);
52 | }


--------------------------------------------------------------------------------
/styles/responsive.css:
--------------------------------------------------------------------------------
 1 | .mobile-device #joystick-container {
 2 |   display: block;
 3 | }
 4 | 
 5 | .mobile-device #right-side-touch-area {
 6 |   display: block;
 7 | }
 8 | 
 9 | .mobile-device #jump-button {
10 |   display: block;
11 | }
12 | 
13 | .mobile-device .instructions {
14 |   display: none !important;
15 |   width: 90%;
16 |   height: 60%;
17 | }
18 | 
19 | /* @tweakable Vertical layout for main UI buttons on mobile */
20 | .mobile-device #options-button {
21 |     bottom: 180px;
22 |     right: 20px;
23 | }
24 | .mobile-device #map-button {
25 |     bottom: 250px;
26 |     right: 20px;
27 | }
28 | .mobile-device #inventory-button {
29 |     bottom: 320px;
30 |     right: 20px;
31 | }
32 | .mobile-device #chat-button {
33 |     bottom: 390px;
34 |     right: 20px;
35 | }
36 | 
37 | .mobile-device #character-creator-button {
38 |     /* @tweakable Position of the character creator button on mobile. */
39 |     top: 20px;
40 |     left: 20px;
41 | }
42 | 
43 | .mobile-device #build-button {
44 |     /* @tweakable Position of the build button on mobile. */
45 |     top: 20px;
46 |     right: 20px;
47 | }
48 | 
49 | .mobile-device #build-controls {
50 |   flex-direction: column;
51 |   bottom: 80px;
52 |   right: 20px;
53 |   left: auto;
54 |   transform: none;
55 | }
56 | 
57 | .mobile-device #height-slider-container {
58 |   top: auto;
59 |   bottom: 80px;
60 |   width: 80%;
61 | }
62 | 
63 | .mobile-device #height-slider {
64 |   width: 150px;
65 | }
66 | 
67 | .mobile-device #ai-build-modal {
68 |   width: 85%;
69 | }
70 | 
71 | .mobile-device #object-library {
72 |   top: auto;
73 |   bottom: 140px;
74 |   left: 20px;
75 |   width: 160px;
76 | }
77 | 
78 | .mobile-device #advanced-build-controls {
79 |   flex-direction: column;
80 |   bottom: 140px;
81 |   right: 20px;
82 |   left: auto;
83 |   transform: none;
84 | }
85 | 
86 | .mobile-device #color-picker {
87 |   width: 80%;
88 |   max-width: 280px;
89 | }
90 | 
91 | .mobile-device #ad-modal iframe {
92 |   width: 90%;
93 |   height: 60%;
94 | }


--------------------------------------------------------------------------------
/styles/theme.css:
--------------------------------------------------------------------------------
 1 | :root {
 2 |   --black-30: rgba(0, 0, 0, 0.3);
 3 |   --black-50: rgba(0, 0, 0, 0.5);
 4 |   --black-60: rgba(0, 0, 0, 0.6);
 5 |   --black-70: rgba(0, 0, 0, 0.7);
 6 |   --black-80: rgba(0, 0, 0, 0.8);
 7 |   --black-85: rgba(0, 0, 0, 0.85);
 8 |   --black-90: rgba(0, 0, 0, 0.9);
 9 |   --black-95: rgba(0, 0, 0, 0.95);
10 | 
11 |   --white-05: rgba(255, 255, 255, 0.05);
12 |   --white-10: rgba(255, 255, 255, 0.1);
13 |   --white-20: rgba(255, 255, 255, 0.2);
14 |   --white-30: rgba(255, 255, 255, 0.3);
15 |   --white-50: rgba(255, 255, 255, 0.5);
16 |   --white-70: rgba(255, 255, 255, 0.7);
17 |   --white-80: rgba(255, 255, 255, 0.8);
18 |   --white-90: rgba(255, 255, 255, 0.9);
19 |   --white-full: rgba(255, 255, 255, 1);
20 | 
21 |   /* @tweakable The background color of tooltips. */
22 |   --tooltip-bg: var(--black-80);
23 |   /* @tweakable The text color of tooltips. */
24 |   --tooltip-color: white;
25 |   /* @tweakable The font size for tooltips. */
26 |   --tooltip-font-size: 14px;
27 |   /* @tweakable The padding for tooltips. */
28 |   --tooltip-padding: 5px 10px;
29 |   /* @tweakable The border radius for tooltips. */
30 |   --tooltip-border-radius: 5px;
31 | }


--------------------------------------------------------------------------------
/ui/adModal.js:
--------------------------------------------------------------------------------
 1 | export class AdModal {
 2 |     constructor(dependencies) {
 3 |         this.playerControls = dependencies.playerControls;
 4 |     }
 5 |     
 6 |     setup() {
 7 |         // Ads disabled.
 8 |     }
 9 | }
10 | 
11 | 


--------------------------------------------------------------------------------
/ui/advancedBuildUI.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | 
  3 | export class AdvancedBuildUI {
  4 |     constructor(dependencies) {
  5 |         this.advancedBuildTool = dependencies.advancedBuildTool;
  6 |         this.buildTool = dependencies.buildTool;
  7 |     }
  8 | 
  9 |     create() {
 10 |         const uiContainer = document.getElementById('ui-container');
 11 | 
 12 |         const advancedBuildControls = document.createElement('div');
 13 |         advancedBuildControls.id = 'advanced-build-controls';
 14 |         advancedBuildControls.innerHTML = `
 15 |           <button id="translate-button" class="transform-button active" data-tooltip="Move Object (G)">Move (G)</button>
 16 |           <button id="rotate-button" class="transform-button" data-tooltip="Rotate Object (R)">Rotate (R)</button>
 17 |           <button id="scale-button" class="transform-button" data-tooltip="Scale Object (S)">Scale (S)</button>
 18 |           <button id="color-button" data-tooltip="Change Color">Color</button>
 19 |           <button id="color-pick-button" data-tooltip="Pick Color from Object">Pick Color</button>
 20 |           <button id="duplicate-button" data-tooltip="Duplicate Object (Ctrl+D)">Duplicate (Ctrl+D)</button>
 21 |           <button id="delete-button" data-tooltip="Delete Object (Del)">Delete</button>
 22 |           <button id="exit-advanced-build-button" data-tooltip="Exit Advanced Mode">Exit</button>
 23 |         `;
 24 |         uiContainer.appendChild(advancedBuildControls);
 25 | 
 26 |         const objectLibrary = document.createElement('div');
 27 |         objectLibrary.id = 'object-library';
 28 |         objectLibrary.innerHTML = `
 29 |           <h3>Object Library</h3>
 30 |           <div class="object-grid"></div>
 31 |         `;
 32 |         uiContainer.appendChild(objectLibrary);
 33 | 
 34 |         const selectionControls = document.createElement('div');
 35 |         selectionControls.id = 'selection-controls';
 36 |         selectionControls.innerHTML = `
 37 |           <div class="selection-info">Object Selected</div>
 38 |         `;
 39 |         uiContainer.appendChild(selectionControls);
 40 | 
 41 |         const colorPicker = document.createElement('div');
 42 |         colorPicker.id = 'color-picker';
 43 |         colorPicker.innerHTML = `
 44 |           <h3>Color Picker</h3>
 45 |           <div class="color-controls">
 46 |             <div id="color-preview"></div>
 47 |             <div class="color-inputs">
 48 |               <div class="color-input">
 49 |                 <label for="color-r">R</label>
 50 |                 <input type="number" id="color-r" min="0" max="255" value="255">
 51 |               </div>
 52 |               <div class="color-input">
 53 |                 <label for="color-g">G</label>
 54 |                 <input type="number" id="color-g" min="0" max="255" value="0">
 55 |               </div>
 56 |               <div class="color-input">
 57 |                 <label for="color-b">B</label>
 58 |                 <input type="number" id="color-b" min="0" max="255" value="0">
 59 |               </div>
 60 |             </div>
 61 |           </div>
 62 |           <button id="apply-color-button">Apply Color</button>
 63 |           <button id="close-color-picker">Close</button>
 64 |         `;
 65 |         colorPicker.style.display = 'none';
 66 |         uiContainer.appendChild(colorPicker);
 67 | 
 68 |         const objectGrid = document.querySelector('#object-library .object-grid');
 69 |         this.advancedBuildTool.objectCreator.objectLibrary.forEach(obj => {
 70 |           const objectButton = document.createElement('div');
 71 |           objectButton.className = 'object-item';
 72 |           objectButton.textContent = obj.name;
 73 |           objectButton.addEventListener('click', () => {
 74 |             this.advancedBuildTool.createObjectFromLibrary(obj.name);
 75 |           });
 76 |           objectGrid.appendChild(objectButton);
 77 |         });
 78 | 
 79 |         document.getElementById('translate-button').addEventListener('click', () => this.advancedBuildTool.setTransformMode('translate'));
 80 |         document.getElementById('rotate-button').addEventListener('click', () => this.advancedBuildTool.setTransformMode('rotate'));
 81 |         document.getElementById('scale-button').addEventListener('click', () => this.advancedBuildTool.setTransformMode('scale'));
 82 | 
 83 |         document.getElementById('color-button').addEventListener('click', () => {
 84 |             if (this.advancedBuildTool.selectedObject) {
 85 |                 document.getElementById('color-picker').style.display = 'block';
 86 |                 const color = this.advancedBuildTool.selectedObject.material.color;
 87 |                 const r = Math.round(color.r * 255);
 88 |                 const g = Math.round(color.g * 255);
 89 |                 const b = Math.round(color.b * 255);
 90 |                 document.getElementById('color-r').value = r;
 91 |                 document.getElementById('color-g').value = g;
 92 |                 document.getElementById('color-b').value = b;
 93 |                 document.getElementById('color-preview').style.backgroundColor = `rgb(${r}, ${g}, ${b})`;
 94 |             }
 95 |         });
 96 | 
 97 |         document.getElementById('color-pick-button').addEventListener('click', () => this.advancedBuildTool.toggleColorPicker());
 98 |         document.getElementById('apply-color-button').addEventListener('click', () => {
 99 |             const r = parseInt(document.getElementById('color-r').value) / 255;
100 |             const g = parseInt(document.getElementById('color-g').value) / 255;
101 |             const b = parseInt(document.getElementById('color-b').value) / 255;
102 |             this.advancedBuildTool.changeObjectColor(new THREE.Color(r, g, b));
103 |         });
104 |         document.getElementById('close-color-picker').addEventListener('click', () => {
105 |             document.getElementById('color-picker').style.display = 'none';
106 |         });
107 | 
108 |         document.getElementById('color-r').addEventListener('input', () => this.advancedBuildTool.updateColorPreview());
109 |         document.getElementById('color-g').addEventListener('input', () => this.advancedBuildTool.updateColorPreview());
110 |         document.getElementById('color-b').addEventListener('input', () => this.advancedBuildTool.updateColorPreview());
111 | 
112 |         document.getElementById('delete-button').addEventListener('click', () => this.advancedBuildTool.deleteSelectedObject());
113 |         document.getElementById('duplicate-button').addEventListener('click', () => this.advancedBuildTool.duplicateSelectedObject());
114 | 
115 |         document.getElementById('exit-advanced-build-button').addEventListener('click', () => {
116 |             this.advancedBuildTool.toggleAdvancedBuildMode();
117 |             document.getElementById('advanced-mode-button').classList.remove('active');
118 |             document.getElementById('build-controls').style.display = 'flex';
119 |             this.buildTool.previewManager.show();
120 |         });
121 | 
122 |         // Lifespan notification
123 |         let notification = document.getElementById('lifespan-notification');
124 |         if (!notification) {
125 |             notification = document.createElement('div');
126 |             notification.id = 'lifespan-notification';
127 |             uiContainer.appendChild(notification);
128 |         }
129 | 
130 |          // color picker message
131 |         const message = document.createElement('div');
132 |         message.id = 'color-picker-message';
133 |         message.style.display = 'none';
134 |         uiContainer.appendChild(message);
135 |     }
136 | }


--------------------------------------------------------------------------------
/ui/buildUI.js:
--------------------------------------------------------------------------------
  1 | export class BuildUI {
  2 |     constructor(dependencies) {
  3 |         this.playerControls = dependencies.playerControls;
  4 |         this.buildTool = dependencies.buildTool;
  5 |         this.advancedBuildTool = dependencies.advancedBuildTool;
  6 |         this.renderer = dependencies.renderer;
  7 |     }
  8 | 
  9 |     create() {
 10 |         this.createBuildUI();
 11 |         this.createAIBuildUI();
 12 |     }
 13 | 
 14 |     createBuildUI() {
 15 |         const uiContainer = document.getElementById('ui-container');
 16 |         
 17 |         // Create build tool UI
 18 |         const buildButton = document.createElement('div');
 19 |         buildButton.id = 'build-button';
 20 |         buildButton.classList.add('circle-button');
 21 |         buildButton.setAttribute('data-tooltip', 'Build Mode');
 22 |         /* @tweakable The size of the build mode hammer icon. */
 23 |         const buildIconSize = "28px";
 24 |         buildButton.innerHTML = `<img src="hammer_icon.png" alt="Build" style="width: ${buildIconSize}; height: ${buildIconSize};">`;
 25 |         uiContainer.appendChild(buildButton);
 26 |         
 27 |         const uselessButton = document.createElement('div');
 28 |         uselessButton.id = 'useless-button';
 29 |         uselessButton.innerText = 'USELESS';
 30 |         uselessButton.style.display = 'none';
 31 |         uiContainer.appendChild(uselessButton);
 32 |         
 33 |         const buildControls = document.createElement('div');
 34 |         buildControls.id = 'build-controls';
 35 |         buildControls.innerHTML = `
 36 |             <button id="shape-button" data-tooltip="Cycle Shape">Change Shape</button>
 37 |             <button id="material-button" data-tooltip="Cycle Material">Change Material</button>
 38 |             <button id="size-button" data-tooltip="Cycle Size">Change Size</button>
 39 |             <button id="rotate-button" data-tooltip="Rotate Preview">Rotate</button>
 40 |             <button id="undo-button" data-tooltip="Undo Last Placement">Undo</button>
 41 |             <button id="advanced-mode-button" data-tooltip="Advanced Build Tools">Advanced Mode</button>
 42 |             <button id="ai-build-button" data-tooltip="AI Structure Generator">AI Build</button>
 43 |             <button id="lifespan-extender-button" data-tooltip="Extend Object Lifespans">Extend Lifespan</button>
 44 |             <button id="exit-build-button" data-tooltip="Exit Build Mode">Exit Build Mode</button>
 45 |         `;
 46 |         buildControls.style.display = 'none';
 47 |         uiContainer.appendChild(buildControls);
 48 | 
 49 |         buildButton.addEventListener('click', () => {
 50 |             const isBuildEnabled = this.buildTool.toggleBuildMode();
 51 |             buildControls.style.display = isBuildEnabled ? 'flex' : 'none';
 52 |             buildButton.classList.toggle('active', isBuildEnabled);
 53 |             
 54 |             const charButton = document.getElementById('character-creator-button');
 55 |             const chatButton = document.getElementById('chat-button');
 56 | 
 57 |             if (isBuildEnabled) {
 58 |                 charButton.style.pointerEvents = 'none';
 59 |                 charButton.style.opacity = '0.5';
 60 |                 chatButton.style.pointerEvents = 'none';
 61 |                 chatButton.style.opacity = '0.5';
 62 |                 document.getElementById('ai-build-button').style.display = 'block';
 63 |             } else {
 64 |                 charButton.style.pointerEvents = 'auto';
 65 |                 charButton.style.opacity = '1';
 66 |                 chatButton.style.pointerEvents = 'auto';
 67 |                 chatButton.style.opacity = '1';
 68 |                 if(this.advancedBuildTool.enabled) {
 69 |                     this.advancedBuildTool.toggleAdvancedBuildMode();
 70 |                     document.getElementById('advanced-mode-button').classList.remove('active');
 71 |                 }
 72 |             }
 73 |         });
 74 | 
 75 |         document.getElementById('shape-button').addEventListener('click', () => this.buildTool.changeShape());
 76 |         document.getElementById('material-button').addEventListener('click', () => this.buildTool.changeMaterial());
 77 |         document.getElementById('size-button').addEventListener('click', () => this.buildTool.changeSize());
 78 |         document.getElementById('rotate-button').addEventListener('click', () => this.buildTool.rotatePreview());
 79 |         document.getElementById('undo-button').addEventListener('click', () => this.buildTool.undoLastObject());
 80 | 
 81 |         document.getElementById('exit-build-button').addEventListener('click', () => {
 82 |             this.buildTool.toggleBuildMode();
 83 |             buildControls.style.display = 'none';
 84 |             buildButton.classList.remove('active');
 85 |             
 86 |             if (this.buildTool.extendingLifespan) {
 87 |                 this.buildTool.toggleLifespanExtender();
 88 |             }
 89 |             document.getElementById('lifespan-extender-button').classList.remove('active');
 90 |             
 91 |             const charButton = document.getElementById('character-creator-button');
 92 |             const chatButton = document.getElementById('chat-button');
 93 |             charButton.style.pointerEvents = 'auto';
 94 |             charButton.style.opacity = '1';
 95 |             chatButton.style.pointerEvents = 'auto';
 96 |             chatButton.style.opacity = '1';
 97 |         });
 98 | 
 99 |         document.getElementById('advanced-mode-button').addEventListener('click', (e) => {
100 |             buildControls.style.display = 'none';
101 |             const isActive = this.advancedBuildTool.toggleAdvancedBuildMode();
102 |             e.target.classList.toggle('active', isActive);
103 |         });
104 | 
105 |         document.getElementById('lifespan-extender-button').addEventListener('click', () => {
106 |             const isExtenderActive = this.buildTool.toggleLifespanExtender();
107 |             document.getElementById('lifespan-extender-button').classList.toggle('active', isExtenderActive);
108 |             const buttonsToToggle = ['shape-button', 'material-button', 'size-button', 'rotate-button', 'undo-button', 'advanced-mode-button', 'ai-build-button'];
109 |             buttonsToToggle.forEach(id => {
110 |               document.getElementById(id).style.display = isExtenderActive ? 'none' : 'block';
111 |             });
112 |         });
113 | 
114 |         this.renderer.domElement.addEventListener('click', (event) => {
115 |             if (this.buildTool.extendingLifespan) {
116 |                 const playerPosition = this.playerControls.getPlayerModel().position.clone();
117 |                 this.buildTool.extendObjectLifespans(playerPosition);
118 |             }
119 |         });
120 | 
121 |         uselessButton.addEventListener('click', () => {
122 |             alert("This button does absolutely nothing... but you found it!");
123 |         });
124 | 
125 |         // The height indicator needs to stay in game-container to be behind modals
126 |         if (!document.getElementById('height-indicator')) {
127 |              const heightIndicator = document.createElement('div');
128 |              heightIndicator.id = 'height-indicator';
129 |              document.getElementById('game-container').appendChild(heightIndicator);
130 |         }
131 | 
132 |         this.createAIBuildUI();
133 |     }
134 | 
135 |     createAIBuildUI() {
136 |         const uiContainer = document.getElementById('ui-container');
137 |         const aiBuildModal = document.createElement('div');
138 |         aiBuildModal.id = 'ai-build-modal';
139 |         aiBuildModal.innerHTML = `
140 |             <h3>AI Structure Generator</h3>
141 |             <textarea id="ai-build-prompt" placeholder="Describe what you want to build (e.g. 'a castle with towers', 'an obstacle course with jumps', 'a cozy cottage')"></textarea>
142 |             <div class="buttons">
143 |             <button class="generate">Generate Structure</button>
144 |             <button class="cancel">Cancel</button>
145 |             </div>
146 |             <div id="ai-build-examples">
147 |             <p>Examples:</p>
148 |             <div class="ai-example">A castle with four towers and a drawbridge</div>
149 |             <div class="ai-example">An obstacle course with platforms of varying heights</div>
150 |             <div class="ai-example">A cozy cottage with a chimney and windows</div>
151 |             </div>
152 |         `;
153 |         uiContainer.appendChild(aiBuildModal);
154 | 
155 |         document.getElementById('ai-build-button').addEventListener('click', () => {
156 |             document.getElementById('ai-build-modal').style.display = 'block';
157 |         });
158 | 
159 |         document.querySelector('#ai-build-modal button.generate').addEventListener('click', () => {
160 |             const prompt = document.getElementById('ai-build-prompt').value.trim();
161 |             if (prompt.length < 3) {
162 |                 alert('Please enter a longer description');
163 |                 return;
164 |             }
165 |             document.getElementById('ai-build-modal').style.display = 'none';
166 |             this.buildTool.aiGenerateStructure(prompt);
167 |         });
168 | 
169 |         document.querySelector('#ai-build-modal button.cancel').addEventListener('click', () => {
170 |             document.getElementById('ai-build-modal').style.display = 'none';
171 |         });
172 | 
173 |         document.querySelectorAll('.ai-example').forEach(example => {
174 |             example.addEventListener('click', () => {
175 |                 document.getElementById('ai-build-prompt').value = example.textContent;
176 |             });
177 |         });
178 | 
179 |         // AI indicator should also be in UI container
180 |         let indicator = document.getElementById('ai-building-indicator');
181 |         if (!indicator) {
182 |             indicator = document.createElement('div');
183 |             indicator.id = 'ai-building-indicator';
184 |             uiContainer.appendChild(indicator);
185 |         }
186 |     }
187 | }


--------------------------------------------------------------------------------
/ui/changelogUI.js:
--------------------------------------------------------------------------------
 1 | export class ChangelogUI {
 2 |     create() {
 3 |         const uiContainer = document.getElementById('ui-container');
 4 |         const changelogButton = document.createElement('div');
 5 |         changelogButton.id = 'changelog-button';
 6 |         changelogButton.classList.add('circle-button');
 7 |         changelogButton.setAttribute('data-tooltip', 'View Changelog');
 8 |         changelogButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M15 1H4a2 2 0 00-2 2v18a2 2 0 002 2h13a1 1 0 001-1V2a1 1 0 00-1-1zM4 3h11v2H4V3zm9 6H6v2h7V9zm-3 4H6v2h4v-2z"/></svg>`;
 9 |         uiContainer.appendChild(changelogButton);
10 | 
11 |         const changelogModal = document.createElement('div');
12 |         changelogModal.id = 'changelog-modal';
13 |         changelogModal.innerHTML = `
14 |             <div id="close-changelog" data-tooltip="Close">✕</div>
15 |             <pre id="changelog-content"></pre>
16 |         `;
17 |         uiContainer.appendChild(changelogModal);
18 | 
19 |         changelogButton.addEventListener('click', async () => {
20 |             changelogModal.style.display = 'block';
21 |             const contentEl = changelogModal.querySelector('#changelog-content');
22 |             try {
23 |                 const text = await fetch('CHANGELOG.md').then(r => r.text());
24 |                 contentEl.textContent = text;
25 |             } catch (e) {
26 |                 contentEl.textContent = 'Failed to load changelog.';
27 |             }
28 |         });
29 | 
30 |         changelogModal.querySelector('#close-changelog').addEventListener('click', () => {
31 |             changelogModal.style.display = 'none';
32 |         });
33 |     }
34 | }


--------------------------------------------------------------------------------
/ui/characterCreatorUI.js:
--------------------------------------------------------------------------------
 1 | export class CharacterCreatorUI {
 2 |     constructor(dependencies) {
 3 |         this.characterCreator = dependencies.characterCreator;
 4 |     }
 5 | 
 6 |     create() {
 7 |         const uiContainer = document.getElementById('ui-container');
 8 | 
 9 |         const characterButton = document.createElement('div');
10 |         characterButton.id = 'character-creator-button';
11 |         characterButton.classList.add('circle-button');
12 |         characterButton.setAttribute('data-tooltip', 'Character Creator');
13 |         characterButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2.5a5.5 5.5 0 015.5 5.5c0 1.536-.624 2.926-1.64 3.96a7.51 7.51 0 013.64 6.04H4.5a7.51 7.51 0 013.64-6.04A5.488 5.488 0 016.5 8a5.5 5.5 0 015.5-5.5z"/></svg>`;
14 |         uiContainer.appendChild(characterButton);
15 | 
16 |         const characterModal = document.createElement('div');
17 |         characterModal.id = 'character-creator-modal';
18 |         characterModal.innerHTML = `
19 |             <h2>Create Character</h2>
20 |             <div class="creator-body">
21 |               <div class="creator-inputs">
22 |                 <label for="character-description">Description</label>
23 |                 <textarea id="character-description" placeholder="e.g. 'a red robot with glowing eyes'"></textarea>
24 |                 <div id="reference-image-container">
25 |                   <label for="reference-image" class="reference-upload-label">Reference Image (optional)</label>
26 |                   <input type="file" id="reference-image" accept="image/*">
27 |                   <div id="reference-preview"></div>
28 |                 </div>
29 |                 <button id="generate-character-button" data-tooltip="Generate character with AI">Generate</button>
30 |                 <div id="character-status"></div>
31 |               </div>
32 |               <div class="creator-preview">
33 |                 <div id="character-preview"></div>
34 |                 <div class="creator-actions">
35 |                   <button id="apply-character-button" data-tooltip="Apply and save this character">Apply & Save</button>
36 |                   <button id="cancel-character-button" data-tooltip="Close character creator">Close</button>
37 |                 </div>
38 |               </div>
39 |             </div>
40 |             <h3>Preset Characters</h3>
41 |             <div class="character-gallery" id="preset-gallery"></div>
42 |             <h3>Community Characters</h3>
43 |             <div class="character-gallery" id="character-gallery"></div>
44 |         `;
45 |         uiContainer.appendChild(characterModal);
46 | 
47 |         characterButton.addEventListener('click', () => this.characterCreator.open());
48 |         document.getElementById('generate-character-button').addEventListener('click', () => this.characterCreator.generateCharacter());
49 |         document.getElementById('apply-character-button').addEventListener('click', () => this.characterCreator.applyAndSaveCharacter());
50 |         document.getElementById('cancel-character-button').addEventListener('click', () => this.characterCreator.close());
51 |         document.getElementById('reference-image').addEventListener('change', (e) => this.characterCreator.handleReferenceImageUpload(e));
52 |     }
53 | }


--------------------------------------------------------------------------------
/ui/chatUI.js:
--------------------------------------------------------------------------------
  1 | export class ChatUI {
  2 |     constructor(dependencies) {
  3 |         this.playerControls = dependencies.playerControls;
  4 |         this.room = dependencies.room;
  5 |         this.multiplayerManager = dependencies.multiplayerManager;
  6 | 
  7 |         this.chatContainer = null;
  8 |         this.chatLog = null;
  9 |         this.chatInput = null;
 10 |         this.chatButton = null;
 11 | 
 12 |         this.isOpen = false;
 13 |         this.inputFocused = false;
 14 |         this.lastMessageTime = 0;
 15 |         /* @tweakable Time in milliseconds for the chat window to stay visible after a message. */
 16 |         this.visibilityTimeoutDuration = 8000;
 17 |         this.visibilityTimeout = null;
 18 | 
 19 |         if (this.multiplayerManager) {
 20 |             this.multiplayerManager.setChatLogMessageHandler((messageData) => this.addMessageToLog(messageData));
 21 |         }
 22 |     }
 23 | 
 24 |     create() {
 25 |         const uiContainer = document.getElementById('ui-container');
 26 | 
 27 |         this.chatContainer = document.createElement('div');
 28 |         this.chatContainer.id = 'chat-ui-container';
 29 |         uiContainer.appendChild(this.chatContainer);
 30 | 
 31 |         this.chatLog = document.createElement('div');
 32 |         this.chatLog.id = 'chat-log';
 33 |         this.chatContainer.appendChild(this.chatLog);
 34 | 
 35 |         const chatInputContainer = document.createElement('div');
 36 |         chatInputContainer.id = 'chat-input-container';
 37 |         
 38 |         this.chatInput = document.createElement('input');
 39 |         this.chatInput.id = 'chat-input';
 40 |         this.chatInput.type = 'text';
 41 |         this.chatInput.maxLength = 100;
 42 |         this.chatInput.placeholder = 'Press / to chat';
 43 |         chatInputContainer.appendChild(this.chatInput);
 44 |         
 45 |         this.chatContainer.appendChild(chatInputContainer);
 46 |         
 47 |         this.chatButton = document.createElement('div');
 48 |         this.chatButton.id = 'chat-button';
 49 |         this.chatButton.classList.add('circle-button');
 50 |         this.chatButton.setAttribute('data-tooltip', 'Toggle Chat');
 51 |         this.chatButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M4.929 19.071c-1.243-1.243-1.95-2.925-1.95-4.707C2.979 9.58 7.56 5.02 12.368 5.02c4.787 0 9.39 4.54 9.39 9.344 0 4.804-4.583 9.364-9.39 9.364a13.9 13.9 0 01-3.64-.563L4.929 19.07z"/></svg>`;
 52 |         uiContainer.appendChild(this.chatButton);
 53 | 
 54 |         this.setupEventListeners();
 55 |     }
 56 |     
 57 |     setupEventListeners() {
 58 |         document.addEventListener('keydown', (e) => {
 59 |             if (e.key === '/' && !this.inputFocused) {
 60 |                 e.preventDefault();
 61 |                 this.openChatInput();
 62 |             } else if (e.key === 'Escape' && this.inputFocused) {
 63 |                 this.closeChatInput();
 64 |             } else if (e.key === 'Enter' && this.inputFocused) {
 65 |                 this.sendChatMessage();
 66 |             }
 67 |         });
 68 | 
 69 |         this.chatInput.addEventListener('focus', () => {
 70 |             this.inputFocused = true;
 71 |             this.playerControls.enabled = false;
 72 |             this.showChatWindow(true); // Keep window open while typing
 73 |         });
 74 |         
 75 |         this.chatInput.addEventListener('blur', () => {
 76 |             this.inputFocused = false;
 77 |             if (this.playerControls) this.playerControls.enabled = true;
 78 |             this.resetVisibilityTimeout();
 79 |         });
 80 |         
 81 |         this.chatButton.addEventListener('click', (e) => {
 82 |             e.preventDefault();
 83 |             this.toggleChatWindow();
 84 |         });
 85 |     }
 86 | 
 87 |     openChatInput() {
 88 |         this.showChatWindow();
 89 |         this.chatInput.focus();
 90 |     }
 91 | 
 92 |     closeChatInput() {
 93 |         this.chatInput.value = '';
 94 |         this.chatInput.blur();
 95 |         this.hideChatWindow();
 96 |     }
 97 | 
 98 |     sendChatMessage() {
 99 |         const message = this.chatInput.value.trim();
100 |         if (message) {
101 |             this.room.updatePresence({ chat: { message, timestamp: Date.now() } });
102 |             if (this.multiplayerManager) {
103 |                 this.multiplayerManager.displayChatMessage(this.room.clientId, message);
104 |             }
105 |         }
106 |         this.closeChatInput();
107 |     }
108 | 
109 |     addMessageToLog({clientId, username, message}) {
110 |         const entry = document.createElement('div');
111 |         entry.className = 'chat-log-entry';
112 |         
113 |         const isLocal = clientId === this.room.clientId;
114 |         entry.classList.add(isLocal ? 'local-user' : 'other-user');
115 |         
116 |         const usernameSpan = document.createElement('span');
117 |         usernameSpan.className = 'username';
118 |         /* @tweakable User color for the local player's name in chat. */
119 |         const localUsernameColor = '#44aaff';
120 |         /* @tweakable User color for other players' names in chat. */
121 |         const otherUsernameColor = '#ff8888';
122 |         usernameSpan.style.color = isLocal ? localUsernameColor : otherUsernameColor;
123 |         usernameSpan.textContent = isLocal ? 'You: ' : `${username}: `;
124 |         
125 |         const messageNode = document.createTextNode(message);
126 |         
127 |         entry.appendChild(usernameSpan);
128 |         entry.appendChild(messageNode);
129 |         
130 |         this.chatLog.appendChild(entry);
131 |         this.chatLog.scrollTop = this.chatLog.scrollHeight;
132 |         
133 |         this.showChatWindow();
134 |     }
135 | 
136 |     showChatWindow(keepOpen = false) {
137 |         this.isOpen = true;
138 |         this.chatContainer.classList.add('visible');
139 |         this.lastMessageTime = Date.now();
140 |         if(this.visibilityTimeout) clearTimeout(this.visibilityTimeout);
141 |         if(!keepOpen) {
142 |             this.resetVisibilityTimeout();
143 |         }
144 |     }
145 | 
146 |     hideChatWindow() {
147 |         if (this.inputFocused) return;
148 |         this.isOpen = false;
149 |         this.chatContainer.classList.remove('visible');
150 |         if (this.visibilityTimeout) clearTimeout(this.visibilityTimeout);
151 |     }
152 |     
153 |     toggleChatWindow() {
154 |         if(this.isOpen) this.hideChatWindow();
155 |         else this.showChatWindow(true); // Keep open when manually toggled
156 |     }
157 | 
158 |     resetVisibilityTimeout() {
159 |         if (this.visibilityTimeout) clearTimeout(this.visibilityTimeout);
160 |         this.visibilityTimeout = setTimeout(() => {
161 |             if (!this.inputFocused) {
162 |                 this.hideChatWindow();
163 |             }
164 |         }, this.visibilityTimeoutDuration);
165 |     }
166 |     
167 |     update() {
168 |         if (this.isOpen && !this.inputFocused && (Date.now() - this.lastMessageTime > this.visibilityTimeoutDuration)) {
169 |             // This logic is now handled by the timeout
170 |         }
171 |     }
172 | }


--------------------------------------------------------------------------------
/ui/compassUI.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | 
  3 | export class CompassUI {
  4 |     constructor(dependencies) {
  5 |         this.playerControls = dependencies.playerControls;
  6 |         this.container = null;
  7 |         this.headingBar = null;
  8 |         this.coordsDisplay = null;
  9 |         this.lastAngleDeg = 0;
 10 |         this.continuousDegrees = 0;
 11 | 
 12 |         /* @tweakable The number of pixels per degree of rotation on the heading bar. Controls scroll speed. */
 13 |         this.pixelsPerDegree = 5;
 14 |         
 15 |         /* @tweakable An optional rotation offset in degrees to calibrate the compass direction. */
 16 |         this.rotationOffset = 0;
 17 |     }
 18 | 
 19 |     create() {
 20 |         const uiContainer = document.getElementById('ui-container');
 21 | 
 22 |         this.container = document.createElement('div');
 23 |         this.container.id = 'heading-bar-container';
 24 | 
 25 |         this.headingBar = document.createElement('div');
 26 |         this.headingBar.id = 'heading-bar';
 27 |         this.container.appendChild(this.headingBar);
 28 |         
 29 |         const centerMarker = document.createElement('div');
 30 |         centerMarker.id = 'heading-center-marker';
 31 |         this.container.appendChild(centerMarker);
 32 | 
 33 |         this.coordsDisplay = document.createElement('div');
 34 |         this.coordsDisplay.id = 'compass-coords';
 35 |         
 36 |         uiContainer.appendChild(this.container);
 37 |         uiContainer.appendChild(this.coordsDisplay);
 38 | 
 39 |         this.populateHeadingBar();
 40 | 
 41 |         // Initialize with current camera angle
 42 |         if (this.playerControls && this.playerControls.camera) {
 43 |             const cameraDirection = new THREE.Vector3();
 44 |             this.playerControls.camera.getWorldDirection(cameraDirection);
 45 |             const angleRad = Math.atan2(cameraDirection.x, cameraDirection.z);
 46 |             const angleDeg = angleRad * (180 / Math.PI);
 47 |             this.lastAngleDeg = angleDeg;
 48 |             this.continuousDegrees = -angleDeg;
 49 |         }
 50 |     }
 51 |     
 52 |     populateHeadingBar() {
 53 |         const directions = {
 54 |             0: 'N', 45: 'NE', 90: 'E', 135: 'SE', 180: 'S', 225: 'SW', 270: 'W', 315: 'NW'
 55 |         };
 56 |         const numberDegrees = [30, 60, 120, 150, 210, 240, 300, 330];
 57 | 
 58 |         const totalWidth = 360 * this.pixelsPerDegree;
 59 |         
 60 |         // We create two copies of the 360-degree ticks to allow for seamless looping
 61 |         for(let cycle = -1; cycle <= 1; cycle++) { // Create 3 cycles for smooth wrapping
 62 |             const cycleOffset = cycle * totalWidth;
 63 | 
 64 |             // Add major ticks with direction labels
 65 |             for (const deg in directions) {
 66 |                 const tickContainer = document.createElement('div');
 67 |                 tickContainer.className = 'heading-tick-container';
 68 |                 tickContainer.style.left = `${cycleOffset + parseInt(deg) * this.pixelsPerDegree}px`;
 69 |                 
 70 |                 const tick = document.createElement('div');
 71 |                 tick.className = 'heading-tick major';
 72 |                 tickContainer.appendChild(tick);
 73 | 
 74 |                 const label = document.createElement('span');
 75 |                 label.className = 'heading-label direction';
 76 |                 label.textContent = directions[deg];
 77 |                 if (parseInt(deg) === 0) {
 78 |                     label.classList.add('north');
 79 |                 }
 80 |                 tickContainer.appendChild(label);
 81 |                 
 82 |                 this.headingBar.appendChild(tickContainer);
 83 |             }
 84 | 
 85 |             // Add major ticks with number labels
 86 |             numberDegrees.forEach(deg => {
 87 |                 const tickContainer = document.createElement('div');
 88 |                 tickContainer.className = 'heading-tick-container';
 89 |                 tickContainer.style.left = `${cycleOffset + deg * this.pixelsPerDegree}px`;
 90 | 
 91 |                 const tick = document.createElement('div');
 92 |                 tick.className = 'heading-tick major';
 93 |                 tickContainer.appendChild(tick);
 94 | 
 95 |                 const label = document.createElement('span');
 96 |                 label.className = 'heading-label number';
 97 |                 label.textContent = deg;
 98 |                 tickContainer.appendChild(label);
 99 | 
100 |                 this.headingBar.appendChild(tickContainer);
101 |             });
102 |             
103 |             // Add minor ticks
104 |             for (let i = 0; i < 360; i += 10) {
105 |                 if (!directions[i] && !numberDegrees.includes(i)) {
106 |                     const tickContainer = document.createElement('div');
107 |                     tickContainer.className = 'heading-tick-container';
108 |                     tickContainer.style.left = `${cycleOffset + i * this.pixelsPerDegree}px`;
109 |                     const tick = document.createElement('div');
110 |                     tick.className = 'heading-tick minor';
111 |                     tickContainer.appendChild(tick);
112 |                     this.headingBar.appendChild(tickContainer);
113 |                 }
114 |             }
115 |         }
116 |     }
117 | 
118 |     update() {
119 |         if (!this.playerControls || !this.headingBar) return;
120 | 
121 |         const camera = this.playerControls.camera;
122 |         if (!camera) return;
123 | 
124 |         // Get camera direction
125 |         const cameraDirection = new THREE.Vector3();
126 |         camera.getWorldDirection(cameraDirection);
127 | 
128 |         // Calculate horizontal angle (azimuth)
129 |         const angleRad = Math.atan2(cameraDirection.x, cameraDirection.z);
130 |         const angleDeg = angleRad * (180 / Math.PI);
131 | 
132 |         // --- New unwrapping logic ---
133 |         const wrapThreshold = 270;
134 |         let diff = angleDeg - this.lastAngleDeg;
135 | 
136 |         if (Math.abs(diff) > wrapThreshold) {
137 |             if (diff > 0) {
138 |                 diff -= 360;
139 |             } else {
140 |                 diff += 360;
141 |             }
142 |         }
143 | 
144 |         if (isNaN(this.continuousDegrees)) {
145 |             this.continuousDegrees = -angleDeg;
146 |         }
147 | 
148 |         this.continuousDegrees -= diff;
149 |         this.lastAngleDeg = angleDeg;
150 |         // --- End new logic ---
151 | 
152 |         const correctedDegrees = this.continuousDegrees;
153 |         
154 |         
155 |         const adjustedDegrees = correctedDegrees + this.rotationOffset;
156 |         
157 |         const barWidth = this.container.offsetWidth;
158 | 
159 |         // Center the current degree in the middle of the container
160 |         const offset = -adjustedDegrees * this.pixelsPerDegree + barWidth / 2;
161 |         
162 |         // Use modulo to wrap the offset for seamless scrolling with 3 cycles
163 |         const totalBarWidth = 360 * this.pixelsPerDegree;
164 |         const wrappedOffset = offset % totalBarWidth;
165 |         
166 |         this.headingBar.style.transform = `translateX(${wrappedOffset}px)`;
167 | 
168 |         const playerModel = this.playerControls.getPlayerModel();
169 |         if (!playerModel) return;
170 |         const pos = playerModel.position;
171 |         this.coordsDisplay.textContent = `X: ${pos.x.toFixed(1)} | Y: ${pos.y.toFixed(1)} | Z: ${pos.z.toFixed(1)}`;
172 |     }
173 | }


--------------------------------------------------------------------------------
/ui/inventoryUI.js:
--------------------------------------------------------------------------------
 1 | export class InventoryUI {
 2 |     constructor(dependencies) {
 3 |         this.objectCreator = dependencies.objectCreator;
 4 |         this.inventoryManager = dependencies.inventoryManager;
 5 |         this.panel = null;
 6 |     }
 7 | 
 8 |     create() {
 9 |         const uiContainer = document.getElementById('ui-container');
10 | 
11 |         const inventoryButton = document.createElement('div');
12 |         inventoryButton.id = 'inventory-button';
13 |         inventoryButton.classList.add('circle-button');
14 |         inventoryButton.setAttribute('data-tooltip', 'Inventory (I)');
15 |         inventoryButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M18.88 4.02A1.5 1.5 0 0017.5 3h-11a1.5 1.5 0 00-1.38 1.02L2.5 12.19l-1 5A1.5 1.5 0 003 19h18a1.5 1.5 0 001.5-1.81l-1-5-2.62-8.17zM12 11.5a2.5 2.5 0 01-2.5-2.5A2.5 2.5 0 0112 6.5a2.5 2.5 0 012.5 2.5A2.5 2.5 0 0112 11.5z"/></svg>`;
16 |         uiContainer.appendChild(inventoryButton);
17 | 
18 |         const inventoryPanel = document.createElement('div');
19 |         inventoryPanel.id = 'inventory-panel';
20 |         inventoryPanel.innerHTML = `
21 |             <h2>Inventory</h2>
22 |             <div class="inventory-grid"></div>
23 |             <button id="close-inventory-button" data-tooltip="Close Inventory">Close</button>
24 |         `;
25 |         uiContainer.appendChild(inventoryPanel);
26 |         this.panel = inventoryPanel;
27 | 
28 |         const objectGrid = this.panel.querySelector('.inventory-grid');
29 |         if (this.objectCreator && this.objectCreator.objectLibrary) {
30 |             this.objectCreator.objectLibrary.forEach(obj => {
31 |                 const itemEl = document.createElement('div');
32 |                 itemEl.className = 'inventory-item';
33 |                 itemEl.textContent = obj.name;
34 |                 itemEl.addEventListener('click', () => {
35 |                     this.objectCreator.createObject(obj.name);
36 |                     this.inventoryManager.toggle(); // Close inventory after creating an item
37 |                 });
38 |                 objectGrid.appendChild(itemEl);
39 |             });
40 |         }
41 | 
42 |         inventoryButton.addEventListener('click', () => {
43 |             this.inventoryManager.toggle();
44 |         });
45 | 
46 |         document.getElementById('close-inventory-button').addEventListener('click', () => {
47 |             this.inventoryManager.toggle();
48 |         });
49 |     }
50 | 
51 |     toggle(visible) {
52 |         if (this.panel) {
53 |             this.panel.style.display = visible ? 'block' : 'none';
54 |         }
55 |     }
56 | }


--------------------------------------------------------------------------------
/ui/mapUI.js:
--------------------------------------------------------------------------------
  1 | import * as THREE from 'three';
  2 | import { ZONE_SIZE, ZONES_PER_CHUNK_SIDE, CHUNKS_PER_CLUSTER_SIDE } from '../js/worldGeneration.js';
  3 | 
  4 | /* @tweakable The base size of the map display in pixels. */
  5 | const MAP_SIZE = 400;
  6 | /* @tweakable The background color of the map. */
  7 | const MAP_BG_COLOR = 'rgba(20, 30, 40, 0.8)';
  8 | /* @tweakable The color of the grid lines on the map. */
  9 | const GRID_COLOR = 'rgba(255, 255, 255, 0.2)';
 10 | /* @tweakable The color of the player's marker on the map. */
 11 | const PLAYER_MARKER_COLOR = '#44aaff';
 12 | /* @tweakable The size of the player's marker on the map. */
 13 | const PLAYER_MARKER_SIZE = 8;
 14 | /* @tweakable The color of other players' markers on the map. */
 15 | const OTHER_PLAYER_MARKER_COLOR = '#ff4444';
 16 | /* @tweakable The size of other players' markers on the map. */
 17 | const OTHER_PLAYER_MARKER_SIZE = 5;
 18 | /* @tweakable The color of built objects' markers on the map. */
 19 | const BUILD_OBJECT_MARKER_COLOR = '#aaffaa';
 20 | /* @tweakable The size of built objects' markers on the map. */
 21 | const BUILD_OBJECT_MARKER_SIZE = 2;
 22 | /* @tweakable The color of the terrain's lowest parts. */
 23 | const TERRAIN_LOW_COLOR = '#1a2a40';
 24 | /* @tweakable The color of the terrain's highest parts. */
 25 | const TERRAIN_HIGH_COLOR = '#99aa88';
 26 | /* @tweakable The minimum height considered when coloring the terrain. */
 27 | const TERRAIN_MIN_HEIGHT = -10;
 28 | /* @tweakable The maximum height considered when coloring the terrain. */
 29 | const TERRAIN_MAX_HEIGHT = 10;
 30 | /* @tweakable The color of tree markers on the map. */
 31 | const TREE_MARKER_COLOR = '#228b22';
 32 | /* @tweakable The size of tree markers on the map. */
 33 | const TREE_MARKER_SIZE = 2;
 34 | /* @tweakable The color of barrier markers on the map. */
 35 | const BARRIER_MARKER_COLOR = '#888888';
 36 | /* @tweakable The size of barrier markers on the map. */
 37 | const BARRIER_MARKER_SIZE = 2;
 38 | 
 39 | export class MapUI {
 40 |     constructor(dependencies) {
 41 |         this.playerControls = dependencies.playerControls;
 42 |         this.buildTool = dependencies.buildTool;
 43 |         this.advancedBuildTool = dependencies.advancedBuildTool;
 44 |         this.multiplayerManager = dependencies.multiplayerManager;
 45 | 
 46 |         this.mapContainer = null;
 47 |         this.mapCanvas = null;
 48 |         this.ctx = null;
 49 |         this.isOpen = false;
 50 | 
 51 |         this.scene = this.playerControls.scene;
 52 |         this.staticObjects = { trees: [], barriers: [] };
 53 |         
 54 |         this.CHUNK_SIZE = ZONE_SIZE * ZONES_PER_CHUNK_SIDE;
 55 |         this.CLUSTER_SIZE = this.CHUNK_SIZE * CHUNKS_PER_CLUSTER_SIDE;
 56 | 
 57 |         // Order zoom levels from most zoomed-in to widest view
 58 |         this.zoomLevels = [
 59 |             { name: 'Zone', scale: ZONE_SIZE },
 60 |             { name: 'Chunk', scale: this.CHUNK_SIZE },
 61 |             { name: 'Cluster', scale: this.CLUSTER_SIZE }
 62 |         ];
 63 |         // Start at Chunk view
 64 |         this.currentZoomIndex = 1;
 65 | 
 66 |         this.terrainCanvas = null; // for pre-rendering terrain
 67 |     }
 68 | 
 69 |     create() {
 70 |         const uiContainer = document.getElementById('ui-container');
 71 |         this.mapContainer = document.createElement('div');
 72 |         this.mapContainer.id = 'map-container';
 73 | 
 74 |         this.mapContainer.innerHTML = `
 75 |             <div id="map-header">
 76 |                 <h2>World Map</h2>
 77 |                 <div id="map-zoom-controls">
 78 |                     <button id="zoom-out-btn" data-tooltip="Zoom Out">-</button>
 79 |                     <span id="zoom-level-label"></span>
 80 |                     <button id="zoom-in-btn" data-tooltip="Zoom In">+</button>
 81 |                 </div>
 82 |                 <div id="close-map" data-tooltip="Close Map (M)">✕</div>
 83 |             </div>
 84 |         `;
 85 | 
 86 |         this.mapCanvas = document.createElement('canvas');
 87 |         this.mapCanvas.id = 'map-canvas';
 88 |         this.mapCanvas.width = MAP_SIZE;
 89 |         this.mapCanvas.height = MAP_SIZE;
 90 |         this.mapContainer.appendChild(this.mapCanvas);
 91 |         
 92 |         this.ctx = this.mapCanvas.getContext('2d');
 93 | 
 94 |         const mapButton = document.createElement('div');
 95 |         mapButton.id = 'map-button';
 96 |         mapButton.classList.add('circle-button');
 97 |         /* @tweakable The size of the map icon. */
 98 |         const mapIconSize = "28px";
 99 |         mapButton.innerHTML = `<img src="map_icon.png" alt="Map" style="width: ${mapIconSize}; height: ${mapIconSize};">`;
100 |         uiContainer.appendChild(mapButton);
101 | 
102 |         uiContainer.appendChild(this.mapContainer);
103 | 
104 |         mapButton.addEventListener('click', () => this.toggle());
105 |         this.mapContainer.querySelector('#close-map').addEventListener('click', () => this.toggle());
106 | 
107 |         window.addEventListener('keydown', (e) => {
108 |             if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA') {
109 |                 return;
110 |             }
111 |             if (e.key.toLowerCase() === 'm') {
112 |                 this.toggle();
113 |             }
114 |         });
115 | 
116 |         document.getElementById('zoom-in-btn').addEventListener('click', () => this.zoomIn());
117 |         document.getElementById('zoom-out-btn').addEventListener('click', () => this.zoomOut());
118 | 
119 |         this.preRenderTerrain();
120 |         this.gatherStaticObjects();
121 |     }
122 | 
123 |     preRenderTerrain() {
124 |         this.terrainCanvas = document.createElement('canvas');
125 |         this.terrainCanvas.width = MAP_SIZE;
126 |         this.terrainCanvas.height = MAP_SIZE;
127 |         const terrainCtx = this.terrainCanvas.getContext('2d');
128 |         const terrain = this.playerControls.terrain;
129 |         if (!terrain || !terrain.material || !terrain.material.map) return;
130 | 
131 |         const textureLoader = new THREE.TextureLoader();
132 |         textureLoader.load('ground_texture.png', (texture) => {
133 |             const tmpCanvas = document.createElement('canvas');
134 |             tmpCanvas.width = texture.image.width;
135 |             tmpCanvas.height = texture.image.height;
136 |             const tmpCtx = tmpCanvas.getContext('2d');
137 |             tmpCtx.drawImage(texture.image, 0, 0);
138 |             const texData = tmpCtx.getImageData(0, 0, tmpCanvas.width, tmpCanvas.height).data;
139 | 
140 |             const imageData = terrainCtx.createImageData(MAP_SIZE, MAP_SIZE);
141 |             const data = imageData.data;
142 | 
143 |             const repeat = terrain.material.map.repeat;
144 | 
145 |             const lowRgb = this.hexToRgb(TERRAIN_LOW_COLOR);
146 |             const highRgb = this.hexToRgb(TERRAIN_HIGH_COLOR);
147 | 
148 |             for (let y = 0; y < MAP_SIZE; y++) {
149 |                 for (let x = 0; x < MAP_SIZE; x++) {
150 |                     const worldX = (x / MAP_SIZE - 0.5) * this.CLUSTER_SIZE;
151 |                     const worldZ = (y / MAP_SIZE - 0.5) * this.CLUSTER_SIZE;
152 | 
153 |                     let u = ((worldX / this.CLUSTER_SIZE) + 0.5) * repeat.x;
154 |                     let v = ((worldZ / this.CLUSTER_SIZE) + 0.5) * repeat.y;
155 |                     u = ((u % 1) + 1) % 1;
156 |                     v = ((v % 1) + 1) % 1;
157 | 
158 |                     const texX = Math.floor(u * tmpCanvas.width);
159 |                     const texY = Math.floor(v * tmpCanvas.height);
160 |                     const texIndex = (texY * tmpCanvas.width + texX) * 4;
161 |                     const index = (y * MAP_SIZE + x) * 4;
162 | 
163 |                     const height = terrain.userData.getHeight(worldX, worldZ);
164 |                     let t = (height - TERRAIN_MIN_HEIGHT) / (TERRAIN_MAX_HEIGHT - TERRAIN_MIN_HEIGHT);
165 |                     t = Math.max(0, Math.min(1, t));
166 |                     const shadeR = lowRgb.r + (highRgb.r - lowRgb.r) * t;
167 |                     const shadeG = lowRgb.g + (highRgb.g - lowRgb.g) * t;
168 |                     const shadeB = lowRgb.b + (highRgb.b - lowRgb.b) * t;
169 | 
170 |                     data[index] = texData[texIndex] * 0.6 + shadeR * 0.4;
171 |                     data[index + 1] = texData[texIndex + 1] * 0.6 + shadeG * 0.4;
172 |                     data[index + 2] = texData[texIndex + 2] * 0.6 + shadeB * 0.4;
173 |                     data[index + 3] = 255;
174 |                 }
175 |             }
176 |             terrainCtx.putImageData(imageData, 0, 0);
177 |         });
178 |     }
179 | 
180 |     gatherStaticObjects() {
181 |         if (!this.scene) return;
182 |         this.staticObjects.trees = [];
183 |         this.staticObjects.barriers = [];
184 |         this.scene.traverse(obj => {
185 |             if (!obj.userData) return;
186 |             if (obj.userData.isTree) {
187 |                 this.staticObjects.trees.push(obj);
188 |             } else if (obj.userData.isBarrier) {
189 |                 this.staticObjects.barriers.push(obj);
190 |             }
191 |         });
192 |     }
193 |     
194 |     hexToRgb(hex) {
195 |         const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
196 |         return result ? {
197 |             r: parseInt(result[1], 16),
198 |             g: parseInt(result[2], 16),
199 |             b: parseInt(result[3], 16)
200 |         } : null;
201 |     }
202 | 
203 |     zoomIn() {
204 |         this.currentZoomIndex = Math.max(0, this.currentZoomIndex - 1);
205 |         this.update();
206 |     }
207 | 
208 |     zoomOut() {
209 |         this.currentZoomIndex = Math.min(this.zoomLevels.length - 1, this.currentZoomIndex + 1);
210 |         this.update();
211 |     }
212 | 
213 |     toggle() {
214 |         this.isOpen = !this.isOpen;
215 |         this.mapContainer.style.display = this.isOpen ? 'flex' : 'none';
216 |         this.playerControls.enabled = !this.isOpen;
217 | 
218 |         if (this.isOpen) {
219 |             this.update();
220 |         }
221 |     }
222 |     
223 |     worldToMap(pos, mapCenter, mapScale) {
224 |         const mapX = (pos.x - mapCenter.x) * mapScale + MAP_SIZE / 2;
225 |         const mapY = (pos.z - mapCenter.z) * mapScale + MAP_SIZE / 2;
226 |         return { x: mapX, y: mapY };
227 |     }
228 | 
229 |     update() {
230 |         if (!this.isOpen || !this.ctx) {
231 |             return;
232 |         }
233 | 
234 |         const zoomLevel = this.zoomLevels[this.currentZoomIndex];
235 |         document.getElementById('zoom-level-label').textContent = zoomLevel.name;
236 | 
237 |         const playerPos = this.playerControls.getPlayerModel().position;
238 |         const mapCenter = playerPos;
239 | 
240 |         const mapScale = MAP_SIZE / zoomLevel.scale;
241 |         
242 |         // Draw background
243 |         this.ctx.fillStyle = MAP_BG_COLOR;
244 |         this.ctx.fillRect(0, 0, MAP_SIZE, MAP_SIZE);
245 |         
246 |         // Draw pre-rendered terrain
247 |         if (this.terrainCanvas) {
248 |             const terrainScale = zoomLevel.scale / this.CLUSTER_SIZE;
249 |             const srcSize = MAP_SIZE * terrainScale;
250 |             const srcX = MAP_SIZE / 2 + (mapCenter.x / this.CLUSTER_SIZE) * MAP_SIZE - srcSize / 2;
251 |             const srcY = MAP_SIZE / 2 + (mapCenter.z / this.CLUSTER_SIZE) * MAP_SIZE - srcSize / 2;
252 |             
253 |             this.ctx.drawImage(this.terrainCanvas, srcX, srcY, srcSize, srcSize, 0, 0, MAP_SIZE, MAP_SIZE);
254 |         }
255 | 
256 |         // Draw grid
257 |         this.ctx.strokeStyle = GRID_COLOR;
258 |         this.ctx.lineWidth = 1;
259 |         
260 |         const worldTopLeft = {
261 |             x: mapCenter.x - zoomLevel.scale / 2,
262 |             z: mapCenter.z - zoomLevel.scale / 2
263 |         };
264 | 
265 |         let gridSize;
266 |         if (zoomLevel.name === 'Cluster') gridSize = this.CHUNK_SIZE;
267 |         else if (zoomLevel.name === 'Chunk') gridSize = ZONE_SIZE;
268 |         else gridSize = ZONE_SIZE / 5; // Finer grid for zone view
269 | 
270 |         const startX = Math.floor(worldTopLeft.x / gridSize) * gridSize;
271 |         const startZ = Math.floor(worldTopLeft.z / gridSize) * gridSize;
272 | 
273 |         for(let x = startX; x < worldTopLeft.x + zoomLevel.scale; x += gridSize) {
274 |             const linePos = this.worldToMap({x: x, z: 0}, mapCenter, mapScale);
275 |             this.ctx.beginPath();
276 |             this.ctx.moveTo(linePos.x, 0);
277 |             this.ctx.lineTo(linePos.x, MAP_SIZE);
278 |             this.ctx.stroke();
279 |         }
280 | 
281 |         for(let z = startZ; z < worldTopLeft.z + zoomLevel.scale; z += gridSize) {
282 |             const linePos = this.worldToMap({x: 0, z: z}, mapCenter, mapScale);
283 |             this.ctx.beginPath();
284 |             this.ctx.moveTo(0, linePos.y);
285 |             this.ctx.lineTo(MAP_SIZE, linePos.y);
286 |             this.ctx.stroke();
287 |         }
288 | 
289 |         // Draw static objects
290 |         const tempPos = new THREE.Vector3();
291 | 
292 |         this.ctx.fillStyle = TREE_MARKER_COLOR;
293 |         this.staticObjects.trees.forEach(obj => {
294 |             obj.getWorldPosition(tempPos);
295 |             const mapPos = this.worldToMap(tempPos, mapCenter, mapScale);
296 |             if (mapPos.x >= 0 && mapPos.x <= MAP_SIZE && mapPos.y >= 0 && mapPos.y <= MAP_SIZE) {
297 |                 this.ctx.fillRect(mapPos.x - TREE_MARKER_SIZE / 2, mapPos.y - TREE_MARKER_SIZE / 2, TREE_MARKER_SIZE, TREE_MARKER_SIZE);
298 |             }
299 |         });
300 | 
301 |         this.ctx.fillStyle = BARRIER_MARKER_COLOR;
302 |         this.staticObjects.barriers.forEach(obj => {
303 |             obj.getWorldPosition(tempPos);
304 |             const mapPos = this.worldToMap(tempPos, mapCenter, mapScale);
305 |             if (mapPos.x >= 0 && mapPos.x <= MAP_SIZE && mapPos.y >= 0 && mapPos.y <= MAP_SIZE) {
306 |                 this.ctx.fillRect(mapPos.x - BARRIER_MARKER_SIZE / 2, mapPos.y - BARRIER_MARKER_SIZE / 2, BARRIER_MARKER_SIZE, BARRIER_MARKER_SIZE);
307 |             }
308 |         });
309 | 
310 |         // Draw build objects
311 |         const allObjects = [...this.buildTool.buildObjects, ...this.advancedBuildTool.advancedBuildObjects];
312 |         this.ctx.fillStyle = BUILD_OBJECT_MARKER_COLOR;
313 |         allObjects.forEach(obj => {
314 |             const mapPos = this.worldToMap(obj.position, mapCenter, mapScale);
315 |             if (mapPos.x >= 0 && mapPos.x <= MAP_SIZE && mapPos.y >= 0 && mapPos.y <= MAP_SIZE) {
316 |                 this.ctx.fillRect(mapPos.x - BUILD_OBJECT_MARKER_SIZE / 2, mapPos.y - BUILD_OBJECT_MARKER_SIZE / 2, BUILD_OBJECT_MARKER_SIZE, BUILD_OBJECT_MARKER_SIZE);
317 |             }
318 |         });
319 | 
320 |         // Draw other players
321 |         if (this.multiplayerManager) {
322 |             this.ctx.fillStyle = OTHER_PLAYER_MARKER_COLOR;
323 |             this.ctx.strokeStyle = 'rgba(255,255,255,0.7)';
324 |             this.ctx.lineWidth = 1;
325 |             for (const id in this.multiplayerManager.otherPlayers) {
326 |                 const otherPlayer = this.multiplayerManager.otherPlayers[id];
327 |                 const mapPos = this.worldToMap(otherPlayer.position, mapCenter, mapScale);
328 |                 if (mapPos.x >= 0 && mapPos.x <= MAP_SIZE && mapPos.y >= 0 && mapPos.y <= MAP_SIZE) {
329 |                     this.ctx.beginPath();
330 |                     this.ctx.arc(mapPos.x, mapPos.y, OTHER_PLAYER_MARKER_SIZE, 0, 2 * Math.PI);
331 |                     this.ctx.fill();
332 |                     this.ctx.stroke();
333 |                 }
334 |             }
335 |         }
336 | 
337 |         // Draw player marker (arrow/triangle)
338 |         const playerMapPos = this.worldToMap(playerPos, mapCenter, mapScale);
339 |         const playerRotationY = this.playerControls.getPlayerModel().rotation.y;
340 | 
341 |         this.ctx.save();
342 |         this.ctx.translate(playerMapPos.x, playerMapPos.y);
343 |         this.ctx.rotate(playerRotationY);
344 |         
345 |         this.ctx.fillStyle = PLAYER_MARKER_COLOR;
346 |         this.ctx.strokeStyle = 'white';
347 |         this.ctx.lineWidth = 1.5;
348 | 
349 |         this.ctx.beginPath();
350 |         // The tip of the triangle points 'up' in the rotated context, which corresponds to player's forward direction.
351 |         this.ctx.moveTo(0, -PLAYER_MARKER_SIZE); // Tip
352 |         this.ctx.lineTo(-PLAYER_MARKER_SIZE * 0.7, PLAYER_MARKER_SIZE * 0.7); // Bottom-left
353 |         this.ctx.lineTo(PLAYER_MARKER_SIZE * 0.7, PLAYER_MARKER_SIZE * 0.7); // Bottom-right
354 |         this.ctx.closePath();
355 |         
356 |         this.ctx.fill();
357 |         this.ctx.stroke();
358 |         
359 |         this.ctx.restore();
360 |     }
361 | }


--------------------------------------------------------------------------------
/ui/optionsUI.js:
--------------------------------------------------------------------------------
  1 | import { AssetReplacementManager } from '../js/assetReplacementManager.js';
  2 | import * as THREE from "three";
  3 | 
  4 | export class OptionsUI {
  5 |     constructor(dependencies) {
  6 |         this.dependencies = dependencies;
  7 |         this.assetReplacementManager = dependencies.assetReplacementManager;
  8 |         this.playerControls = dependencies.playerControls;
  9 |         this.renderer = dependencies.renderer;
 10 |         this.dirLight = dependencies.dirLight;
 11 |         this.scene = dependencies.scene;
 12 |     }
 13 | 
 14 |     create() {
 15 |         const uiContainer = document.getElementById('ui-container');
 16 |         const button = document.createElement('div');
 17 |         button.id = 'options-button';
 18 |         button.classList.add('circle-button');
 19 |         button.setAttribute('data-tooltip', 'Options');
 20 |         /* @tweakable The size of the options gear icon. */
 21 |         const optionsIconSize = "28px";
 22 |         button.innerHTML = `<img src="gear_icon.png" alt="Options" style="width: ${optionsIconSize}; height: ${optionsIconSize};">`;
 23 |         uiContainer.appendChild(button);
 24 | 
 25 |         const modal = document.createElement('div');
 26 |         modal.id = 'options-modal';
 27 |         modal.style.display = 'none';
 28 |         modal.innerHTML = `
 29 |             <div id="options-header">
 30 |                 <h2>Options</h2>
 31 |                 <div id="close-options" data-tooltip="Close Options">✕</div>
 32 |             </div>
 33 |             <div id="options-tabs">
 34 |                 <button class="options-tab active" data-tab="general">General</button>
 35 |                 <button class="options-tab" data-tab="assets">Assets</button>
 36 |                 <button class="options-tab" data-tab="about">About</button>
 37 |             </div>
 38 |             <div id="options-content">
 39 |                 <div id="options-tab-general" class="options-tab-content active">
 40 |                     <h3>General Settings</h3>
 41 |                     <div class="option-item">
 42 |                         <label for="shadow-quality">Shadow Quality</label>
 43 |                         <select id="shadow-quality">
 44 |                             <option value="high">High</option>
 45 |                             <option value="medium" selected>Medium</option>
 46 |                             <option value="low">Low</option>
 47 |                             <option value="off">Off</option>
 48 |                         </select>
 49 |                     </div>
 50 |                      <div class="option-item">
 51 |                         <label for="view-distance">View Distance</label>
 52 |                         <input type="range" id="view-distance" min="50" max="250" value="100" step="10">
 53 |                         <span id="view-distance-value">100</span>
 54 |                     </div>
 55 |                     <button id="respawn-button" class="option-button" data-tooltip="Return to the starting area">Respawn</button>
 56 |                 </div>
 57 |                 <div id="options-tab-assets" class="options-tab-content">
 58 |                     <h3>Asset Replacement</h3>
 59 |                     <button id="download-assets" class="option-button" data-tooltip="Download assets for animated models">Download All Assets</button>
 60 |                     <div id="download-status"></div>
 61 |                     <div id="asset-replacement-buttons">
 62 |                         <button class="option-button" id="use-all-assets-button" style="grid-column: 1 / -1; background-color: #4CAF50;" data-tooltip="Replace all characters with animated versions">Use All Animated Models</button>
 63 |                         <button class="option-button" id="replace-player-button" data-tooltip="Use an animated model for your player">Use Animated Player</button>
 64 |                         <button class="option-button" id="replace-robots-button" data-tooltip="Replace robot NPCs with animated models">Use Animated Robots</button>
 65 |                         <button class="option-button" id="replace-eyebots-button" data-tooltip="Replace eyebot NPCs with models">Use Eyebots</button>
 66 |                         <button class="option-button" id="replace-chickens-button" data-tooltip="Replace chicken NPCs with animated models">Use Animated Chickens</button>
 67 |                         <button class="option-button" id="replace-wireframes-button" data-tooltip="Replace wireframe NPCs with animated models">Use Animated Wireframes</button>
 68 |                         <button class="option-button" id="replace-aliens-button" data-tooltip="Replace alien NPCs with animated models">Use Animated Aliens</button>
 69 |                     </div>
 70 |                 </div>
 71 |                 <div id="options-tab-about" class="options-tab-content">
 72 |                     <h3>About</h3>
 73 |                     <p>3D Overworld Template v1.9</p>
 74 |                     <p>Created with Websim for educational purposes.</p>
 75 |                     <p>Models from Mixamo. Project by LordTsarcasm.</p>
 76 |                 </div>
 77 |             </div>
 78 |         `;
 79 |         uiContainer.appendChild(modal);
 80 |         
 81 |         this.assetReplacementManager.setStatusElement(modal.querySelector('#download-status'));
 82 | 
 83 |         button.addEventListener('click', () => {
 84 |             modal.style.display = 'block';
 85 |             this.playerControls.enabled = false;
 86 |         });
 87 | 
 88 |         modal.querySelector('#close-options').addEventListener('click', () => {
 89 |             modal.style.display = 'none';
 90 |             this.playerControls.enabled = true;
 91 |         });
 92 | 
 93 |         // Tab switching logic
 94 |         modal.querySelectorAll('.options-tab').forEach(tab => {
 95 |             tab.addEventListener('click', (e) => {
 96 |                 const tabName = e.target.dataset.tab;
 97 |                 modal.querySelectorAll('.options-tab').forEach(t => t.classList.remove('active'));
 98 |                 e.target.classList.add('active');
 99 |                 modal.querySelectorAll('.options-tab-content').forEach(content => {
100 |                     content.classList.remove('active');
101 |                 });
102 |                 modal.querySelector(`#options-tab-${tabName}`).classList.add('active');
103 |             });
104 |         });
105 | 
106 |         // Respawn logic
107 |         modal.querySelector('#respawn-button').addEventListener('click', () => {
108 |             const playerModel = this.playerControls.getPlayerModel();
109 |             playerModel.position.set(0, 5, 0); // Respawn at center, slightly elevated
110 |             this.playerControls.velocity.set(0, 0, 0); // Reset velocity
111 |             modal.style.display = 'none';
112 |             this.playerControls.enabled = true;
113 |         });
114 |         
115 |         // Shadow Quality Logic
116 |         const shadowQualitySelect = modal.querySelector('#shadow-quality');
117 |         shadowQualitySelect.value = localStorage.getItem('shadowQuality') || 'medium';
118 |         this.applyShadowQuality(shadowQualitySelect.value);
119 |         shadowQualitySelect.addEventListener('change', (e) => {
120 |             this.applyShadowQuality(e.target.value);
121 |             localStorage.setItem('shadowQuality', e.target.value);
122 |         });
123 | 
124 |         // View distance logic
125 |         const viewDistanceSlider = modal.querySelector('#view-distance');
126 |         const viewDistanceValue = modal.querySelector('#view-distance-value');
127 |         viewDistanceSlider.value = this.playerControls.camera.far;
128 |         viewDistanceValue.textContent = this.playerControls.camera.far;
129 |         viewDistanceSlider.addEventListener('input', (e) => {
130 |             const distance = parseInt(e.target.value);
131 |             this.playerControls.camera.far = distance;
132 |             this.playerControls.camera.updateProjectionMatrix();
133 |             viewDistanceValue.textContent = distance;
134 |         });
135 |         
136 |         const replaceButtons = [
137 |             'use-all-assets-button', 'replace-player-button', 'replace-robots-button', 'replace-eyebots-button',
138 |             'replace-chickens-button', 'replace-wireframes-button', 'replace-aliens-button'
139 |         ];
140 | 
141 |         const toggleReplaceButtons = (show) => {
142 |             const container = modal.querySelector('#asset-replacement-buttons');
143 |             if (container) {
144 |                 container.style.display = show ? 'grid' : 'none';
145 |             }
146 |         };
147 |         
148 |         toggleReplaceButtons(false);
149 | 
150 |         modal.querySelector('#download-assets').addEventListener('click', async () => {
151 |             const success = await this.assetReplacementManager.downloadExternalAssets();
152 |             if (success) {
153 |                 toggleReplaceButtons(true);
154 |             }
155 |         });
156 | 
157 |         modal.querySelector('#use-all-assets-button').addEventListener('click', () => {
158 |             this.assetReplacementManager.replaceAllModels();
159 |         });
160 | 
161 |         modal.querySelector('#replace-player-button').addEventListener('click', () => {
162 |             this.assetReplacementManager.replaceModel('player');
163 |         });
164 |         modal.querySelector('#replace-robots-button').addEventListener('click', () => {
165 |             this.assetReplacementManager.replaceModel('robot');
166 |         });
167 |         modal.querySelector('#replace-eyebots-button').addEventListener('click', () => {
168 |             this.assetReplacementManager.replaceModel('eyebot');
169 |         });
170 |         modal.querySelector('#replace-chickens-button').addEventListener('click', () => {
171 |             this.assetReplacementManager.replaceModel('chicken');
172 |         });
173 |         modal.querySelector('#replace-wireframes-button').addEventListener('click', () => {
174 |             this.assetReplacementManager.replaceModel('wireframe');
175 |         });
176 |         modal.querySelector('#replace-aliens-button').addEventListener('click', () => {
177 |             this.assetReplacementManager.replaceModel('alien');
178 |         });
179 |     }
180 | 
181 |     applyShadowQuality(quality) {
182 |         if (!this.renderer || !this.dirLight) return;
183 |         
184 |         switch(quality) {
185 |             case 'high':
186 |                 this.renderer.shadowMap.enabled = true;
187 |                 this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
188 |                 this.dirLight.castShadow = true;
189 |                 this.dirLight.shadow.mapSize.width = 2048;
190 |                 this.dirLight.shadow.mapSize.height = 2048;
191 |                 this.dirLight.shadow.radius = 2.0;
192 |                 break;
193 |             case 'medium':
194 |                 this.renderer.shadowMap.enabled = true;
195 |                 this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
196 |                 this.dirLight.castShadow = true;
197 |                 this.dirLight.shadow.mapSize.width = 1024;
198 |                 this.dirLight.shadow.mapSize.height = 1024;
199 |                 this.dirLight.shadow.radius = 1.5;
200 |                 break;
201 |             case 'low':
202 |                 this.renderer.shadowMap.enabled = true;
203 |                 this.renderer.shadowMap.type = THREE.PCFShadowMap;
204 |                 this.dirLight.castShadow = true;
205 |                 this.dirLight.shadow.mapSize.width = 512;
206 |                 this.dirLight.shadow.mapSize.height = 512;
207 |                 break;
208 |             case 'off':
209 |                 this.renderer.shadowMap.enabled = false;
210 |                 this.dirLight.castShadow = false;
211 |                 break;
212 |         }
213 |         // Force materials to update
214 |         this.scene.traverse(obj => {
215 |             if(obj.material) {
216 |                 obj.material.needsUpdate = true;
217 |             }
218 |         });
219 |     }
220 | }


--------------------------------------------------------------------------------

