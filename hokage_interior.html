<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Konoha — Hokage Office (React + Three.js)</title>
  <link rel="icon" href="data:," />
  <style>
    html, body { height:100%; margin:0; background:#0d0f12; color:#e8eaed; font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, sans-serif; }
    #root { height:100%; }
    canvas { display:block; }
    .ui {
      position: fixed; left: 12px; top: 12px; z-index: 6;
      backdrop-filter: blur(6px);
      background: rgba(6,8,10,.55); border: 1px solid rgba(255,255,255,.08); border-radius: 12px;
      padding: 10px 12px; max-width: 360px; box-shadow: 0 8px 24px rgba(0,0,0,.35);
    }
    .ui h1 { margin: 0 0 6px; font-size: 13px; font-weight: 700; letter-spacing: .3px; text-transform: uppercase; color:#bcd2ff }
    .ui .hint { font-size: 12px; color:#cfd3da; opacity:.92 }
    .ui .kbd { background:#161b22; border:1px solid #2a2f36; border-bottom-color:#232831; border-radius:6px; padding:1px 6px; font:600 11px/16px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace }
    .gate {
      position: fixed; inset: 0; display: grid; place-items: center; z-index: 7;
      background: radial-gradient(1200px 600px at 50% 120%, rgba(255,223,120,.12), transparent 60%), #0b0d10;
    }
    .card {
      width: min(92vw, 580px); padding: 20px 22px; border-radius: 16px;
      background: linear-gradient(180deg, rgba(20,24,29,.85), rgba(14,17,21,.85));
      border: 1px solid rgba(255,255,255,.08);
      box-shadow: 0 18px 60px rgba(0,0,0,.55);
      text-align: center;
    }
    .card h2 { margin: 0 0 8px; font-size: 18px; letter-spacing:.2px }
    .card p { margin: 0 0 14px; color:#cfd3da }
    .btn {
      appearance: none; cursor: pointer; user-select: none;
      border:1px solid #2f80ff; color:#e9f2ff; background:#2f80ff;
      padding: 10px 14px; font-weight: 700; border-radius: 12px;
      box-shadow: 0 8px 20px rgba(47,128,255,.35);
    }
    .crosshair {
      position: fixed; left: 50%; top: 50%; transform: translate(-50%,-50%); z-index: 5;
      width: 8px; height: 8px; border-radius: 50%;
      background: radial-gradient(circle, #ffffff, #ffffff 30%, rgba(255,255,255,.0) 60%);
      opacity: .35; pointer-events:none;
    }
    .credit {
      position: fixed; right: 10px; bottom: 8px; z-index: 6; opacity:.7; font-size: 11px;
    }
    .credit a { color:#8fb3ff; text-decoration: none; border-bottom: 1px dotted #8fb3ff; }
  </style>
</head>
<body>
  <div id="root"></div>

  <!-- React (UMD) -->
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

  <!-- Import map so three/examples can import "three" as a bare specifier -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
    }
  }
  </script>

  <!-- App (ESM) -->
  <script type="module">
    import * as THREE from "https://unpkg.com/three@0.160.0/build/three.module.js";
  import { PointerLockControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/PointerLockControls.js";
    import { OrbitControls } from "https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js";

    const { useEffect, useRef, useState } = React;

    function App(){
      const mountRef = useRef(null);
      const controlsRef = useRef(null);
      const [locked, setLocked] = useState(false);

      useEffect(() => {
        const container = mountRef.current;

        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        // Scene & Camera
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xCFE7FF); // soft sky
        const camera = new THREE.PerspectiveCamera(70, container.clientWidth/container.clientHeight, 0.1, 1000);
        camera.position.set(0, 1.72, 0); // eye height; we'll spawn near room center

        // Controls (Pointer Lock)
        const controls = new PointerLockControls(camera, renderer.domElement);
        controlsRef.current = controls;
        controls.addEventListener('lock', () => setLocked(true));
        controls.addEventListener('unlock', () => setLocked(false));

        // Lighting
        const hemi = new THREE.HemisphereLight(0xe8f2ff, 0x22282f, 0.85);
        scene.add(hemi);

        const sun = new THREE.DirectionalLight(0xfff1c4, 0.85);
        sun.position.set(8, 10, -4);
        sun.castShadow = true;
        sun.shadow.mapSize.set(2048, 2048);
        scene.add(sun);

        // Floor (polished concrete look via procedural canvas)
        const floorTex = new THREE.CanvasTexture(makeConcrete(1024));
        floorTex.wrapS = floorTex.wrapT = THREE.RepeatWrapping;
        floorTex.repeat.set(2.5, 2.5);

        const floor = new THREE.Mesh(
          new THREE.CylinderGeometry(7.0, 7.0, 0.06, 64),
          new THREE.MeshStandardMaterial({ color: 0x868B8E, map: floorTex, roughness: 0.85, metalness: 0.05 })
        );
        floor.receiveShadow = true;
        floor.position.y = -0.03;
        scene.add(floor);

        // Ceiling
        const ceiling = new THREE.Mesh(
          new THREE.CylinderGeometry(7.0, 7.0, 0.08, 64),
          new THREE.MeshStandardMaterial({ color: 0xD8D0B4, roughness: 1.0, metalness: 0.0 })
        );
        ceiling.position.y = 3.1;
        scene.add(ceiling);

        // Walls segmented with windows
        buildWalls(scene);

        // Central desk (elliptical)
        const desk = buildDesk();
        // Place desk toward the windows (front)
        desk.position.set(0, 0, -1.6);
        scene.add(desk);

        // Book stacks & props
        const props = buildProps();
        desk.add(props);

        // Outside skyline (simple diorama so the windows look alive)
        const skyline = buildSkyline();
        skyline.position.y = 0;
        scene.add(skyline);

        // --- Player movement (WASD + run) ---
        const state = {
          keys: { forward:false, back:false, left:false, right:false, run:false },
          velocity: new THREE.Vector3(),
          speed: 3.2,   // m/s walk
          runMul: 1.8,
          roomRadius: 6.6,
          deskPos: new THREE.Vector2(desk.position.x, desk.position.z),
          deskRadius: 2.6, // simple collision radius around desk
          tmp: new THREE.Vector3()
        };

        function onKey(e, down){
          switch(e.code){
            case 'KeyW': state.keys.forward = down; break;
            case 'KeyS': state.keys.back = down; break;
            case 'KeyA': state.keys.left = down; break;
            case 'KeyD': state.keys.right = down; break;
            case 'ShiftLeft': case 'ShiftRight': state.keys.run = down; break;
          }
        }
        window.addEventListener('keydown', e => onKey(e, true));
        window.addEventListener('keyup', e => onKey(e, false));

        // Resize
        function onResize(){
          const w = container.clientWidth, h = container.clientHeight;
          camera.aspect = w/h; camera.updateProjectionMatrix();
          renderer.setSize(w, h);
        }
        window.addEventListener('resize', onResize);

        // Animation loop
        const clock = new THREE.Clock();
        let rafId = 0;

        function animate(){
          rafId = requestAnimationFrame(animate);

          const dt = Math.min(clock.getDelta(), 0.033);

          // movement only when pointer locked
          if (controls.isLocked){
            const accel = state.speed * (state.keys.run ? state.runMul : 1.0);
            // local axes
            const dir = new THREE.Vector3();
            if (state.keys.forward) dir.z -= 1;
            if (state.keys.back) dir.z += 1;
            if (state.keys.left) dir.x -= 1;
            if (state.keys.right) dir.x += 1;
            if (dir.lengthSq() > 0) dir.normalize();

            // convert to world space relative to camera yaw (ignore pitch)
            const yaw = camera.rotation.y;
            const forward = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw));
            const right = new THREE.Vector3(forward.z, 0, -forward.x);
            const wish = new THREE.Vector3()
              .addScaledVector(forward, dir.z)
              .addScaledVector(right, dir.x)
              .normalize();

            // velocity integrate with damping
            const damping = Math.pow(0.001, dt); // exp damping ~ strong stop when no input
            state.velocity.multiplyScalar(damping);
            if (dir.lengthSq() > 0){
              state.velocity.addScaledVector(wish, accel * dt);
            }

            // candidate move
            state.tmp.copy(camera.position).addScaledVector(state.velocity, dt);

            // keep eye at fixed height and within cylinder room
            state.tmp.y = 1.72;

            // wall collision (keep within slightly smaller radius)
            const r = Math.hypot(state.tmp.x, state.tmp.z);
            const maxR = state.roomRadius - 0.25;
            if (r > maxR){
              // push back along normal
              const nx = state.tmp.x / r, nz = state.tmp.z / r;
              state.tmp.x = nx * maxR;
              state.tmp.z = nz * maxR;
              // slide tangentially a bit
              state.velocity.addScaledVector(new THREE.Vector3(-nx, 0, -nz), -state.velocity.dot(new THREE.Vector3(nx,0,nz)));
            }

            // desk collision — simple circle keep-out
            const dx = state.tmp.x - state.deskPos.x;
            const dz = state.tmp.z - state.deskPos.y;
            const d2 = dx*dx + dz*dz;
            const keepOut = state.deskRadius + 0.35;
            if (d2 < keepOut*keepOut){
              const d = Math.sqrt(d2) || 0.0001;
              const nx = dx / d, nz = dz / d;
              state.tmp.x = state.deskPos.x + nx * keepOut;
              state.tmp.z = state.deskPos.y + nz * keepOut;
              // reflect velocity away from desk
              const n = new THREE.Vector3(nx,0,nz);
              state.velocity.addScaledVector(n, -state.velocity.dot(n));
            }

            camera.position.copy(state.tmp);
          }

          renderer.render(scene, camera);
        }
        animate();

        // Helpers: build geometry
        function buildWalls(scene){
          const radius = 6.9, height = 3.0, segments = 14;
          const group = new THREE.Group();

          // materials
          const wood = new THREE.MeshStandardMaterial({ color: 0xC79A62, metalness: 0.05, roughness: 0.75 });
          const mullion = new THREE.MeshStandardMaterial({ color: 0xB98B56, metalness: 0.1, roughness: 0.6 });
          const glassMat = new THREE.MeshPhysicalMaterial({ color: 0xFFFFFF, transmission: 0.9, opacity: 1, transparent: true, roughness: 0.1, thickness: 0.05, ior: 1.2 });

          // ring of panels (window-window-wall pattern)
          for (let i=0;i<segments;i++){
            const theta0 = (i/segments) * Math.PI*2;
            const theta1 = ((i+1)/segments) * Math.PI*2;
            const theta = (theta0+theta1)/2;

            const isWindow = (i % 2 === 0) || (i === Math.floor(segments/2)); // lots of windows
            const panelWidth = 2 * Math.sin((theta1-theta0)/2) * radius;

            // base wood column
            const col = new THREE.Mesh(
              new THREE.BoxGeometry(0.16, height, 0.6),
              mullion
            );
            col.position.set(Math.sin(theta0)*radius, height/2-0.02, Math.cos(theta0)*radius);
            col.lookAt(0,col.position.y,0);
            group.add(col);

            // next column
            const col2 = col.clone();
            col2.position.set(Math.sin(theta1)*radius, height/2-0.02, Math.cos(theta1)*radius);
            group.add(col2);

            // top & bottom rails
            const railTop = new THREE.Mesh(new THREE.BoxGeometry(panelWidth-0.22, 0.16, 0.5), mullion);
            railTop.position.set(Math.sin(theta)*radius, height-0.08, Math.cos(theta)*radius);
            railTop.lookAt(0,railTop.position.y,0);
            group.add(railTop);

            const sill = railTop.clone();
            sill.position.y = 0.9;
            group.add(sill);

            // panel infill
            if (isWindow){
              const plane = new THREE.Mesh(new THREE.PlaneGeometry(panelWidth-0.28, height-1.06), glassMat);
              plane.position.set(Math.sin(theta)*radius, (height-0.9)/2+0.9, Math.cos(theta)*radius);
              plane.lookAt(0,plane.position.y,0);
              group.add(plane);
            } else {
              const wall = new THREE.Mesh(new THREE.BoxGeometry(panelWidth-0.24, height-1.06, 0.45), wood);
              wall.position.set(Math.sin(theta)*radius, (height-0.9)/2+0.9, Math.cos(theta)*radius);
              wall.lookAt(0,wall.position.y,0);
              wall.castShadow = true; wall.receiveShadow = true;
              group.add(wall);
            }
          }

          scene.add(group);
        }

        function buildDesk(){
          const g = new THREE.Group();

          // Base (scaled cylinder -> elliptical footprint)
          const base = new THREE.Mesh(
            new THREE.CylinderGeometry(2.2, 2.2, 1.0, 48, 1, true),
            new THREE.MeshStandardMaterial({ color: 0xD6B88A, metalness: 0.06, roughness: 0.65 })
          );
          base.scale.z = 0.62;
          base.position.y = 0.5;
          base.castShadow = true; base.receiveShadow = true;
          g.add(base);

          // Top
          const top = new THREE.Mesh(
            new THREE.CylinderGeometry(2.3, 2.3, 0.08, 48),
            new THREE.MeshStandardMaterial({ color: 0xE6D1A9, metalness: 0.04, roughness: 0.55 })
          );
          top.scale.z = 0.62;
          top.position.y = 1.04;
          top.castShadow = true; top.receiveShadow = true;
          g.add(top);

          // “Hokage emblem” front panel (procedural texture)
          const panelTex = new THREE.CanvasTexture(makeHokagePanel(512, 256));
          const panel = new THREE.Mesh(
            new THREE.PlaneGeometry(1.8, 0.9),
            new THREE.MeshStandardMaterial({ map: panelTex, metalness: 0.0, roughness: 0.95 })
          );
          panel.position.set(0, 0.65, 1.35);
          panel.rotation.y = Math.PI; // faces player when desk is at z<0
          panel.castShadow = true;
          g.add(panel);

          // Chair (simple)
          const seat = new THREE.Mesh(
            new THREE.BoxGeometry(0.7, 0.08, 0.6),
            new THREE.MeshStandardMaterial({ color: 0x9DC7B8, roughness: 0.8 })
          );
          seat.position.set(0, 0.62, -0.25);
          seat.castShadow = true; seat.receiveShadow = true;
          g.add(seat);

          const back = new THREE.Mesh(
            new THREE.BoxGeometry(0.7, 0.9, 0.08),
            new THREE.MeshStandardMaterial({ color: 0x9DC7B8, roughness: 0.8 })
          );
          back.position.set(0, 1.08, -0.55);
          back.castShadow = true; back.receiveShadow = true;
          g.add(back);

          return g;
        }

        function buildProps(){
          const grp = new THREE.Group();

          // books
          function book(w,h,d,color){
            const m = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), new THREE.MeshStandardMaterial({ color, roughness:.9, metalness:.02 }));
            m.castShadow = true; m.receiveShadow = true; return m;
          }
          const colors = [0xc73f3f,0x3f7fc7,0xf2a65a,0x68a357,0x8e6cc6,0xf0c808,0x444f77];
          function stack(x,z, n=5){
            let y = 1.08; // desk top
            for (let i=0;i<n;i++){
              const w = 0.22+Math.random()*0.08, h = 0.035+Math.random()*0.01, d = 0.3+Math.random()*0.06;
              const b = book(w,h,d, colors[Math.floor(Math.random()*colors.length)]);
              b.position.set(x + (Math.random()*0.06-0.03), y + h/2 + i*(h+0.008), z + (Math.random()*0.06-0.03));
              grp.add(b);
            }
          }
          stack(-0.9, 0.25, 6);
          stack(0.95, 0.2, 5);
          stack(1.0, -0.3, 4);

          // scrolls
          function scroll(x,z){
            const body = new THREE.Mesh(new THREE.CylinderGeometry(0.04,0.04,0.35,16),
              new THREE.MeshStandardMaterial({ color: 0xEEE7D6, roughness: .85 }));
            body.rotation.z = Math.PI/2;
            body.position.set(x, 1.10, z);
            body.castShadow = true;
            const cap1 = new THREE.Mesh(new THREE.CylinderGeometry(0.045,0.045,0.02,12),
              new THREE.MeshStandardMaterial({ color: 0x403832, roughness:.6 }));
            cap1.position.set(x-0.18,1.10,z);
            cap1.rotation.z = Math.PI/2;
            cap1.castShadow = true;
            const cap2 = cap1.clone(); cap2.position.x = x+0.18;
            grp.add(body, cap1, cap2);
          }
          scroll(-0.2, 0.4);
          scroll(0.35, 0.15);

          // ink bottle
          const ink = new THREE.Mesh(new THREE.CylinderGeometry(0.06,0.08,0.1,18),
            new THREE.MeshStandardMaterial({ color:0x1a1a1a, roughness:.4, metalness:.1 }));
          ink.position.set(-0.25, 1.12, 0.05); ink.castShadow = true; grp.add(ink);

          return grp;
        }

        function buildSkyline(){
          const grp = new THREE.Group();

          // distant ground disk
          const ground = new THREE.Mesh(
            new THREE.CylinderGeometry(60,60,0.02,64),
            new THREE.MeshStandardMaterial({ color:0xd7e8c5, roughness:.95 })
          );
          ground.position.y = -0.02; ground.receiveShadow = true; grp.add(ground);

          // low hills
          const hillMat = new THREE.MeshStandardMaterial({ color:0x94b29b, roughness:1.0 });
          for (let i=0;i<8;i++){
            const r = 25 + Math.random()*12;
            const a = (i/8)*Math.PI*2 + Math.random()*0.2;
            const hill = new THREE.Mesh(new THREE.SphereGeometry(6+Math.random()*3, 24, 16), hillMat);
            hill.scale.set(1.8,0.6,1.8);
            hill.position.set(Math.sin(a)*r, 2.2, Math.cos(a)*r);
            grp.add(hill);
          }

          // stubby buildings (leaf village vibe)
          const bMat = new THREE.MeshStandardMaterial({ color:0xE7D7A3, roughness:.9 });
          for (let i=0;i<14;i++){
            const r = 18 + Math.random()*16;
            const a = (i/14)*Math.PI*2 + Math.random()*0.15;
            const h = 2 + Math.random()*2.5;
            const cyl = new THREE.Mesh(new THREE.CylinderGeometry(1.2,1.2,h,24), bMat);
            cyl.position.set(Math.sin(a)*r, h/2, Math.cos(a)*r);
            grp.add(cyl);

            // simple cap
            const cap = new THREE.Mesh(new THREE.CylinderGeometry(1.25,1.25,0.25,24),
              new THREE.MeshStandardMaterial({ color:0xC7B483, roughness:.9 }));
            cap.position.set(cyl.position.x, h+0.12, cyl.position.z);
            grp.add(cap);
          }
          return grp;
        }

        // --- textures (procedural) ---
        function makeConcrete(size){
          const c = document.createElement('canvas'); c.width=c.height=size;
          const ctx = c.getContext('2d');
          ctx.fillStyle = '#9AA0A5'; ctx.fillRect(0,0,size,size);
          for(let i=0;i<1200;i++){
            const x = Math.random()*size, y = Math.random()*size, r = Math.random()*2+0.2;
            const a = Math.random()*0.08;
            ctx.fillStyle = `rgba(40,45,50,${a})`;
            ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
          }
          // subtle radial sheen
          const grad = ctx.createRadialGradient(size*.52, size*.52, size*.1, size*.5, size*.5, size*.7);
          grad.addColorStop(0,'rgba(255,255,255,.06)');
          grad.addColorStop(1,'rgba(255,255,255,0)');
          ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(size*.5,size*.5,size*.7,0,Math.PI*2); ctx.fill();
          return c;
        }

        function makeHokagePanel(w,h){
          const c = document.createElement('canvas'); c.width=w; c.height=h;
          const ctx = c.getContext('2d');
          // wood base
          const grd = ctx.createLinearGradient(0,0,0,h);
          grd.addColorStop(0,'#E3CBA1'); grd.addColorStop(.5,'#D6B88A'); grd.addColorStop(1,'#C9A774');
          ctx.fillStyle = grd; ctx.fillRect(0,0,w,h);

          // Konoha swirl (stylized)
          ctx.save();
          ctx.translate(w*0.52, h*0.55);
          ctx.rotate(-0.02);
          ctx.lineWidth = Math.max(10, w*0.02);
          ctx.strokeStyle = '#C9412E';
          ctx.beginPath();
          // spiral
          const turns = 1.2;
          for (let a=0; a<Math.PI*2*turns; a+=0.05){
            const r = 34 + a*10;
            ctx.lineTo(Math.cos(a)*r, Math.sin(a)*r);
          }
          // tail
          ctx.lineTo(120, -8);
          ctx.stroke();
          ctx.restore();

          // Kanji-like brush marks (implied, not literal)
          ctx.globalAlpha = .9;
          ctx.strokeStyle = '#2a2a2a';
          ctx.lineWidth = 8; ctx.lineCap = 'round';
          ctx.beginPath(); ctx.moveTo(w*0.18, h*0.28); ctx.lineTo(w*0.18, h*0.74); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(w*0.18, h*0.28); ctx.lineTo(w*0.30, h*0.34); ctx.stroke();
          ctx.beginPath(); ctx.moveTo(w*0.28, h*0.52); ctx.lineTo(w*0.42, h*0.60); ctx.stroke();

          // grime/speckles
          for (let i=0;i<240;i++){
            const x = Math.random()*w, y = Math.random()*h, a=.08+Math.random()*.08;
            ctx.fillStyle = `rgba(0,0,0,${a})`; ctx.fillRect(x,y,1,1);
          }
          return c;
        }

        // Cleanup
        return () => {
          cancelAnimationFrame(rafId);
          window.removeEventListener('resize', onResize);
          renderer.dispose();
          container.removeChild(renderer.domElement);
        };
      }, []);

      return React.createElement(
        React.Fragment,
        null,
        React.createElement('div', { className:'ui' },
          React.createElement('h1', null, 'Hokage Office — Walkable Demo'),
          React.createElement('div', { className:'hint' },
            'Controls: ',
            React.createElement('span', { className:'kbd' }, 'W'),
            ' ',
            React.createElement('span', { className:'kbd' }, 'A'),
            ' ',
            React.createElement('span', { className:'kbd' }, 'S'),
            ' ',
            React.createElement('span', { className:'kbd' }, 'D'),
            ' to move, ',
            React.createElement('span', { className:'kbd' }, 'Shift'),
            ' to run, mouse to look. Stay inside the office—desk has collision.'
          )
        ),
        !locked && React.createElement('div', { className:'gate' },
          React.createElement('div', { className:'card' },
            React.createElement('h2', null, 'Enter the Hokage’s Office'),
            React.createElement('p', null, 'Click below to lock the cursor and start walking.'),
            React.createElement('button', {
              className:'btn',
              onClick: () => { if (controlsRef.current) controlsRef.current.lock(); }
            }, 'Enter Office')
          )
        ),
        locked && React.createElement('div', { className:'crosshair' }),
        React.createElement('div', { ref: mountRef, style:{ position:'absolute', inset:0 } }),
        React.createElement('div', { className:'credit' }, '© fan scene. Keyboard/mouse only. ')
      );
    }

    ReactDOM.createRoot(document.getElementById('root')).render(React.createElement(App));
  </script>
</body>
</html>