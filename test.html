<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Exam Arena — Connected Shingled Dome</title>
<style>
  html,body{margin:0;height:100%;background:#0e0e0e}
  canvas{display:block}
  #ui{position:fixed;left:12px;top:12px;color:#e7e7e7;background:rgba(0,0,0,.55);
      border:1px solid #333;border-radius:10px;padding:10px 12px;font:12px system-ui;backdrop-filter:blur(4px)}
</style>
<script type="importmap">
{
  "imports":{
    "three":"https://unpkg.com/three@0.160.0/build/three.module.js",
    "three/examples/jsm/controls/OrbitControls.js":"https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js"
  }
}
</script>
</head>
<body>
<div id="ui"><b>Controls</b> drag=orbit • wheel=zoom • right-drag=pan</div>

<script type="module">
import * as THREE from "three";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";

/* =========================
   CONFIG
   ========================= */
const CFG = {
  arena: {
    radius: 185,
    wall: { radius: 214, height: 92, thickness: 8, color: 0x7d7d7d, cap: 0xb6b6b6 },
    floor: { color: 0xbf9968, patch: 0x9b815a }
  },
  roof: {
    innerR: 225,     // near wall
    outerR: 288,     // base of dome
    height: 138,     // crest height above base
    tileW: 3.2,      // around-the-ring width
    tileD: 3.0,      // downslope depth (row pitch)
    tileH: 1.0,      // thickness
    overlap: 0.45,   // 0..1, how much each row overlaps the previous
    colorA: 0xb54b2f,
    colorB: 0x9a3f26,
    ridgeColor: 0xddddde
  },
  pagodas: { count: 3, arcDeg: 78, baseRadius: 352, floors: 4, w: 78, d: 64, roof: 0xb88a2d, horn: 0x7a4011 },
  trees: { count: 28, trunk: 0x5e3d2a, canopy: 0x2e6b3b }
};

/* =========================
   SCENE
   ========================= */
const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x8fcaf0);

const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 8000);
camera.position.set(560, 390, 560);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.minDistance = 200;
controls.maxDistance = 2400;
controls.maxPolarAngle = Math.PI*0.495;

// lights
scene.add(new THREE.HemisphereLight(0xffffff, 0x667788, 0.7));
const sun = new THREE.DirectionalLight(0xffffff, 1.1);
sun.position.set(-640, 900, 520);
sun.castShadow = true;
sun.shadow.mapSize.set(2048,2048);
Object.assign(sun.shadow.camera,{left:-1600,right:1600,top:1600,bottom:-1600,far:4000});
scene.add(sun);

// ground
{
  const ground = new THREE.Mesh(
    new THREE.CylinderGeometry(1400,1400,4,160),
    new THREE.MeshStandardMaterial({ color:0xCDBB8C, roughness:0.95 })
  );
  ground.position.y = -2;
  ground.receiveShadow = true;
  scene.add(ground);
}

/* =========================
   MATERIALS
   ========================= */
const mWall   = new THREE.MeshStandardMaterial({
  color: CFG.arena.wall.color,
  roughness: 0.9,
  side: THREE.DoubleSide          // ← see grey from both sides
});
const mWallCap= new THREE.MeshStandardMaterial({ color: CFG.arena.wall.cap, roughness:0.6, metalness:0.05 });
const mFloor  = new THREE.MeshStandardMaterial({ color: CFG.arena.floor.color, roughness:0.95 });
const mPatch  = new THREE.MeshStandardMaterial({ color: CFG.arena.floor.patch, roughness:0.95 });

const mTileA  = new THREE.MeshStandardMaterial({ color: CFG.roof.colorA, roughness:0.55, metalness:0.08 });
const mTileB  = new THREE.MeshStandardMaterial({ color: CFG.roof.colorB, roughness:0.55, metalness:0.08 });
const mRidge  = new THREE.MeshStandardMaterial({ color: CFG.roof.ridgeColor, roughness:0.35, metalness:0.12 });

const mPlaster= new THREE.MeshStandardMaterial({ color: 0xECE8E3, roughness:0.85 });
const mRoof   = new THREE.MeshStandardMaterial({ color: CFG.pagodas.roof, roughness:0.55, metalness:0.1 });
const mHorn   = new THREE.MeshStandardMaterial({ color: CFG.pagodas.horn, roughness:0.6 });
const trunkM  = new THREE.MeshStandardMaterial({ color: CFG.trees.trunk, roughness:0.9 });
const canopyM = new THREE.MeshStandardMaterial({ color: CFG.trees.canopy, roughness:0.8 });

/* =========================
   BUILDERS
   ========================= */
function buildArenaFloor(){
  const g = new THREE.Group();
  const r = CFG.arena.radius;
  const floor = new THREE.Mesh(new THREE.CylinderGeometry(r, r, 1.8, 96), mFloor);
  floor.receiveShadow = true;
  g.add(floor);

  const rng = mulberry32(101);
  for (let i=0;i<28;i++){
    const rr = 5 + rng()*20;
    const patch = new THREE.Mesh(new THREE.CylinderGeometry(rr,rr,0.9,24), mPatch);
    const a = rng()*Math.PI*2;
    const rad = (r-20)*Math.sqrt(rng());
    patch.position.set(Math.cos(a)*rad, 0.9, Math.sin(a)*rad);
    patch.rotation.y = rng()*Math.PI*2;
    patch.receiveShadow = true;
    g.add(patch);
  }
  scene.add(g);
}

function buildInnerWallAndGate(){
  const { radius, height, thickness } = CFG.arena.wall;

  // Choose segments and align faces so +Z is centered
  const segs = 192;
  const thetaStart = Math.PI/2 + (Math.PI*2) / (segs*2); // face centered at +Z

  // Outer & inner cylindrical shells (double-sided material)
  const outerGeo = new THREE.CylinderGeometry(
    radius + thickness, radius + thickness, height,
    segs, 1, true, thetaStart, Math.PI*2
  );
  const innerGeo = new THREE.CylinderGeometry(
    radius, radius, height,
    segs, 1, true, thetaStart, Math.PI*2
  );

  const outer = new THREE.Mesh(outerGeo, mWall);
  const inner = new THREE.Mesh(innerGeo, mWall);
  outer.position.y = inner.position.y = height/2;
  outer.castShadow = inner.castShadow = true;
  outer.receiveShadow = inner.receiveShadow = true;
  scene.add(outer, inner);

  // Simple gate + stairs at +Z (unchanged)
  const gateW = 34, rise = 1.2, run = 3.0;
  const steps = new THREE.Group();
  for (let i = 0; i < 9; i++) {
    const s = new THREE.Mesh(new THREE.BoxGeometry(gateW*0.9 - i*0.8, rise, run), mWallCap);
    s.position.set(0, rise/2 + i*rise, radius + 6 + (i+0.5)*run);
    s.castShadow = s.receiveShadow = true;
    steps.add(s);
  }
  scene.add(steps);
}

/* -------------------------
   ROOF SURFACE + SHINGLES
   ------------------------- */

// profile along downslope (u: 0 crest -> 1 base)
function roofProfile(u){
  const { innerR, outerR, height } = CFG.roof;
  // easing to get a shoulder near base
  const e = easeInOut(1 - u, 1.6); // 1 at crest
  const r = innerR + (outerR - innerR) * u;
  const y = height * e*e;
  return { r, y };
}
function roofProfileDeriv(u){
  const { outerR, innerR, height } = CFG.roof;
  const drdu = (outerR - innerR);
  const e = 1 - u; const k = 1.6;
  const dydu = height * 2*k * Math.pow(e, 2*k - 1) * (-1);
  return { drdu, dydu };
}

// invisible analytical surface for normals
function makeRoofSurface(){
  const segU = 64, segV = 180;
  const geo = new THREE.BufferGeometry();
  const verts = [], norms = [], idx = [];
  for(let i=0;i<=segU;i++){
    const u = i/segU;
    const { r, y } = roofProfile(u);
    const { drdu, dydu } = roofProfileDeriv(u);
    for(let j=0;j<=segV;j++){
      const v = (j/segV)*Math.PI*2;
      const x = Math.cos(v)*r, z = Math.sin(v)*r;
      verts.push(x, y, z);
      const pu = new THREE.Vector3(Math.cos(v)*drdu, dydu, Math.sin(v)*drdu);
      const pv = new THREE.Vector3(-Math.sin(v)*r, 0, Math.cos(v)*r);
      const n = pv.clone().cross(pu).normalize();
      norms.push(n.x, n.y, n.z);
    }
  }
  const row = segV+1;
  for(let i=0;i<segU;i++){
    for(let j=0;j<segV;j++){
      const a = i*row + j, b = a+1, c = (i+1)*row + j, d = c+1;
      idx.push(a,c,b, b,c,d);
    }
  }
  geo.setAttribute('position', new THREE.Float32BufferAttribute(verts,3));
  geo.setAttribute('normal',  new THREE.Float32BufferAttribute(norms,3));
  geo.setIndex(idx);
  const m = new THREE.MeshStandardMaterial({ color:0x5a2b19, roughness:1, transparent:true, opacity:0 });
  const mesh = new THREE.Mesh(geo,m);
  mesh.position.y = CFG.arena.wall.height*0.18;
  mesh.updateMatrixWorld(true);
  return mesh;
}

// visible underlayment shell so the dome looks solid
function buildRoofUnderlayer({uSeg=72, vSeg=240, offset=-0.45, thick=0.75} = {}) {
  const pos = [], nor = [], idx = [];
  for (let i=0;i<=uSeg;i++){
    const u = i/uSeg;
    const { r, y } = roofProfile(u);
    const { drdu, dydu } = roofProfileDeriv(u);
    for (let j=0;j<=vSeg;j++){
      const v = (j/vSeg)*Math.PI*2;
      const pv = new THREE.Vector3(-Math.sin(v)*r, 0, Math.cos(v)*r);
      const pu = new THREE.Vector3(Math.cos(v)*drdu, dydu, Math.sin(v)*drdu);
      const n  = pv.clone().cross(pu).normalize();

      const base = new THREE.Vector3(Math.cos(v)*r, y, Math.sin(v)*r);
      const p0 = base.clone().addScaledVector(n, offset);
      const p1 = base.clone().addScaledVector(n, offset+thick);

      pos.push(p0.x,p0.y,p0.z, p1.x,p1.y,p1.z);
      nor.push(n.x,n.y,n.z,    n.x,n.y,n.z);
    }
  }
  const row = (vSeg+1)*2;
  for (let i=0;i<uSeg;i++){
    for (let j=0;j<vSeg;j++){
      const a = i*row + j*2;
      const b = a + 2;
      const c = a + row;
      const d = c + 2;
      idx.push(a,c,b, b,c,d);
    }
  }
  const geo = new THREE.BufferGeometry();
  geo.setAttribute('position', new THREE.Float32BufferAttribute(pos,3));
  geo.setAttribute('normal',   new THREE.Float32BufferAttribute(nor,3));
  geo.setIndex(idx);
  geo.computeVertexNormals();

  const underMat = new THREE.MeshStandardMaterial({ color: 0x8f3822, roughness:0.65, metalness:0.06 });
  const mesh = new THREE.Mesh(geo, underMat);
  mesh.position.y = CFG.arena.wall.height*0.18;
  mesh.castShadow = mesh.receiveShadow = true;
  scene.add(mesh);
}

function buildShingledDome(){
  // 0) Visible underlayment so the dome reads as one solid piece
  buildRoofUnderlayer({ uSeg: 72, vSeg: 240, offset: -0.45, thick: 0.75 });

  // 1) Invisible analytical surface for normals/orientation
  const surface = makeRoofSurface();
  scene.add(surface);

  const { tileW, tileD, tileH, overlap } = CFG.roof;
  const rowPitch = tileD * (1 - overlap);
  const rows = Math.max(18, Math.floor((CFG.roof.outerR - CFG.roof.innerR) / rowPitch));

  // Shingle geometry; we scale per instance so rings/rows have no gaps
  const tileGeo = new THREE.BoxGeometry(tileW, tileH, tileD);
  const instA = new THREE.InstancedMesh(tileGeo, mTileA, 200000);
  const instB = new THREE.InstancedMesh(tileGeo, mTileB, 200000);
  instA.count = 0; instB.count = 0;
  instA.castShadow = instB.castShadow = true;
  instA.receiveShadow = instB.receiveShadow = true;

  const pos = new THREE.Vector3(), nrm = new THREE.Vector3();
  const pu  = new THREE.Vector3(), pv  = new THREE.Vector3();
  const tD  = new THREE.Vector3(), tS  = new THREE.Vector3();
  const basis = new THREE.Matrix4(), m = new THREE.Matrix4(), q = new THREE.Quaternion(), s = new THREE.Vector3();

  for (let ri = 0; ri < rows; ri++){
    const u = ri / (rows - 1);
    const { r, y }       = roofProfile(u);
    const { drdu, dydu } = roofProfileDeriv(u);

    // Exact circumferential fit → no side gaps
    const circ = 2 * Math.PI * r;
    const cols = Math.max(8, Math.ceil(circ / (tileW * 0.98)));
    const arcW = circ / cols;
    const scaleX = arcW / tileW;

    // Exact downslope fit → no row gaps
    const nextU = Math.min(1, (ri + 1) / (rows - 1));
    const { r: r2, y: y2 } = roofProfile(nextU);
    const downDist = Math.hypot(r2 - r, y - y2);
    const scaleZ = (downDist || rowPitch) / tileD * 1.02; // tiny overfill to hide seams

    const vStep   = (2 * Math.PI) / cols;
    const vOffset = (ri & 1) ? vStep * 0.5 : 0;           // stagger rows

    for (let ci = 0; ci < cols; ci++){
      const v = ci * vStep + vOffset;

      pos.set(Math.cos(v) * r, y, Math.sin(v) * r);

      pu.set(Math.cos(v) * drdu, dydu, Math.sin(v) * drdu); // downslope tangent
      pv.set(-Math.sin(v) * r, 0, Math.cos(v) * r);         // around tangent
      nrm.copy(pv).cross(pu).normalize();                   // outward normal

      tD.copy(pu).normalize().multiplyScalar(-1);  // local +Z = downslope
      tS.copy(pv).normalize();                     // local +X = around ring

      basis.makeBasis(tS, nrm, tD);
      q.setFromRotationMatrix(basis);

      const lifted = pos.clone().addScaledVector(nrm, 0.45);
      s.set(scaleX, 1, scaleZ);
      m.compose(lifted, q, s);

      const inst = ((ri + ci) & 1) ? instA : instB;
      inst.setMatrixAt(inst.count++, m);
    }
  }
  instA.instanceMatrix.needsUpdate = true;
  instB.instanceMatrix.needsUpdate = true;
  scene.add(instA, instB);

  // 2) Ridge caps — centered & visible from BOTH sides of the crest
  {
    const crestU = 0.06;                                 // near the crest
    const { r: rCrest, y: yCrest } = roofProfile(crestU);
    const { drdu, dydu } = roofProfileDeriv(crestU);

    // Even count for symmetry; spacing tied to tileW rhythm
    let ridgeCols = Math.max(60, Math.round((2 * Math.PI * rCrest) / (tileW * 1.1)));
    if (ridgeCols % 2) ridgeCols++;                      // force even

    // Phase so a block sits exactly at +Z (gate direction)
    const startAngle = Math.PI / 2;

    const ridgeGeo = new THREE.BoxGeometry(tileW * 1.6, tileH * 1.2, tileD * 1.6);
    const ridgeOut = new THREE.InstancedMesh(ridgeGeo, mRidge, ridgeCols);
    const ridgeIn  = new THREE.InstancedMesh(ridgeGeo, mRidge, ridgeCols);
    ridgeOut.castShadow = ridgeOut.receiveShadow = true;
    ridgeIn.castShadow  = ridgeIn.receiveShadow  = true;

    const lift = 0.52;                                   // distance from crest to each side
    const mm = new THREE.Matrix4(), qq = new THREE.Quaternion();

    for (let i = 0; i < ridgeCols; i++){
      const v = startAngle + (i / ridgeCols) * Math.PI * 2;

      const pv = new THREE.Vector3(-Math.sin(v) * rCrest, 0, Math.cos(v) * rCrest);
      const pu = new THREE.Vector3(Math.cos(v) * drdu, dydu, Math.sin(v) * drdu);
      const n  = pv.clone().cross(pu).normalize();        // outward normal
      const tS = pv.clone().normalize();                  // side
      const tD = pu.clone().normalize().multiplyScalar(-1);

      const basisR = new THREE.Matrix4().makeBasis(tS, n, tD);
      qq.setFromRotationMatrix(basisR);

      const basePos = new THREE.Vector3(Math.cos(v) * rCrest, yCrest, Math.sin(v) * rCrest);

      // OUTER band
      mm.compose(basePos.clone().addScaledVector(n, +lift), qq, new THREE.Vector3(1,1,1));
      ridgeOut.setMatrixAt(i, mm);

      // INNER band
      mm.compose(basePos.clone().addScaledVector(n, -lift), qq, new THREE.Vector3(1,1,1));
      ridgeIn.setMatrixAt(i, mm);
    }
    scene.add(ridgeOut, ridgeIn);
  }
}


/* ------ pagodas & trees (unchanged basics) ------ */
function buildPagodas(){
  const g = new THREE.Group();
  const { count, arcDeg, baseRadius, floors, w, d } = CFG.pagodas;
  const start = -THREE.MathUtils.degToRad(arcDeg/2);
  const step = THREE.MathUtils.degToRad(arcDeg/(count-1));
  for(let i=0;i<count;i++){
    const a = start + i*step;
    const x = Math.sin(a)*baseRadius;
    const z = Math.cos(a)*baseRadius;
    const t = pagoda(floors, w, d);
    t.position.set(x, 0, z);
    t.lookAt(0, t.position.y, 0);
    g.add(t);
  }
  scene.add(g);
}
function pagoda(floors, w, d){
  const g = new THREE.Group();
  const podium = new THREE.Mesh(new THREE.BoxGeometry(w*1.6, 12, d*1.6), mPlaster);
  podium.position.y = 6; podium.castShadow = podium.receiveShadow = true; g.add(podium);
  let y = 12;
  for (let f=0; f<floors; f++){
    const scale = 1 - f*0.07;
    const bw = w*scale, bd = d*scale, bh = 18;
    const body = new THREE.Mesh(new THREE.BoxGeometry(bw, bh, bd), mPlaster);
    body.position.y = y + bh/2; body.castShadow = body.receiveShadow = true; g.add(body);
    const deck = new THREE.Mesh(new THREE.BoxGeometry(bw*1.08, 2.4, bd*1.08), mHorn);
    deck.position.y = body.position.y + bh/2 + 1.4; deck.castShadow = deck.receiveShadow = true; g.add(deck);
    const roof = new THREE.Mesh(new THREE.BoxGeometry(bw*1.24, 6, bd*1.24), mRoof);
    roof.position.y = deck.position.y + 4.4; roof.castShadow = roof.receiveShadow = true; g.add(roof);
    const hornGeo = new THREE.ConeGeometry(3.4, 12, 12);
    [[+1,+1],[+1,-1],[-1,+1],[-1,-1]].forEach(([sx,sz])=>{
      const c = new THREE.Mesh(hornGeo, mHorn);
      c.position.set((bw*0.62)*sx, roof.position.y+6, (bd*0.62)*sz);
      c.rotation.z = sx>0 ? -Math.PI/6 : Math.PI/6;
      c.rotation.x = sz>0 ?  Math.PI/10 : -Math.PI/10;
      c.castShadow = c.receiveShadow = true; g.add(c);
    });
    y = roof.position.y + 5.5;
  }
  const cap = new THREE.Mesh(new THREE.BoxGeometry(w*0.72, 6, d*0.72), mRoof);
  cap.position.y = y + 6; cap.castShadow = cap.receiveShadow = true; g.add(cap);
  return g;
}

function buildTrees(){
  const g = new THREE.Group();
  const rng = mulberry32(4242);
  const r = CFG.arena.radius - 10;
  for(let i=0;i<CFG.trees.count;i++){
    const a = rng()*Math.PI*2;
    const rad = r*Math.sqrt(rng());
    const x = Math.cos(a)*rad, z = Math.sin(a)*rad;
    const h = 7 + rng()*8;
    const trunk = new THREE.Mesh(new THREE.CylinderGeometry(1.5,2.1,h,10), trunkM);
    trunk.position.set(x, h/2, z);
    trunk.castShadow = trunk.receiveShadow = true;
    const c1 = new THREE.Mesh(new THREE.SphereGeometry(5+rng()*3,14,12), canopyM);
    const c2 = new THREE.Mesh(new THREE.SphereGeometry(4+rng()*2,12,10), canopyM);
    c1.position.set(x, h + 3.6, z);
    c2.position.set(x + 1.6, h + 6, z - 1.2);
    c1.castShadow = c1.receiveShadow = c2.castShadow = c2.receiveShadow = true;
    g.add(trunk,c1,c2);
  }
  scene.add(g);
}

/* =========================
   ASSEMBLY
   ========================= */
buildArenaFloor();
buildInnerWallAndGate();
buildShingledDome();   // connected + underlayment + ridge
buildPagodas();
buildTrees();

/* =========================
   LOOP
   ========================= */
addEventListener("resize", ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
(function anim(){ requestAnimationFrame(anim); controls.update(); renderer.render(scene,camera); })();

/* =========================
   UTIL
   ========================= */
function mulberry32(a){return function(){let t=(a+=0x6D2B79F5);t=Math.imul(t^(t>>>15),t|1);t^=t+Math.imul(t^(t>>>7),t|61);return((t^(t>>>14))>>>0)/4294967296;};}
function easeInOut(x, k=2){
  x = THREE.MathUtils.clamp(x,0,1);
  const a = Math.pow(x, k);
  const b = Math.pow(1-x, k);
  return a/(a+b);
}
</script>
</body>
</html>
