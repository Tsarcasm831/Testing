<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Naruto Nature Transformations — Programmatic Bubbles (No Kanji)</title>
<style>
  :root{
    --bg:#0e0e0e; --fg:#eaeaea; --muted:#9ba1a6;
    --fire:#e53935; --water:#1e88e5; --wind:#26a69a; --earth:#8d6e63; --lightning:#fdd835;
    --ice:#7fd3df; --boil:#ef9a9a; --scorch:#ff6f60; --wood:#66bb6a; --dust:#ffcc66;
    --storm:#3b3f63; --explosion:#ff8a65; --magnet:#8e24aa; --lava:#ff7d50; --unknown:#9e9e9e;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);font:14px/1.25 system-ui,Segoe UI,Roboto,Helvetica,Arial}
  #ui{
    position:fixed;inset:auto auto 12px 12px; background:rgba(0,0,0,.55);
    border:1px solid #333;border-radius:12px;padding:10px 12px;backdrop-filter:blur(6px)
  }
  #ui h1{margin:.1rem 0 .35rem 0;font-size:14px}
  #ui label{display:inline-flex;gap:6px;align-items:center;margin-right:10px;opacity:.9}
  svg{display:block;width:100%;height:100vh}
  .edge{fill:none;stroke-width:2.5;opacity:.95}
  .edge.parent{opacity:.9}
  .edge.dominance{stroke:#111;stroke-width:3.5;marker-end:url(#arrow)}
  .node circle{
    stroke:#151515;stroke-width:2.5;filter:url(#shadow);cursor:default;
  }
  .node text{
    fill:#111;font-weight:700;font-size:11px;pointer-events:none;
  }
  .node.basic text{fill:#111}
  .node.combo text{fill:#111}
  .node:hover circle{stroke:#fff;stroke-width:3}
  .hidden{display:none}
  .legend{font-size:12px;fill:var(--muted)}
</style>
</head>
<body>
<div id="ui">
  <h1>Nature Transformations</h1>
  <label><input type="checkbox" id="toggle-labels" checked> Show labels</label>
  <label><input type="checkbox" id="toggle-parent" checked> Show parent edges</label>
  <label><input type="checkbox" id="toggle-dominance" checked> Show dominance cycle</label>
</div>

<svg id="canvas" viewBox="0 0 900 720" role="img" aria-label="Nature transformation bubbles and relationships">
  <defs>
    <filter id="shadow" x="-50%" y="-50%" width="200%" height="200%">
      <feDropShadow dx="0" dy="1.5" stdDeviation="1.5" flood-color="#000" flood-opacity=".55"/>
    </filter>
    <marker id="arrow" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="7.5" markerHeight="7.5" orient="auto-start-reverse">
      <path d="M 0 0 L 10 5 L 0 10 z" fill="#111"/>
    </marker>
  </defs>
  <g id="edges"></g>
  <g id="nodes"></g>

  <!-- Yin–Yang mini diagram -->
  <g id="yin-yang" transform="translate(180,590)">
    <path d="M0,60 Q120,-10 240,20" fill="none" stroke="#bbb" stroke-width="2"/>
    <circle cx="0" cy="60" r="20" fill="#fff" stroke="#111" stroke-width="2.5"/>
    <circle cx="240" cy="20" r="20" fill="#111" stroke="#111" stroke-width="2.5"/>
    <circle cx="120" cy="40" r="16" fill="#fff" stroke="#111" stroke-width="2.5"/>
    <text x="0" y="65" text-anchor="middle" font-weight="700" fill="#111">YANG</text>
    <text x="240" y="25" text-anchor="middle" font-weight="700" fill="#fff">YIN</text>
    <text x="120" y="45" text-anchor="middle" font-weight="700" fill="#111">Yin–Yang</text>
  </g>
</svg>

<script>
/* ---------- Data ---------- */
const COLORS = {
  fire: getCSS('--fire'), water: getCSS('--water'), wind: getCSS('--wind'),
  earth: getCSS('--earth'), lightning: getCSS('--lightning'),
  ice: getCSS('--ice'), boil: getCSS('--boil'), scorch: getCSS('--scorch'),
  wood: getCSS('--wood'), dust: getCSS('--dust'), storm: getCSS('--storm'),
  explosion: getCSS('--explosion'), magnet: getCSS('--magnet'),
  lava: getCSS('--lava'), unknown: getCSS('--unknown')
};

// Basics placed clockwise starting at top to match the usual chart
const basicOrder = ['fire','wind','lightning','earth','water'];

const nodes = [
  // Basic natures (inner ring)
  { id:'fire',      label:'Fire',      type:'basic',   color:COLORS.fire },
  { id:'water',     label:'Water',     type:'basic',   color:COLORS.water },
  { id:'wind',      label:'Wind',      type:'basic',   color:COLORS.wind },
  { id:'earth',     label:'Earth',     type:'basic',   color:COLORS.earth },
  { id:'lightning', label:'Lightning', type:'basic',   color:COLORS.lightning },

  // Combined natures (outer ring) — relationships encoded via parents:[]
  { id:'ice',       label:'Ice',       type:'combo', color:COLORS.ice,       parents:['water','wind'] },
  { id:'boil',      label:'Boil',      type:'combo', color:COLORS.boil,      parents:['water','fire'] },
  { id:'scorch',    label:'Scorch',    type:'combo', color:COLORS.scorch,    parents:['wind','fire'] },
  { id:'wood',      label:'Wood',      type:'combo', color:COLORS.wood,      parents:['water','earth'] },
  // Dust is canonically a kekkei tōta (Wind + Earth + Fire). If you prefer 2-parent,
  // just remove 'fire' here — the renderer handles 2 or 3 parents.
  { id:'dust',      label:'Dust',      type:'combo', color:COLORS.dust,      parents:['wind','earth','fire'] },
  { id:'explosion', label:'Explosion', type:'combo', color:COLORS.explosion, parents:['earth','lightning'] },
  { id:'storm',     label:'Storm',     type:'combo', color:COLORS.storm,     parents:['water','lightning'] },
  { id:'magnet',    label:'Magnet',    type:'combo', color:COLORS.magnet,    parents:['wind','earth'] },
  { id:'lava',      label:'Lava',      type:'combo', color:COLORS.lava,      parents:['fire','earth'] },
  { id:'unknownWL', label:'Unknown',   type:'combo', color:COLORS.unknown,   parents:['wind','lightning'] }
];

// Dominance cycle (directional): Fire → Wind → Lightning → Earth → Water → Fire
const dominance = [
  ['fire','wind'], ['wind','lightning'], ['lightning','earth'],
  ['earth','water'], ['water','fire']
];

/* ---------- Layout ---------- */
const svg = document.getElementById('canvas');
const gEdges = document.getElementById('edges');
const gNodes = document.getElementById('nodes');

const cx = 450, cy = 300; // center of main diagram
const rInner = 150;       // radius for basic natures
const rOuter = 230;       // radius for combined natures
const nodeR  = 24;        // bubble radius

// Place basics evenly
const pos = {};
basicOrder.forEach((id, i) => {
  const angle = (-90 + i * (360/basicOrder.length)) * Math.PI/180;
  pos[id] = polar(cx, cy, rInner, angle);
});

// Place combos at the normalized average direction of their parents on the outer ring
for (const n of nodes.filter(n=>n.type==='combo')) {
  const vec = n.parents.reduce((acc, pid)=>{
    const p = pos[pid];
    const v = {x:(p.x-cx), y:(p.y-cy)};
    return {x:acc.x+v.x, y:acc.y+v.y};
  }, {x:0,y:0});
  const ang = Math.atan2(vec.y, vec.x);
  pos[n.id] = polar(cx, cy, rOuter, ang);
}

/* ---------- Rendering ---------- */
drawParentEdges();
drawDominanceEdges();
drawNodes();

function drawNodes(){
  for (const n of nodes){
    const {x,y} = pos[n.id];
    const g = el('g', {class:`node ${n.type}`, transform:`translate(${x},${y})`});
    const c = el('circle', {r:nodeR, fill:n.color});
    const t = el('text', {textAnchor:'middle', y:4, class:'label'}, n.label);
    g.appendChild(c);
    g.appendChild(t);
    gNodes.appendChild(g);
  }
}

function drawParentEdges(){
  for (const n of nodes.filter(n=>n.type==='combo')){
    const to = pos[n.id];
    n.parents.forEach(pid=>{
      const from = pos[pid];
      const ctrl = radialBetween({x:cx,y:cy}, to, 1.12); // slight outward arc
      const d = `M ${from.x} ${from.y} Q ${ctrl.x} ${ctrl.y} ${to.x} ${to.y}`;
      const edge = el('path', {d, class:'edge parent', stroke: nodes.find(v=>v.id===pid).color});
      gEdges.appendChild(edge);
    });
  }
}

function drawDominanceEdges(){
  dominance.forEach(([a,b])=>{
    const A = pos[a], B = pos[b];
    const ctrl = {x:cx, y:cy}; // curve through center, like the reference image
    const d = `M ${A.x} ${A.y} Q ${ctrl.x} ${ctrl.y} ${B.x} ${B.y}`;
    const e = el('path', {d, class:'edge dominance'});
    gEdges.appendChild(e);
  });
}

/* ---------- Helpers ---------- */
function el(tag, attrs={}, text){
  const e = document.createElementNS('http://www.w3.org/2000/svg', tag);
  for (const [k,v] of Object.entries(attrs)) e.setAttribute(k, v);
  if (text!=null) e.appendChild(document.createTextNode(text));
  return e;
}
function polar(cx,cy,r,ang){ return {x: cx + r*Math.cos(ang), y: cy + r*Math.sin(ang)}; }
function radialBetween(center, point, scale=1){
  const vx = point.x - center.x, vy = point.y - center.y;
  const len = Math.hypot(vx,vy);
  const nx = center.x + (vx/len) * (len*scale);
  const ny = center.y + (vy/len) * (len*scale);
  return {x:nx, y:ny};
}
function getCSS(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }

/* ---------- UI Toggles ---------- */
const cbLabels = document.getElementById('toggle-labels');
const cbParent = document.getElementById('toggle-parent');
const cbDom    = document.getElementById('toggle-dominance');

cbLabels.addEventListener('change', ()=>{
  document.querySelectorAll('.node .label, #yin-yang text').forEach(t=>{
    t.classList.toggle('hidden', !cbLabels.checked);
  });
});
cbParent.addEventListener('change', ()=>{
  document.querySelectorAll('.edge.parent').forEach(e=>{
    e.classList.toggle('hidden', !cbParent.checked);
  });
});
cbDom.addEventListener('change', ()=>{
  document.querySelectorAll('.edge.dominance').forEach(e=>{
    e.classList.toggle('hidden', !cbDom.checked);
  });
});
</script>
</body>
</html>
